{
  "version": 3,
  "sources": ["../../highcharts/highcharts-more.src.js"],
  "sourcesContent": ["/**\n * @license Highcharts JS v10.3.3 (2023-01-20)\n *\n * (c) 2009-2021 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/highcharts-more', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(\n                    new CustomEvent(\n                        'HighchartsModuleLoaded',\n                        { detail: { path: path, module: obj[path] }\n                    })\n                );\n            }\n        }\n    }\n    _registerModule(_modules, 'Extensions/Pane.js', [_modules['Core/Chart/Chart.js'], _modules['Series/CenteredUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Pointer.js'], _modules['Core/Utilities.js']], function (Chart, CU, H, Pointer, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var addEvent = U.addEvent,\n            correctFloat = U.correctFloat,\n            defined = U.defined,\n            extend = U.extend,\n            merge = U.merge,\n            pick = U.pick,\n            splat = U.splat;\n        /**\n         * @typedef {\"arc\"|\"circle\"|\"solid\"} Highcharts.PaneBackgroundShapeValue\n         */\n        /* eslint-disable no-invalid-this, valid-jsdoc */\n        Chart.prototype.collectionsWithUpdate.push('pane');\n        /**\n         * The Pane object allows options that are common to a set of X and Y axes.\n         *\n         * In the future, this can be extended to basic Highcharts and Highcharts Stock.\n         *\n         * @private\n         * @class\n         * @name Highcharts.Pane\n         * @param {Highcharts.PaneOptions} options\n         * @param {Highcharts.Chart} chart\n         */\n        var Pane = /** @class */ (function () {\n                function Pane(options, chart) {\n                    this.background = void 0;\n                this.center = void 0;\n                this.chart = void 0;\n                this.options = void 0;\n                this.coll = 'pane'; // Member of chart.pane\n                /**\n                 * The pane serves as a container for axes and backgrounds for circular\n                 * gauges and polar charts.\n                 *\n                 * @since        2.3.0\n                 * @product      highcharts\n                 * @requires     highcharts-more\n                 * @optionparent pane\n                 */\n                this.defaultOptions = {\n                    /**\n                     * The end angle of the polar X axis or gauge value axis, given in\n                     * degrees where 0 is north. Defaults to [startAngle](#pane.startAngle)\n                     * + 360.\n                     *\n                     * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n                     *         VU-meter with custom start and end angle\n                     *\n                     * @type      {number}\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption pane.endAngle\n                     */\n                    /**\n                     * The center of a polar chart or angular gauge, given as an array\n                     * of [x, y] positions. Positions can be given as integers that\n                     * transform to pixels, or as percentages of the plot area size.\n                     *\n                     * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n                     *         Two gauges with different center\n                     *\n                     * @type    {Array<string|number>}\n                     * @default [\"50%\", \"50%\"]\n                     * @since   2.3.0\n                     * @product highcharts\n                     */\n                    center: ['50%', '50%'],\n                    /**\n                     * The size of the pane, either as a number defining pixels, or a\n                     * percentage defining a percentage of the available plot area (the\n                     * smallest of the plot height or plot width).\n                     *\n                     * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n                     *         Smaller size\n                     *\n                     * @type    {number|string}\n                     * @product highcharts\n                     */\n                    size: '85%',\n                    /**\n                     * The inner size of the pane, either as a number defining pixels, or a\n                     * percentage defining a percentage of the pane's size.\n                     *\n                     * @sample {highcharts} highcharts/series-polar/column-inverted-inner\n                     *         The inner size set to 20%\n                     *\n                     * @type    {number|string}\n                     * @product highcharts\n                     */\n                    innerSize: '0%',\n                    /**\n                     * The start angle of the polar X axis or gauge axis, given in degrees\n                     * where 0 is north. Defaults to 0.\n                     *\n                     * @sample {highcharts} highcharts/demo/gauge-vu-meter/\n                     *         VU-meter with custom start and end angle\n                     *\n                     * @since   2.3.0\n                     * @product highcharts\n                     */\n                    startAngle: 0\n                };\n                /**\n                 * An array of background items for the pane.\n                 *\n                 * @sample {highcharts} highcharts/demo/gauge-speedometer/\n                 *         Speedometer gauge with multiple backgrounds\n                 *\n                 * @type         {Array<*>}\n                 * @optionparent pane.background\n                 */\n                this.defaultBackgroundOptions = {\n                    /**\n                     * The class name for this background.\n                     *\n                     * @sample {highcharts} highcharts/css/pane/\n                     *         Panes styled by CSS\n                     * @sample {highstock} highcharts/css/pane/\n                     *         Panes styled by CSS\n                     * @sample {highmaps} highcharts/css/pane/\n                     *         Panes styled by CSS\n                     *\n                     * @type      {string}\n                     * @default   highcharts-pane\n                     * @since     5.0.0\n                     * @apioption pane.background.className\n                     */\n                    /**\n                     * The shape of the pane background. When `solid`, the background\n                     * is circular. When `arc`, the background extends only from the min\n                     * to the max of the value axis.\n                     *\n                     * @type    {Highcharts.PaneBackgroundShapeValue}\n                     * @since   2.3.0\n                     * @product highcharts\n                     */\n                    shape: 'circle',\n                    /**\n                     * The pixel border width of the pane background.\n                     *\n                     * @since 2.3.0\n                     * @product highcharts\n                     */\n                    borderWidth: 1,\n                    /**\n                     * The pane background border color.\n                     *\n                     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @since   2.3.0\n                     * @product highcharts\n                     */\n                    borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n                    /**\n                     * The background color or gradient for the pane.\n                     *\n                     * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @default { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, #ffffff], [1, #e6e6e6]] }\n                     * @since   2.3.0\n                     * @product highcharts\n                     */\n                    backgroundColor: {\n                        /** @ignore-option */\n                        linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },\n                        /** @ignore-option */\n                        stops: [\n                            [0, \"#ffffff\" /* Palette.backgroundColor */],\n                            [1, \"#e6e6e6\" /* Palette.neutralColor10 */]\n                        ]\n                    },\n                    /** @ignore-option */\n                    from: -Number.MAX_VALUE,\n                    /**\n                     * The inner radius of the pane background. Can be either numeric\n                     * (pixels) or a percentage string.\n                     *\n                     * @type    {number|string}\n                     * @since   2.3.0\n                     * @product highcharts\n                     */\n                    innerRadius: 0,\n                    /** @ignore-option */\n                    to: Number.MAX_VALUE,\n                    /**\n                     * The outer radius of the circular pane background. Can be either\n                     * numeric (pixels) or a percentage string.\n                     *\n                     * @type     {number|string}\n                     * @since    2.3.0\n                     * @product  highcharts\n                     */\n                    outerRadius: '105%'\n                };\n                this.init(options, chart);\n            }\n            /**\n             * Initialize the Pane object\n             *\n             * @private\n             * @function Highcharts.Pane#init\n             *\n             * @param {Highcharts.PaneOptions} options\n             *\n             * @param {Highcharts.Chart} chart\n             */\n            Pane.prototype.init = function (options, chart) {\n                this.chart = chart;\n                this.background = [];\n                chart.pane.push(this);\n                this.setOptions(options);\n            };\n            /**\n             * @private\n             * @function Highcharts.Pane#setOptions\n             *\n             * @param {Highcharts.PaneOptions} options\n             */\n            Pane.prototype.setOptions = function (options) {\n                // Set options. Angular charts have a default background (#3318)\n                this.options = options = merge(this.defaultOptions, this.chart.angular ? { background: {} } : void 0, options);\n            };\n            /**\n             * Render the pane with its backgrounds.\n             *\n             * @private\n             * @function Highcharts.Pane#render\n             */\n            Pane.prototype.render = function () {\n                var options = this.options,\n                    backgroundOption = this.options.background,\n                    renderer = this.chart.renderer,\n                    len,\n                    i;\n                if (!this.group) {\n                    this.group = renderer.g('pane-group')\n                        .attr({ zIndex: options.zIndex || 0 })\n                        .add();\n                }\n                this.updateCenter();\n                // Render the backgrounds\n                if (backgroundOption) {\n                    backgroundOption = splat(backgroundOption);\n                    len = Math.max(backgroundOption.length, this.background.length || 0);\n                    for (i = 0; i < len; i++) {\n                        // #6641 - if axis exists, chart is circular and apply\n                        // background\n                        if (backgroundOption[i] && this.axis) {\n                            this.renderBackground(merge(this.defaultBackgroundOptions, backgroundOption[i]), i);\n                        }\n                        else if (this.background[i]) {\n                            this.background[i] = this.background[i].destroy();\n                            this.background.splice(i, 1);\n                        }\n                    }\n                }\n            };\n            /**\n             * Render an individual pane background.\n             *\n             * @private\n             * @function Highcharts.Pane#renderBackground\n             *\n             * @param {Highcharts.PaneBackgroundOptions} backgroundOptions\n             *        Background options\n             *\n             * @param {number} i\n             *        The index of the background in this.backgrounds\n             */\n            Pane.prototype.renderBackground = function (backgroundOptions, i) {\n                var method = 'animate',\n                    attribs = {\n                        'class': 'highcharts-pane ' + (backgroundOptions.className || '')\n                    };\n                if (!this.chart.styledMode) {\n                    extend(attribs, {\n                        'fill': backgroundOptions.backgroundColor,\n                        'stroke': backgroundOptions.borderColor,\n                        'stroke-width': backgroundOptions.borderWidth\n                    });\n                }\n                if (!this.background[i]) {\n                    this.background[i] = this.chart.renderer\n                        .path()\n                        .add(this.group);\n                    method = 'attr';\n                }\n                this.background[i][method]({\n                    'd': this.axis.getPlotBandPath(backgroundOptions.from, backgroundOptions.to, backgroundOptions)\n                }).attr(attribs);\n            };\n            /**\n             * Gets the center for the pane and its axis.\n             *\n             * @private\n             * @function Highcharts.Pane#updateCenter\n             * @param {Highcharts.Axis} [axis]\n             */\n            Pane.prototype.updateCenter = function (axis) {\n                this.center = (axis ||\n                    this.axis ||\n                    {}).center = CU.getCenter.call(this);\n            };\n            /**\n             * Destroy the pane item\n             *\n             * @ignore\n             * @private\n             * @function Highcharts.Pane#destroy\n             * /\n            destroy: function () {\n                erase(this.chart.pane, this);\n                this.background.forEach(function (background) {\n                    background.destroy();\n                });\n                this.background.length = 0;\n                this.group = this.group.destroy();\n            },\n            */\n            /**\n             * Update the pane item with new options\n             *\n             * @private\n             * @function Highcharts.Pane#update\n             * @param {Highcharts.PaneOptions} options\n             *        New pane options\n             * @param {boolean} [redraw]\n             */\n            Pane.prototype.update = function (options, redraw) {\n                merge(true, this.options, options);\n                this.setOptions(this.options);\n                this.render();\n                this.chart.axes.forEach(function (axis) {\n                    if (axis.pane === this) {\n                        axis.pane = null;\n                        axis.update({}, redraw);\n                    }\n                }, this);\n            };\n            return Pane;\n        }());\n        /**\n         * Check whether element is inside or outside pane.\n         * @private\n         * @param  {number} x\n         * Element's x coordinate\n         * @param  {number} y\n         * Element's y coordinate\n         * @param  {Array<number>} inverted\n         * `Chart.inverted` param\n         * @param  {Array<number>} center\n         * Pane's center (x, y) and diameter\n         * @param  {number} startAngle\n         * Pane's normalized start angle in radians (<-PI, PI>)\n         * @param  {number} endAngle\n         * Pane's normalized end angle in radians (<-PI, PI>)\n         */\n        function isInsidePane(x, y, center, startAngle, endAngle) {\n            var insideSlice = true;\n            var cx = center[0],\n                cy = center[1];\n            var distance = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2));\n            if (defined(startAngle) && defined(endAngle)) {\n                // Round angle to N-decimals to avoid numeric errors\n                var angle = Math.atan2(correctFloat(y - cy, 8),\n                    correctFloat(x - cx, 8));\n                // Ignore full circle panes:\n                if (endAngle !== startAngle) {\n                    // If normalized start angle is bigger than normalized end,\n                    // it means angles have different signs. In such situation we\n                    // check the <-PI, startAngle> and <endAngle, PI> ranges.\n                    if (startAngle > endAngle) {\n                        insideSlice = (angle >= startAngle &&\n                            angle <= Math.PI) || (angle <= endAngle &&\n                            angle >= -Math.PI);\n                    }\n                    else {\n                        // In this case, we simple check if angle is within the\n                        // <startAngle, endAngle> range\n                        insideSlice = angle >= startAngle &&\n                            angle <= correctFloat(endAngle, 8);\n                    }\n                }\n            }\n            // Round up radius because x and y values are rounded\n            return distance <= Math.ceil(center[2] / 2) && insideSlice;\n        }\n        Chart.prototype.getHoverPane = function (eventArgs) {\n            var chart = this;\n            var hoverPane;\n            if (eventArgs) {\n                chart.pane.forEach(function (pane) {\n                    var x = eventArgs.chartX - chart.plotLeft,\n                        y = eventArgs.chartY - chart.plotTop;\n                    if (isInsidePane(x, y, pane.center)) {\n                        hoverPane = pane;\n                    }\n                });\n            }\n            return hoverPane;\n        };\n        // Check if (x, y) position is within pane for polar\n        addEvent(Chart, 'afterIsInsidePlot', function (e) {\n            var _a;\n            var chart = this;\n            if (chart.polar) {\n                if (e.options.inverted) {\n                    _a = [e.y, e.x], e.x = _a[0], e.y = _a[1];\n                }\n                e.isInsidePlot = chart.pane.some(function (pane) { return isInsidePane(e.x, e.y, pane.center, pane.axis && pane.axis.normalizedStartAngleRad, pane.axis && pane.axis.normalizedEndAngleRad); });\n            }\n        });\n        addEvent(Pointer, 'beforeGetHoverData', function (eventArgs) {\n            var chart = this.chart;\n            if (chart.polar) {\n                // Find pane we are currently hovering over.\n                chart.hoverPane = chart.getHoverPane(eventArgs);\n                // Edit filter method to handle polar\n                eventArgs.filter = function (s) {\n                    return (s.visible &&\n                        !(!eventArgs.shared && s.directTouch) && // #3821\n                        pick(s.options.enableMouseTracking, true) &&\n                        (!chart.hoverPane || s.xAxis.pane === chart.hoverPane));\n                };\n            }\n            else {\n                chart.hoverPane = void 0;\n            }\n        });\n        addEvent(Pointer, 'afterGetHoverData', function (eventArgs) {\n            var chart = this.chart;\n            if (eventArgs.hoverPoint &&\n                eventArgs.hoverPoint.plotX &&\n                eventArgs.hoverPoint.plotY &&\n                chart.hoverPane &&\n                !isInsidePane(eventArgs.hoverPoint.plotX, eventArgs.hoverPoint.plotY, chart.hoverPane.center)) {\n                eventArgs.hoverPoint = void 0;\n            }\n        });\n        H.Pane = Pane;\n\n        return H.Pane;\n    });\n    _registerModule(_modules, 'Series/AreaRange/AreaRangePoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var _a = SeriesRegistry.seriesTypes.area.prototype,\n            AreaPoint = _a.pointClass,\n            areaProto = _a.pointClass.prototype;\n        var defined = U.defined,\n            isNumber = U.isNumber;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var AreaRangePoint = /** @class */ (function (_super) {\n                __extends(AreaRangePoint, _super);\n            function AreaRangePoint() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /**\n                 * Range series only. The high or maximum value for each data point.\n                 * @name Highcharts.Point#high\n                 * @type {number|undefined}\n                 */\n                _this.high = void 0;\n                /**\n                 * Range series only. The low or minimum value for each data point.\n                 * @name Highcharts.Point#low\n                 * @type {number|undefined}\n                 */\n                _this.low = void 0;\n                _this.options = void 0;\n                _this.plotX = void 0;\n                _this.series = void 0;\n                return _this;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            AreaRangePoint.prototype.setState = function () {\n                var prevState = this.state,\n                    series = this.series,\n                    isPolar = series.chart.polar;\n                if (!defined(this.plotHigh)) {\n                    // Boost doesn't calculate plotHigh\n                    this.plotHigh = series.yAxis.toPixels(this.high, true);\n                }\n                if (!defined(this.plotLow)) {\n                    // Boost doesn't calculate plotLow\n                    this.plotLow = this.plotY = series.yAxis.toPixels(this.low, true);\n                }\n                if (series.stateMarkerGraphic) {\n                    series.lowerStateMarkerGraphic = series.stateMarkerGraphic;\n                    series.stateMarkerGraphic = series.upperStateMarkerGraphic;\n                }\n                // Change state also for the top marker\n                this.graphic = this.graphics && this.graphics[1];\n                this.plotY = this.plotHigh;\n                if (isPolar && isNumber(this.plotHighX)) {\n                    this.plotX = this.plotHighX;\n                }\n                // Top state:\n                areaProto.setState.apply(this, arguments);\n                this.state = prevState;\n                // Now restore defaults\n                this.plotY = this.plotLow;\n                this.graphic = this.graphics && this.graphics[0];\n                if (isPolar && isNumber(this.plotLowX)) {\n                    this.plotX = this.plotLowX;\n                }\n                if (series.stateMarkerGraphic) {\n                    series.upperStateMarkerGraphic = series.stateMarkerGraphic;\n                    series.stateMarkerGraphic = series.lowerStateMarkerGraphic;\n                    // Lower marker is stored at stateMarkerGraphic\n                    // to avoid reference duplication (#7021)\n                    series.lowerStateMarkerGraphic = void 0;\n                }\n                areaProto.setState.apply(this, arguments);\n            };\n            AreaRangePoint.prototype.haloPath = function () {\n                var isPolar = this.series.chart.polar;\n                var path = [];\n                // Bottom halo\n                this.plotY = this.plotLow;\n                if (isPolar && isNumber(this.plotLowX)) {\n                    this.plotX = this.plotLowX;\n                }\n                if (this.isInside) {\n                    path = areaProto.haloPath.apply(this, arguments);\n                }\n                // Top halo\n                this.plotY = this.plotHigh;\n                if (isPolar && isNumber(this.plotHighX)) {\n                    this.plotX = this.plotHighX;\n                }\n                if (this.isTopInside) {\n                    path = path.concat(areaProto.haloPath.apply(this, arguments));\n                }\n                return path;\n            };\n            AreaRangePoint.prototype.isValid = function () {\n                return isNumber(this.low) && isNumber(this.high);\n            };\n            return AreaRangePoint;\n        }(AreaPoint));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AreaRangePoint;\n    });\n    _registerModule(_modules, 'Series/AreaRange/AreaRangeSeries.js', [_modules['Series/AreaRange/AreaRangePoint.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (AreaRangePoint, H, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var noop = H.noop;\n        var _a = SeriesRegistry.seriesTypes,\n            AreaSeries = _a.area,\n            areaProto = _a.area.prototype,\n            columnProto = _a.column.prototype;\n        var addEvent = U.addEvent,\n            defined = U.defined,\n            extend = U.extend,\n            isArray = U.isArray,\n            isNumber = U.isNumber,\n            pick = U.pick,\n            merge = U.merge;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * The area range series is a carteseian series with higher and lower values for\n         * each point along an X axis, where the area between the values is shaded.\n         *\n         * @sample {highcharts} highcharts/demo/arearange/\n         *         Area range chart\n         * @sample {highstock} stock/demo/arearange/\n         *         Area range chart\n         *\n         * @extends      plotOptions.area\n         * @product      highcharts highstock\n         * @excluding    stack, stacking\n         * @requires     highcharts-more\n         * @optionparent plotOptions.arearange\n         *\n         * @private\n         */\n        var areaRangeSeriesOptions = {\n                /**\n                 * @see [fillColor](#plotOptions.arearange.fillColor)\n                 * @see [fillOpacity](#plotOptions.arearange.fillOpacity)\n                 *\n                 * @apioption plotOptions.arearange.color\n                 */\n                /**\n                 * @default   low\n                 * @apioption plotOptions.arearange.colorKey\n                 */\n                /**\n                 * @see [color](#plotOptions.arearange.color)\n                 * @see [fillOpacity](#plotOptions.arearange.fillOpacity)\n                 *\n                 * @apioption plotOptions.arearange.fillColor\n                 */\n                /**\n                 * @see [color](#plotOptions.arearange.color)\n                 * @see [fillColor](#plotOptions.arearange.fillColor)\n                 *\n                 * @default   {highcharts} 0.75\n                 * @default   {highstock} 0.75\n                 * @apioption plotOptions.arearange.fillOpacity\n                 */\n                /**\n                 * Whether to apply a drop shadow to the graph line. Since 2.3 the\n                 * shadow can be an object configuration containing `color`,\n            `offsetX`,\n                 * `offsetY`,\n            `opacity` and `width`.\n                 *\n                 * @type      {boolean|Highcharts.ShadowOptionsObject}\n                 * @product   highcharts\n                 * @apioption plotOptions.arearange.shadow\n                 */\n                /**\n                 * Pixel width of the arearange graph line.\n                 *\n                 * @since 2.3.0\n                 *\n                 * @private\n                 */\n                lineWidth: 1,\n                /**\n                 * @type {number|null}\n                 */\n                threshold: null,\n                tooltip: {\n                    pointFormat: '<span style=\"color:{series.color}\">\\u25CF</span> ' +\n                        '{series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n                },\n                /**\n                 * Whether the whole area or just the line should respond to mouseover\n                 * tooltips and other mouse or touch events.\n                 *\n                 * @since 2.3.0\n                 *\n                 * @private\n                 */\n                trackByArea: true,\n                /**\n                 * Extended data labels for range series types. Range series data\n                 * labels use no `x` and `y` options. Instead,\n            they have `xLow`,\n                 * `xHigh`,\n            `yLow` and `yHigh` options to allow the higher and lower\n                 * data label sets individually.\n                 *\n                 * @declare Highcharts.SeriesAreaRangeDataLabelsOptionsObject\n                 * @exclude x,\n            y\n                 * @since   2.3.0\n                 * @product highcharts highstock\n                 *\n                 * @private\n                 */\n                dataLabels: {\n                    align: void 0,\n                    verticalAlign: void 0,\n                    /**\n                     * X offset of the lower data labels relative to the point value.\n                     *\n                     * @sample highcharts/plotoptions/arearange-datalabels/\n                     *         Data labels on range series\n                     * @sample highcharts/plotoptions/arearange-datalabels/\n                     *         Data labels on range series\n                     */\n                    xLow: 0,\n                    /**\n                     * X offset of the higher data labels relative to the point value.\n                     *\n                     * @sample highcharts/plotoptions/arearange-datalabels/\n                     *         Data labels on range series\n                     */\n                    xHigh: 0,\n                    /**\n                     * Y offset of the lower data labels relative to the point value.\n                     *\n                     * @sample highcharts/plotoptions/arearange-datalabels/\n                     *         Data labels on range series\n                     */\n                    yLow: 0,\n                    /**\n                     * Y offset of the higher data labels relative to the point value.\n                     *\n                     * @sample highcharts/plotoptions/arearange-datalabels/\n                     *         Data labels on range series\n                     */\n                    yHigh: 0\n                }\n            };\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The AreaRange series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.arearange\n         *\n         * @augments Highcharts.Series\n         */\n        var AreaRangeSeries = /** @class */ (function (_super) {\n                __extends(AreaRangeSeries, _super);\n            function AreaRangeSeries() {\n                /**\n                 *\n                 *  Static Properties\n                 *\n                 */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                _this.lowerStateMarkerGraphic = void 0;\n                _this.xAxis = void 0;\n                return _this;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            AreaRangeSeries.prototype.toYData = function (point) {\n                return [point.low, point.high];\n            };\n            /**\n             * Translate a point's plotHigh from the internal angle and radius measures\n             * to true plotHigh coordinates. This is an addition of the toXY method\n             * found in Polar.js, because it runs too early for arearanges to be\n             * considered (#3419).\n             * @private\n             */\n            AreaRangeSeries.prototype.highToXY = function (point) {\n                // Find the polar plotX and plotY\n                var chart = this.chart,\n                    xy = this.xAxis.postTranslate(point.rectPlotX || 0,\n                    this.yAxis.len - (point.plotHigh || 0));\n                point.plotHighX = xy.x - chart.plotLeft;\n                point.plotHigh = xy.y - chart.plotTop;\n                point.plotLowX = point.plotX;\n            };\n            /**\n             * Extend the line series' getSegmentPath method by applying the segment\n             * path to both lower and higher values of the range.\n             * @private\n             */\n            AreaRangeSeries.prototype.getGraphPath = function (points) {\n                var highPoints = [],\n                    highAreaPoints = [],\n                    getGraphPath = areaProto.getGraphPath,\n                    options = this.options,\n                    polar = this.chart.polar,\n                    connectEnds = polar && options.connectEnds !== false,\n                    connectNulls = options.connectNulls;\n                var i,\n                    point,\n                    pointShim,\n                    step = options.step;\n                points = points || this.points;\n                // Create the top line and the top part of the area fill. The area fill\n                // compensates for null points by drawing down to the lower graph,\n                // moving across the null gap and starting again at the lower graph.\n                i = points.length;\n                while (i--) {\n                    point = points[i];\n                    // Support for polar\n                    var highAreaPoint = polar ? {\n                            plotX: point.rectPlotX,\n                            plotY: point.yBottom,\n                            doCurve: false // #5186, gaps in areasplinerange fill\n                        } : {\n                            plotX: point.plotX,\n                            plotY: point.plotY,\n                            doCurve: false // #5186, gaps in areasplinerange fill\n                        };\n                    if (!point.isNull &&\n                        !connectEnds &&\n                        !connectNulls &&\n                        (!points[i + 1] || points[i + 1].isNull)) {\n                        highAreaPoints.push(highAreaPoint);\n                    }\n                    pointShim = {\n                        polarPlotY: point.polarPlotY,\n                        rectPlotX: point.rectPlotX,\n                        yBottom: point.yBottom,\n                        // plotHighX is for polar charts\n                        plotX: pick(point.plotHighX, point.plotX),\n                        plotY: point.plotHigh,\n                        isNull: point.isNull\n                    };\n                    highAreaPoints.push(pointShim);\n                    highPoints.push(pointShim);\n                    if (!point.isNull &&\n                        !connectEnds &&\n                        !connectNulls &&\n                        (!points[i - 1] || points[i - 1].isNull)) {\n                        highAreaPoints.push(highAreaPoint);\n                    }\n                }\n                // Get the paths\n                var lowerPath = getGraphPath.call(this,\n                    points);\n                if (step) {\n                    if (step === true) {\n                        step = 'left';\n                    }\n                    options.step = {\n                        left: 'right',\n                        center: 'center',\n                        right: 'left'\n                    }[step]; // swap for reading in getGraphPath\n                }\n                var higherPath = getGraphPath.call(this,\n                    highPoints);\n                var higherAreaPath = getGraphPath.call(this,\n                    highAreaPoints);\n                options.step = step;\n                // Create a line on both top and bottom of the range\n                var linePath = [].concat(lowerPath,\n                    higherPath);\n                // For the area path, we need to change the 'move' statement into\n                // 'lineTo'\n                if (!this.chart.polar &&\n                    higherAreaPath[0] &&\n                    higherAreaPath[0][0] === 'M') {\n                    // This probably doesn't work for spline\n                    higherAreaPath[0] = [\n                        'L',\n                        higherAreaPath[0][1],\n                        higherAreaPath[0][2]\n                    ];\n                }\n                this.graphPath = linePath;\n                this.areaPath = lowerPath.concat(higherAreaPath);\n                // Prepare for sideways animation\n                linePath.isArea = true;\n                linePath.xMap = lowerPath.xMap;\n                this.areaPath.xMap = lowerPath.xMap;\n                return linePath;\n            };\n            /**\n             * Extend the basic drawDataLabels method by running it for both lower and\n             * higher values.\n             * @private\n             */\n            AreaRangeSeries.prototype.drawDataLabels = function () {\n                var data = this.points,\n                    length = data.length,\n                    originalDataLabels = [],\n                    dataLabelOptions = this.options.dataLabels,\n                    inverted = this.chart.inverted;\n                var i,\n                    point,\n                    up,\n                    upperDataLabelOptions,\n                    lowerDataLabelOptions;\n                if (dataLabelOptions) {\n                    // Split into upper and lower options. If data labels is an array,\n                    // the first element is the upper label, the second is the lower.\n                    //\n                    // TODO: We want to change this and allow multiple labels for both\n                    // upper and lower values in the future - introducing some options\n                    // for which point value to use as Y for the dataLabel, so that this\n                    // could be handled in Series.drawDataLabels. This would also\n                    // improve performance since we now have to loop over all the points\n                    // multiple times to work around the data label logic.\n                    if (isArray(dataLabelOptions)) {\n                        upperDataLabelOptions = dataLabelOptions[0] || {\n                            enabled: false\n                        };\n                        lowerDataLabelOptions = dataLabelOptions[1] || {\n                            enabled: false\n                        };\n                    }\n                    else {\n                        // Make copies\n                        upperDataLabelOptions = extend({}, dataLabelOptions);\n                        upperDataLabelOptions.x = dataLabelOptions.xHigh;\n                        upperDataLabelOptions.y = dataLabelOptions.yHigh;\n                        lowerDataLabelOptions = extend({}, dataLabelOptions);\n                        lowerDataLabelOptions.x = dataLabelOptions.xLow;\n                        lowerDataLabelOptions.y = dataLabelOptions.yLow;\n                    }\n                    // Draw upper labels\n                    if (upperDataLabelOptions.enabled || this._hasPointLabels) {\n                        // Set preliminary values for plotY and dataLabel\n                        // and draw the upper labels\n                        i = length;\n                        while (i--) {\n                            point = data[i];\n                            if (point) {\n                                var _a = point.plotHigh,\n                                    plotHigh = _a === void 0 ? 0 : _a,\n                                    _b = point.plotLow,\n                                    plotLow = _b === void 0 ? 0 : _b;\n                                up = upperDataLabelOptions.inside ?\n                                    plotHigh < plotLow :\n                                    plotHigh > plotLow;\n                                point.y = point.high;\n                                point._plotY = point.plotY;\n                                point.plotY = plotHigh;\n                                // Store original data labels and set preliminary label\n                                // objects to be picked up in the uber method\n                                originalDataLabels[i] = point.dataLabel;\n                                point.dataLabel = point.dataLabelUpper;\n                                // Set the default offset\n                                point.below = up;\n                                if (inverted) {\n                                    if (!upperDataLabelOptions.align) {\n                                        upperDataLabelOptions.align = up ?\n                                            'right' : 'left';\n                                    }\n                                }\n                                else {\n                                    if (!upperDataLabelOptions.verticalAlign) {\n                                        upperDataLabelOptions.verticalAlign = up ?\n                                            'top' :\n                                            'bottom';\n                                    }\n                                }\n                            }\n                        }\n                        this.options.dataLabels = upperDataLabelOptions;\n                        if (areaProto.drawDataLabels) {\n                            // #1209:\n                            areaProto.drawDataLabels.apply(this, arguments);\n                        }\n                        // Reset state after the upper labels were created. Move\n                        // it to point.dataLabelUpper and reassign the originals.\n                        // We do this here to support not drawing a lower label.\n                        i = length;\n                        while (i--) {\n                            point = data[i];\n                            if (point) {\n                                point.dataLabelUpper = point.dataLabel;\n                                point.dataLabel = originalDataLabels[i];\n                                delete point.dataLabels;\n                                point.y = point.low;\n                                point.plotY = point._plotY;\n                            }\n                        }\n                    }\n                    // Draw lower labels\n                    if (lowerDataLabelOptions.enabled || this._hasPointLabels) {\n                        i = length;\n                        while (i--) {\n                            point = data[i];\n                            if (point) {\n                                var _c = point.plotHigh,\n                                    plotHigh = _c === void 0 ? 0 : _c,\n                                    _d = point.plotLow,\n                                    plotLow = _d === void 0 ? 0 : _d;\n                                up = lowerDataLabelOptions.inside ?\n                                    plotHigh < plotLow :\n                                    plotHigh > plotLow;\n                                // Set the default offset\n                                point.below = !up;\n                                if (inverted) {\n                                    if (!lowerDataLabelOptions.align) {\n                                        lowerDataLabelOptions.align = up ?\n                                            'left' : 'right';\n                                    }\n                                }\n                                else {\n                                    if (!lowerDataLabelOptions.verticalAlign) {\n                                        lowerDataLabelOptions.verticalAlign = up ?\n                                            'bottom' :\n                                            'top';\n                                    }\n                                }\n                            }\n                        }\n                        this.options.dataLabels = lowerDataLabelOptions;\n                        if (areaProto.drawDataLabels) {\n                            areaProto.drawDataLabels.apply(this, arguments);\n                        }\n                    }\n                    // Merge upper and lower into point.dataLabels for later destroying\n                    if (upperDataLabelOptions.enabled) {\n                        i = length;\n                        while (i--) {\n                            point = data[i];\n                            if (point) {\n                                point.dataLabels = [\n                                    point.dataLabelUpper,\n                                    point.dataLabel\n                                ].filter(function (label) {\n                                    return !!label;\n                                });\n                            }\n                        }\n                    }\n                    // Reset options\n                    this.options.dataLabels = dataLabelOptions;\n                }\n            };\n            AreaRangeSeries.prototype.alignDataLabel = function () {\n                columnProto.alignDataLabel.apply(this, arguments);\n            };\n            AreaRangeSeries.prototype.drawPoints = function () {\n                var series = this,\n                    pointLength = series.points.length;\n                var i,\n                    point;\n                // Draw bottom points\n                areaProto.drawPoints.apply(series, arguments);\n                // Prepare drawing top points\n                i = 0;\n                while (i < pointLength) {\n                    point = series.points[i];\n                    /**\n                     * Array for multiple SVG graphics representing the point in the\n                     * chart. Only used in cases where the point can not be represented\n                     * by a single graphic.\n                     *\n                     * @see Highcharts.Point#graphic\n                     *\n                     * @name Highcharts.Point#graphics\n                     * @type {Array<Highcharts.SVGElement>|undefined}\n                     */\n                    point.graphics = point.graphics || [];\n                    // Save original props to be overridden by temporary props for top\n                    // points\n                    point.origProps = {\n                        plotY: point.plotY,\n                        plotX: point.plotX,\n                        isInside: point.isInside,\n                        negative: point.negative,\n                        zone: point.zone,\n                        y: point.y\n                    };\n                    if (point.graphic || point.graphics[0]) {\n                        point.graphics[0] = point.graphic;\n                    }\n                    point.graphic = point.graphics[1];\n                    point.plotY = point.plotHigh;\n                    if (defined(point.plotHighX)) {\n                        point.plotX = point.plotHighX;\n                    }\n                    point.y = pick(point.high, point.origProps.y); // #15523\n                    point.negative = point.y < (series.options.threshold || 0);\n                    if (series.zones.length) {\n                        point.zone = point.getZone();\n                    }\n                    if (!series.chart.polar) {\n                        point.isInside = point.isTopInside = (typeof point.plotY !== 'undefined' &&\n                            point.plotY >= 0 &&\n                            point.plotY <= series.yAxis.len && // #3519\n                            point.plotX >= 0 &&\n                            point.plotX <= series.xAxis.len);\n                    }\n                    i++;\n                }\n                // Draw top points\n                areaProto.drawPoints.apply(series, arguments);\n                // Reset top points preliminary modifications\n                i = 0;\n                while (i < pointLength) {\n                    point = series.points[i];\n                    point.graphics = point.graphics || [];\n                    if (point.graphic || point.graphics[1]) {\n                        point.graphics[1] = point.graphic;\n                    }\n                    point.graphic = point.graphics[0];\n                    if (point.origProps) {\n                        extend(point, point.origProps);\n                        delete point.origProps;\n                    }\n                    i++;\n                }\n            };\n            AreaRangeSeries.defaultOptions = merge(AreaSeries.defaultOptions, areaRangeSeriesOptions);\n            return AreaRangeSeries;\n        }(AreaSeries));\n        addEvent(AreaRangeSeries, 'afterTranslate', function () {\n            // Set plotLow and plotHigh\n            var _this = this;\n            // Rules out lollipop, but lollipop should not inherit range series in the\n            // first place\n            if (this.pointArrayMap.join(',') === 'low,high') {\n                this.points.forEach(function (point) {\n                    var high = point.high,\n                        plotY = point.plotY;\n                    if (point.isNull) {\n                        point.plotY = void 0;\n                    }\n                    else {\n                        point.plotLow = plotY;\n                        // Calculate plotHigh value based on each yAxis scale (#15752)\n                        point.plotHigh = isNumber(high) ? _this.yAxis.translate(_this.dataModify ?\n                            _this.dataModify.modifyValue(high) : high, false, true, void 0, true) : void 0;\n                        if (_this.dataModify) {\n                            point.yBottom = point.plotHigh;\n                        }\n                    }\n                });\n            }\n        }, { order: 0 });\n        addEvent(AreaRangeSeries, 'afterTranslate', function () {\n            var _this = this;\n            var inverted = this.chart.inverted;\n            this.points.forEach(function (point) {\n                // Postprocessing after the PolarComposition's afterTranslate\n                if (_this.chart.polar) {\n                    _this.highToXY(point);\n                    point.plotLow = point.plotY;\n                    point.tooltipPos = [\n                        ((point.plotHighX || 0) + (point.plotLowX || 0)) / 2,\n                        ((point.plotHigh || 0) + (point.plotLow || 0)) / 2\n                    ];\n                    // Put the tooltip in the middle of the range\n                }\n                else {\n                    var tooltipPos = point.pos(false,\n                        point.plotLow),\n                        posHigh = point.pos(false,\n                        point.plotHigh);\n                    if (tooltipPos && posHigh) {\n                        tooltipPos[0] = (tooltipPos[0] + posHigh[0]) / 2;\n                        tooltipPos[1] = (tooltipPos[1] + posHigh[1]) / 2;\n                    }\n                    point.tooltipPos = tooltipPos;\n                }\n            });\n        }, { order: 3 });\n        extend(AreaRangeSeries.prototype, {\n            deferTranslatePolar: true,\n            pointArrayMap: ['low', 'high'],\n            pointClass: AreaRangePoint,\n            pointValKey: 'low',\n            setStackedPoints: noop\n        });\n        SeriesRegistry.registerSeriesType('arearange', AreaRangeSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `arearange` series. If the [type](#series.arearange.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         *\n         * @extends   series,plotOptions.arearange\n         * @excluding dataParser, dataURL, stack, stacking\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption series.arearange\n         */\n        /**\n         * @see [fillColor](#series.arearange.fillColor)\n         * @see [fillOpacity](#series.arearange.fillOpacity)\n         *\n         * @apioption series.arearange.color\n         */\n        /**\n         * An array of data points for the series. For the `arearange` series type,\n         * points can be given in the following ways:\n         *\n         * 1.  An array of arrays with 3 or 2 values. In this case, the values\n         *     correspond to `x,low,high`. If the first value is a string, it is\n         *     applied as the name of the point, and the `x` value is inferred.\n         *     The `x` value can also be omitted, in which case the inner arrays\n         *     should be of length 2\\. Then the `x` value is automatically calculated,\n         *     either starting at 0 and incremented by 1, or from `pointStart`\n         *     and `pointInterval` given in the series options.\n         *     ```js\n         *     data: [\n         *         [0, 8, 3],\n         *         [1, 1, 1],\n         *         [2, 6, 8]\n         *     ]\n         *     ```\n         *\n         * 2.  An array of objects with named values. The following snippet shows only a\n         *     few settings, see the complete options set below. If the total number of\n         *     data points exceeds the series'\n         *     [turboThreshold](#series.arearange.turboThreshold),\n         *     this option is not available.\n         *     ```js\n         *     data: [{\n         *         x: 1,\n         *         low: 9,\n         *         high: 0,\n         *         name: \"Point2\",\n         *         color: \"#00FF00\"\n         *     }, {\n         *         x: 1,\n         *         low: 3,\n         *         high: 4,\n         *         name: \"Point1\",\n         *         color: \"#FF00FF\"\n         *     }]\n         *     ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n         * @extends   series.line.data\n         * @excluding marker, y\n         * @product   highcharts highstock\n         * @apioption series.arearange.data\n         */\n        /**\n         * @extends   series.arearange.dataLabels\n         * @product   highcharts highstock\n         * @apioption series.arearange.data.dataLabels\n         */\n        /**\n         * @see [color](#series.arearange.color)\n         * @see [fillOpacity](#series.arearange.fillOpacity)\n         *\n         * @apioption series.arearange.fillColor\n         */\n        /**\n         * @see [color](#series.arearange.color)\n         * @see [fillColor](#series.arearange.fillColor)\n         *\n         * @default   {highcharts} 0.75\n         * @default   {highstock} 0.75\n         * @apioption series.arearange.fillOpacity\n         */\n        /**\n         * The high or maximum value for each data point.\n         *\n         * @type      {number}\n         * @product   highcharts highstock\n         * @apioption series.arearange.data.high\n         */\n        /**\n         * The low or minimum value for each data point.\n         *\n         * @type      {number}\n         * @product   highcharts highstock\n         * @apioption series.arearange.data.low\n         */\n        ''; // adds doclets above to tranpiled file\n\n        return AreaRangeSeries;\n    });\n    _registerModule(_modules, 'Series/AreaSplineRange/AreaSplineRangeSeries.js', [_modules['Series/AreaRange/AreaRangeSeries.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (AreaRangeSeries, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var splineProto = SeriesRegistry.seriesTypes.spline.prototype;\n        var merge = U.merge,\n            extend = U.extend;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The areasplinerange series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.areasplinerange\n         *\n         * @augments Highcharts.Series\n         */\n        var AreaSplineRangeSeries = /** @class */ (function (_super) {\n                __extends(AreaSplineRangeSeries, _super);\n            function AreaSplineRangeSeries() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.options = void 0;\n                _this.data = void 0;\n                _this.points = void 0;\n                return _this;\n            }\n            AreaSplineRangeSeries.defaultOptions = merge(AreaRangeSeries.defaultOptions);\n            return AreaSplineRangeSeries;\n        }(AreaRangeSeries));\n        extend(AreaSplineRangeSeries.prototype, {\n            getPointSpline: splineProto.getPointSpline\n        });\n        SeriesRegistry.registerSeriesType('areasplinerange', AreaSplineRangeSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * The area spline range is a cartesian series type with higher and\n         * lower Y values along an X axis. The area inside the range is colored, and\n         * the graph outlining the area is a smoothed spline.\n         *\n         * @sample {highstock|highstock} stock/demo/areasplinerange/\n         *         Area spline range\n         *\n         * @extends   plotOptions.arearange\n         * @since     2.3.0\n         * @excluding step, boostThreshold, boostBlending\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption plotOptions.areasplinerange\n         */\n        /**\n         * @see [fillColor](#plotOptions.areasplinerange.fillColor)\n         * @see [fillOpacity](#plotOptions.areasplinerange.fillOpacity)\n         *\n         * @apioption plotOptions.areasplinerange.color\n         */\n        /**\n         * @see [color](#plotOptions.areasplinerange.color)\n         * @see [fillOpacity](#plotOptions.areasplinerange.fillOpacity)\n         *\n         * @apioption plotOptions.areasplinerange.fillColor\n         */\n        /**\n         * @see [color](#plotOptions.areasplinerange.color)\n         * @see [fillColor](#plotOptions.areasplinerange.fillColor)\n         *\n         * @default   0.75\n         * @apioption plotOptions.areasplinerange.fillOpacity\n         */\n        /**\n         * A `areasplinerange` series. If the [type](#series.areasplinerange.type)\n         * option is not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.areasplinerange\n         * @excluding dataParser, dataURL, stack, step, boostThreshold, boostBlending\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption series.areasplinerange\n         */\n        /**\n         * @see [fillColor](#series.areasplinerange.fillColor)\n         * @see [fillOpacity](#series.areasplinerange.fillOpacity)\n         *\n         * @apioption series.areasplinerange.color\n         */\n        /**\n         * An array of data points for the series. For the `areasplinerange`\n         * series type, points can be given in the following ways:\n         *\n         * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n         *    to `x,low,high`. If the first value is a string, it is applied as the name\n         *    of the point, and the `x` value is inferred. The `x` value can also be\n         *    omitted, in which case the inner arrays should be of length 2\\. Then the\n         *    `x` value is automatically calculated, either starting at 0 and\n         *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n         *    series options.\n         *    ```js\n         *    data: [\n         *        [0, 0, 5],\n         *        [1, 9, 1],\n         *        [2, 5, 2]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.areasplinerange.turboThreshold), this option is\n         *    not available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        low: 5,\n         *        high: 0,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        low: 4,\n         *        high: 1,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n         * @extends   series.arearange.data\n         * @product   highcharts highstock\n         * @apioption series.areasplinerange.data\n         */\n        /**\n         * @see [color](#series.areasplinerange.color)\n         * @see [fillOpacity](#series.areasplinerange.fillOpacity)\n         *\n         * @apioption series.areasplinerange.fillColor\n         */\n        /**\n         * @see [color](#series.areasplinerange.color)\n         * @see [fillColor](#series.areasplinerange.fillColor)\n         *\n         * @default   0.75\n         * @apioption series.areasplinerange.fillOpacity\n         */\n        ''; // adds doclets above to transpiled file\n\n        return AreaSplineRangeSeries;\n    });\n    _registerModule(_modules, 'Series/BoxPlot/BoxPlotSeries.js', [_modules['Series/Column/ColumnSeries.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (ColumnSeries, H, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var noop = H.noop;\n        var extend = U.extend,\n            merge = U.merge,\n            pick = U.pick;\n        /**\n         * The boxplot series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes#boxplot\n         *\n         * @augments Highcharts.Series\n         */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var BoxPlotSeries = /** @class */ (function (_super) {\n                __extends(BoxPlotSeries, _super);\n            function BoxPlotSeries() {\n                /* *\n                 *\n                 * Static Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                return _this;\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            // Get presentational attributes\n            BoxPlotSeries.prototype.pointAttribs = function () {\n                // No attributes should be set on point.graphic which is the group\n                return {};\n            };\n            // Translate data points from raw values x and y to plotX and plotY\n            BoxPlotSeries.prototype.translate = function () {\n                var series = this,\n                    yAxis = series.yAxis,\n                    pointArrayMap = series.pointArrayMap;\n                _super.prototype.translate.apply(series);\n                // do the translation on each point dimension\n                series.points.forEach(function (point) {\n                    pointArrayMap.forEach(function (key) {\n                        if (point[key] !== null) {\n                            point[key + 'Plot'] = yAxis.translate(point[key], 0, 1, 0, 1);\n                        }\n                    });\n                    point.plotHigh = point.highPlot; // For data label validation\n                });\n            };\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Draw the data points\n             * @private\n             */\n            BoxPlotSeries.prototype.drawPoints = function () {\n                var series = this,\n                    points = series.points,\n                    options = series.options,\n                    chart = series.chart,\n                    renderer = chart.renderer,\n                    q1Plot,\n                    q3Plot,\n                    highPlot,\n                    lowPlot,\n                    medianPlot,\n                    medianPath,\n                    crispCorr,\n                    crispX = 0,\n                    boxPath,\n                    width,\n                    left,\n                    right,\n                    halfWidth, \n                    // error bar inherits this series type but doesn't do quartiles\n                    doQuartiles = series.doQuartiles !== false,\n                    pointWiskerLength,\n                    whiskerLength = series.options.whiskerLength;\n                points.forEach(function (point) {\n                    var graphic = point.graphic,\n                        verb = graphic ? 'animate' : 'attr',\n                        shapeArgs = point.shapeArgs,\n                        boxAttr = {},\n                        stemAttr = {},\n                        whiskersAttr = {},\n                        medianAttr = {},\n                        color = point.color || series.color;\n                    if (typeof point.plotY !== 'undefined') {\n                        // crisp vector coordinates\n                        width = Math.round(shapeArgs.width);\n                        left = Math.floor(shapeArgs.x);\n                        right = left + width;\n                        halfWidth = Math.round(width / 2);\n                        q1Plot = Math.floor(doQuartiles ? point.q1Plot : point.lowPlot);\n                        q3Plot = Math.floor(doQuartiles ? point.q3Plot : point.lowPlot);\n                        highPlot = Math.floor(point.highPlot);\n                        lowPlot = Math.floor(point.lowPlot);\n                        if (!graphic) {\n                            point.graphic = graphic = renderer.g('point')\n                                .add(series.group);\n                            point.stem = renderer.path()\n                                .addClass('highcharts-boxplot-stem')\n                                .add(graphic);\n                            if (whiskerLength) {\n                                point.whiskers = renderer.path()\n                                    .addClass('highcharts-boxplot-whisker')\n                                    .add(graphic);\n                            }\n                            if (doQuartiles) {\n                                point.box = renderer.path(boxPath)\n                                    .addClass('highcharts-boxplot-box')\n                                    .add(graphic);\n                            }\n                            point.medianShape = renderer.path(medianPath)\n                                .addClass('highcharts-boxplot-median')\n                                .add(graphic);\n                        }\n                        if (!chart.styledMode) {\n                            // Stem attributes\n                            stemAttr.stroke =\n                                point.stemColor || options.stemColor || color;\n                            stemAttr['stroke-width'] = pick(point.stemWidth, options.stemWidth, options.lineWidth);\n                            stemAttr.dashstyle = (point.stemDashStyle ||\n                                options.stemDashStyle ||\n                                options.dashStyle);\n                            point.stem.attr(stemAttr);\n                            // Whiskers attributes\n                            if (whiskerLength) {\n                                whiskersAttr.stroke = (point.whiskerColor ||\n                                    options.whiskerColor ||\n                                    color);\n                                whiskersAttr['stroke-width'] = pick(point.whiskerWidth, options.whiskerWidth, options.lineWidth);\n                                whiskersAttr.dashstyle = (point.whiskerDashStyle ||\n                                    options.whiskerDashStyle ||\n                                    options.dashStyle);\n                                point.whiskers.attr(whiskersAttr);\n                            }\n                            if (doQuartiles) {\n                                boxAttr.fill = (point.fillColor ||\n                                    options.fillColor ||\n                                    color);\n                                boxAttr.stroke = options.lineColor || color;\n                                boxAttr['stroke-width'] = options.lineWidth || 0;\n                                boxAttr.dashstyle = (point.boxDashStyle ||\n                                    options.boxDashStyle ||\n                                    options.dashStyle);\n                                point.box.attr(boxAttr);\n                            }\n                            // Median attributes\n                            medianAttr.stroke = (point.medianColor ||\n                                options.medianColor ||\n                                color);\n                            medianAttr['stroke-width'] = pick(point.medianWidth, options.medianWidth, options.lineWidth);\n                            medianAttr.dashstyle = (point.medianDashStyle ||\n                                options.medianDashStyle ||\n                                options.dashStyle);\n                            point.medianShape.attr(medianAttr);\n                        }\n                        var d = void 0;\n                        // The stem\n                        crispCorr = (point.stem.strokeWidth() % 2) / 2;\n                        crispX = left + halfWidth + crispCorr;\n                        d = [\n                            // stem up\n                            ['M', crispX, q3Plot],\n                            ['L', crispX, highPlot],\n                            // stem down\n                            ['M', crispX, q1Plot],\n                            ['L', crispX, lowPlot]\n                        ];\n                        point.stem[verb]({ d: d });\n                        // The box\n                        if (doQuartiles) {\n                            crispCorr = (point.box.strokeWidth() % 2) / 2;\n                            q1Plot = Math.floor(q1Plot) + crispCorr;\n                            q3Plot = Math.floor(q3Plot) + crispCorr;\n                            left += crispCorr;\n                            right += crispCorr;\n                            d = [\n                                ['M', left, q3Plot],\n                                ['L', left, q1Plot],\n                                ['L', right, q1Plot],\n                                ['L', right, q3Plot],\n                                ['L', left, q3Plot],\n                                ['Z']\n                            ];\n                            point.box[verb]({ d: d });\n                        }\n                        // The whiskers\n                        if (whiskerLength) {\n                            crispCorr = (point.whiskers.strokeWidth() % 2) / 2;\n                            highPlot = highPlot + crispCorr;\n                            lowPlot = lowPlot + crispCorr;\n                            pointWiskerLength = (/%$/).test(whiskerLength) ?\n                                halfWidth * parseFloat(whiskerLength) / 100 :\n                                whiskerLength / 2;\n                            d = [\n                                // High whisker\n                                ['M', crispX - pointWiskerLength, highPlot],\n                                ['L', crispX + pointWiskerLength, highPlot],\n                                // Low whisker\n                                ['M', crispX - pointWiskerLength, lowPlot],\n                                ['L', crispX + pointWiskerLength, lowPlot]\n                            ];\n                            point.whiskers[verb]({ d: d });\n                        }\n                        // The median\n                        medianPlot = Math.round(point.medianPlot);\n                        crispCorr = (point.medianShape.strokeWidth() % 2) / 2;\n                        medianPlot = medianPlot + crispCorr;\n                        d = [\n                            ['M', left, medianPlot],\n                            ['L', right, medianPlot]\n                        ];\n                        point.medianShape[verb]({ d: d });\n                    }\n                });\n            };\n            // return a plain array for speedy calculation\n            BoxPlotSeries.prototype.toYData = function (point) {\n                return [point.low, point.q1, point.median, point.q3, point.high];\n            };\n            /**\n             * A box plot is a convenient way of depicting groups of data through their\n             * five-number summaries: the smallest observation (sample minimum), lower\n             * quartile (Q1), median (Q2), upper quartile (Q3), and largest observation\n             * (sample maximum).\n             *\n             * @sample highcharts/demo/box-plot/\n             *         Box plot\n             *\n             * @extends      plotOptions.column\n             * @excluding    borderColor, borderRadius, borderWidth, groupZPadding,\n             *               states, boostThreshold, boostBlending\n             * @product      highcharts\n             * @requires     highcharts-more\n             * @optionparent plotOptions.boxplot\n             */\n            BoxPlotSeries.defaultOptions = merge(ColumnSeries.defaultOptions, {\n                /**\n                 * @type {number|null}\n                 */\n                threshold: null,\n                tooltip: {\n                    pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> <b>' +\n                        '{series.name}</b><br/>' +\n                        'Maximum: {point.high}<br/>' +\n                        'Upper quartile: {point.q3}<br/>' +\n                        'Median: {point.median}<br/>' +\n                        'Lower quartile: {point.q1}<br/>' +\n                        'Minimum: {point.low}<br/>'\n                },\n                /**\n                 * The length of the whiskers, the horizontal lines marking low and\n                 * high values. It can be a numerical pixel value, or a percentage\n                 * value of the box width. Set `0` to disable whiskers.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         True by default\n                 *\n                 * @type    {number|string}\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                whiskerLength: '50%',\n                /**\n                 * The fill color of the box.\n                 *\n                 * In styled mode, the fill color can be set with the\n                 * `.highcharts-boxplot-box` class.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 *\n                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @default #ffffff\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                fillColor: \"#ffffff\" /* Palette.backgroundColor */,\n                /**\n                 * The width of the line surrounding the box. If any of\n                 * [stemWidth](#plotOptions.boxplot.stemWidth),\n                 * [medianWidth](#plotOptions.boxplot.medianWidth)\n                 * or [whiskerWidth](#plotOptions.boxplot.whiskerWidth) are `null`,\n                 * the lineWidth also applies to these lines.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                lineWidth: 1,\n                /**\n                 * The color of the median line. If `undefined`, the general series\n                 * color applies.\n                 *\n                 * In styled mode, the median stroke width can be set with the\n                 * `.highcharts-boxplot-median` class.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject}\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.medianColor\n                 */\n                /**\n                 * The pixel width of the median line. If `null`, the\n                 * [lineWidth](#plotOptions.boxplot.lineWidth) is used.\n                 *\n                 * In styled mode, the median stroke width can be set with the\n                 * `.highcharts-boxplot-median` class.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 *\n                 * @type    {number|null}\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                medianWidth: 2,\n                /*\n                // States are not working and are removed from docs.\n                // Refer to: #2340\n                states: {\n                    hover: {\n                        brightness: -0.3\n                    }\n                },\n                */\n                /**\n                 * The color of the stem, the vertical line extending from the box to\n                 * the whiskers. If `undefined`, the series color is used.\n                 *\n                 * In styled mode, the stem stroke can be set with the\n                 * `.highcharts-boxplot-stem` class.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.stemColor\n                 */\n                /**\n                 * The dash style of the box.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 *\n                 * @type      {Highcharts.DashStyleValue}\n                 * @default   Solid\n                 * @since 8.1.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.boxDashStyle\n                 */\n                /**\n                 * The dash style of the median.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 *\n                 * @type      {Highcharts.DashStyleValue}\n                 * @default   Solid\n                 * @since 8.1.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.medianDashStyle\n                 */\n                /**\n                 * The dash style of the stem, the vertical line extending from the\n                 * box to the whiskers.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @type      {Highcharts.DashStyleValue}\n                 * @default   Solid\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.stemDashStyle\n                 */\n                /**\n                 * The dash style of the whiskers.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 *\n                 * @type      {Highcharts.DashStyleValue}\n                 * @default   Solid\n                 * @since 8.1.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.whiskerDashStyle\n                 */\n                /**\n                 * The width of the stem, the vertical line extending from the box to\n                 * the whiskers. If `undefined`, the width is inherited from the\n                 * [lineWidth](#plotOptions.boxplot.lineWidth) option.\n                 *\n                 * In styled mode, the stem stroke width can be set with the\n                 * `.highcharts-boxplot-stem` class.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @type      {number}\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.stemWidth\n                 */\n                /**\n                 * @default   high\n                 * @apioption plotOptions.boxplot.colorKey\n                 */\n                /**\n                 * The color of the whiskers, the horizontal lines marking low and high\n                 * values. When `undefined`, the general series color is used.\n                 *\n                 * In styled mode, the whisker stroke can be set with the\n                 * `.highcharts-boxplot-whisker` class .\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.boxplot.whiskerColor\n                 */\n                /**\n                 * The line width of the whiskers, the horizontal lines marking low and\n                 * high values. When `undefined`, the general\n                 * [lineWidth](#plotOptions.boxplot.lineWidth) applies.\n                 *\n                 * In styled mode, the whisker stroke width can be set with the\n                 * `.highcharts-boxplot-whisker` class.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n                 *         Box plot styling\n                 * @sample {highcharts} highcharts/css/boxplot/\n                 *         Box plot in styled mode\n                 *\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                whiskerWidth: 2\n            });\n            return BoxPlotSeries;\n        }(ColumnSeries));\n        extend(BoxPlotSeries.prototype, {\n            // array point configs are mapped to this\n            pointArrayMap: ['low', 'q1', 'median', 'q3', 'high'],\n            // defines the top of the tracker\n            pointValKey: 'high',\n            // Disable data labels for box plot\n            drawDataLabels: noop,\n            setStackedPoints: noop // #3890\n        });\n        /* *\n         *\n         * Registry\n         *\n         * */\n        SeriesRegistry.registerSeriesType('boxplot', BoxPlotSeries);\n        /* *\n         *\n         * Default Export\n         *\n         * */\n        /* *\n         *\n         * API Options\n         *\n         * */\n        /**\n         * A `boxplot` series. If the [type](#series.boxplot.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.boxplot\n         * @excluding dataParser, dataURL, marker, stack, stacking, states,\n         *            boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  highcharts-more\n         * @apioption series.boxplot\n         */\n        /**\n         * An array of data points for the series. For the `boxplot` series\n         * type, points can be given in the following ways:\n         *\n         * 1. An array of arrays with 6 or 5 values. In this case, the values correspond\n         *    to `x,low,q1,median,q3,high`. If the first value is a string, it is\n         *    applied as the name of the point, and the `x` value is inferred. The `x`\n         *    value can also be omitted, in which case the inner arrays should be of\n         *    length 5. Then the `x` value is automatically calculated, either starting\n         *    at 0 and incremented by 1, or from `pointStart` and `pointInterval` given\n         *    in the series options.\n         *    ```js\n         *    data: [\n         *        [0, 3, 0, 10, 3, 5],\n         *        [1, 7, 8, 7, 2, 9],\n         *        [2, 6, 9, 5, 1, 3]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.boxplot.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        low: 4,\n         *        q1: 9,\n         *        median: 9,\n         *        q3: 1,\n         *        high: 10,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        low: 5,\n         *        q1: 7,\n         *        median: 3,\n         *        q3: 6,\n         *        high: 2,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number,number,number,number>|Array<(number|string),number,number,number,number,number>|*>}\n         * @extends   series.line.data\n         * @excluding marker\n         * @product   highcharts\n         * @apioption series.boxplot.data\n         */\n        /**\n         * The `high` value for each data point, signifying the highest value\n         * in the sample set. The top whisker is drawn here.\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption series.boxplot.data.high\n         */\n        /**\n         * The `low` value for each data point, signifying the lowest value\n         * in the sample set. The bottom whisker is drawn here.\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption series.boxplot.data.low\n         */\n        /**\n         * The median for each data point. This is drawn as a line through the\n         * middle area of the box.\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption series.boxplot.data.median\n         */\n        /**\n         * The lower quartile for each data point. This is the bottom of the\n         * box.\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption series.boxplot.data.q1\n         */\n        /**\n         * The higher quartile for each data point. This is the top of the box.\n         *\n         * @type      {number}\n         * @product   highcharts\n         * @apioption series.boxplot.data.q3\n         */\n        /**\n         * The dash style of the box.\n         *\n         * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n         *         Box plot styling\n         * @sample {highcharts} highcharts/css/boxplot/\n         *         Box plot in styled mode\n         *\n         * @type      {Highcharts.DashStyleValue}\n         * @default   Solid\n         * @since 8.1.0\n         * @product   highcharts\n         * @apioption series.boxplot.data.boxDashStyle\n         */\n        /**\n         * The dash style of the median.\n         *\n         * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n         *         Box plot styling\n         * @sample {highcharts} highcharts/css/boxplot/\n         *         Box plot in styled mode\n         *\n         * @type      {Highcharts.DashStyleValue}\n         * @default   Solid\n         * @since 8.1.0\n         * @product   highcharts\n         * @apioption series.boxplot.data.medianDashStyle\n         */\n        /**\n         * The dash style of the stem.\n         *\n         * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n         *         Box plot styling\n         * @sample {highcharts} highcharts/css/boxplot/\n         *         Box plot in styled mode\n         *\n         * @type      {Highcharts.DashStyleValue}\n         * @default   Solid\n         * @since 8.1.0\n         * @product   highcharts\n         * @apioption series.boxplot.data.stemDashStyle\n         */\n        /**\n         * The dash style of the whiskers.\n         *\n         * @sample {highcharts} highcharts/plotoptions/box-plot-styling/\n         *         Box plot styling\n         * @sample {highcharts} highcharts/css/boxplot/\n         *         Box plot in styled mode\n         *\n         * @type      {Highcharts.DashStyleValue}\n         * @default   Solid\n         * @since 8.1.0\n         * @product   highcharts\n         * @apioption series.boxplot.data.whiskerDashStyle\n         */\n        ''; // adds doclets above to transpiled file\n\n        return BoxPlotSeries;\n    });\n    _registerModule(_modules, 'Series/Bubble/BubbleLegendDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2021 Highsoft AS\n         *\n         *  Author: Pawe Potaczek\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * The bubble legend is an additional element in legend which\n         * presents the scale of the bubble series. Individual bubble ranges\n         * can be defined by user or calculated from series. In the case of\n         * automatically calculated ranges, a 1px margin of error is\n         * permitted.\n         *\n         * @since        7.0.0\n         * @product      highcharts highstock highmaps\n         * @requires     highcharts-more\n         * @optionparent legend.bubbleLegend\n         */\n        var BubbleLegendDefaults = {\n                /**\n                 * The color of the ranges borders,\n            can be also defined for an\n                 * individual range.\n                 *\n                 * @sample highcharts/bubble-legend/similartoseries/\n                 *         Similar look to the bubble series\n                 * @sample highcharts/bubble-legend/bordercolor/\n                 *         Individual bubble border color\n                 *\n                 * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 */\n                borderColor: void 0,\n                /**\n                 * The width of the ranges borders in pixels,\n            can be also\n                 * defined for an individual range.\n                 */\n                borderWidth: 2,\n                /**\n                 * An additional class name to apply to the bubble legend'\n                 * circle graphical elements. This option does not replace\n                 * default class names of the graphical element.\n                 *\n                 * @sample {highcharts} highcharts/css/bubble-legend/\n                 *         Styling by CSS\n                 *\n                 * @type {string}\n                 */\n                className: void 0,\n                /**\n                 * The main color of the bubble legend. Applies to ranges,\n            if\n                 * individual color is not defined.\n                 *\n                 * @sample highcharts/bubble-legend/similartoseries/\n                 *         Similar look to the bubble series\n                 * @sample highcharts/bubble-legend/color/\n                 *         Individual bubble color\n                 *\n                 * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 */\n                color: void 0,\n                /**\n                 * An additional class name to apply to the bubble legend's\n                 * connector graphical elements. This option does not replace\n                 * default class names of the graphical element.\n                 *\n                 * @sample {highcharts} highcharts/css/bubble-legend/\n                 *         Styling by CSS\n                 *\n                 * @type {string}\n                 */\n                connectorClassName: void 0,\n                /**\n                 * The color of the connector,\n            can be also defined\n                 * for an individual range.\n                 *\n                 * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 */\n                connectorColor: void 0,\n                /**\n                 * The length of the connectors in pixels. If labels are\n                 * centered,\n            the distance is reduced to 0.\n                 *\n                 * @sample highcharts/bubble-legend/connectorandlabels/\n                 *         Increased connector length\n                 */\n                connectorDistance: 60,\n                /**\n                 * The width of the connectors in pixels.\n                 *\n                 * @sample highcharts/bubble-legend/connectorandlabels/\n                 *         Increased connector width\n                 */\n                connectorWidth: 1,\n                /**\n                 * Enable or disable the bubble legend.\n                 */\n                enabled: false,\n                /**\n                 * Options for the bubble legend labels.\n                 */\n                labels: {\n                    /**\n                     * An additional class name to apply to the bubble legend\n                     * label graphical elements. This option does not replace\n                     * default class names of the graphical element.\n                     *\n                     * @sample {highcharts} highcharts/css/bubble-legend/\n                     *         Styling by CSS\n                     *\n                     * @type {string}\n                     */\n                    className: void 0,\n                    /**\n                     * Whether to allow data labels to overlap.\n                     */\n                    allowOverlap: false,\n                    /**\n                     * A format string for the bubble legend labels. Available\n                     * variables are the same as for `formatter`.\n                     *\n                     * @sample highcharts/bubble-legend/format/\n                     *         Add a unit\n                     *\n                     * @type {string}\n                     */\n                    format: '',\n                    /**\n                     * Available `this` properties are:\n                     *\n                     * - `this.value`: The bubble value.\n                     *\n                     * - `this.radius`: The radius of the bubble range.\n                     *\n                     * - `this.center`: The center y position of the range.\n                     *\n                     * @type {Highcharts.FormatterCallbackFunction<Highcharts.BubbleLegendFormatterContextObject>}\n                     */\n                    formatter: void 0,\n                    /**\n                     * The alignment of the labels compared to the bubble\n                     * legend. Can be one of `left`,\n            `center` or `right`.\n                     *\n                     * @sample highcharts/bubble-legend/connectorandlabels/\n                     *         Labels on left\n                     *\n                     * @type {Highcharts.AlignValue}\n                     */\n                    align: 'right',\n                    /**\n                     * CSS styles for the labels.\n                     *\n                     * @type {Highcharts.CSSObject}\n                     */\n                    style: {\n                        /** @ignore-option */\n                        fontSize: '10px',\n                        /** @ignore-option */\n                        color: \"#000000\" /* Palette.neutralColor100 */\n                    },\n                    /**\n                     * The x position offset of the label relative to the\n                     * connector.\n                     */\n                    x: 0,\n                    /**\n                     * The y position offset of the label relative to the\n                     * connector.\n                     */\n                    y: 0\n                },\n                /**\n                 * Miximum bubble legend range size. If values for ranges are\n                 * not specified,\n            the `minSize` and the `maxSize` are calculated\n                 * from bubble series.\n                 */\n                maxSize: 60,\n                /**\n                 * Minimum bubble legend range size. If values for ranges are\n                 * not specified,\n            the `minSize` and the `maxSize` are calculated\n                 * from bubble series.\n                 */\n                minSize: 10,\n                /**\n                 * The position of the bubble legend in the legend.\n                 * @sample highcharts/bubble-legend/connectorandlabels/\n                 *         Bubble legend as last item in legend\n                 */\n                legendIndex: 0,\n                /**\n                 * Options for specific range. One range consists of bubble,\n                 * label and connector.\n                 *\n                 * @sample highcharts/bubble-legend/ranges/\n                 *         Manually defined ranges\n                 * @sample highcharts/bubble-legend/autoranges/\n                 *         Auto calculated ranges\n                 *\n                 * @type {Array<*>}\n                 */\n                ranges: {\n                    /**\n                     * Range size value,\n            similar to bubble Z data.\n                     * @type {number}\n                     */\n                    value: void 0,\n                    /**\n                     * The color of the border for individual range.\n                     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     */\n                    borderColor: void 0,\n                    /**\n                     * The color of the bubble for individual range.\n                     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     */\n                    color: void 0,\n                    /**\n                     * The color of the connector for individual range.\n                     * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     */\n                    connectorColor: void 0\n                },\n                /**\n                 * Whether the bubble legend range value should be represented\n                 * by the area or the width of the bubble. The default,\n            area,\n                 * corresponds best to the human perception of the size of each\n                 * bubble.\n                 *\n                 * @sample highcharts/bubble-legend/ranges/\n                 *         Size by width\n                 *\n                 * @type {Highcharts.BubbleSizeByValue}\n                 */\n                sizeBy: 'area',\n                /**\n                 * When this is true,\n            the absolute value of z determines the\n                 * size of the bubble. This means that with the default\n                 * zThreshold of 0,\n            a bubble of value -1 will have the same size\n                 * as a bubble of value 1,\n            while a bubble of value 0 will have a\n                 * smaller size according to minSize.\n                 */\n                sizeByAbsoluteValue: false,\n                /**\n                 * Define the visual z index of the bubble legend.\n                 */\n                zIndex: 1,\n                /**\n                 * Ranges with with lower value than zThreshold,\n            are skipped.\n                 */\n                zThreshold: 0\n            };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return BubbleLegendDefaults;\n    });\n    _registerModule(_modules, 'Series/Bubble/BubbleLegendItem.js', [_modules['Core/Color/Color.js'], _modules['Core/FormatUtilities.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (Color, F, H, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Highsoft AS\n         *\n         *  Author: Pawe Potaczek\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var color = Color.parse;\n        var noop = H.noop;\n        var arrayMax = U.arrayMax,\n            arrayMin = U.arrayMin,\n            isNumber = U.isNumber,\n            merge = U.merge,\n            pick = U.pick,\n            stableSort = U.stableSort;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * BubbleLegend class.\n         *\n         * @private\n         * @class\n         * @name Highcharts.BubbleLegend\n         * @param {Highcharts.LegendBubbleLegendOptions} options\n         * Options of BubbleLegendItem.\n         *\n         * @param {Highcharts.Legend} legend\n         * Legend of item.\n         */\n        var BubbleLegendItem = /** @class */ (function () {\n                /* *\n                 *\n                 *  Constructor\n                 *\n                 * */\n                function BubbleLegendItem(options, legend) {\n                    /* *\n                     *\n                     *  Properties\n                     *\n                     * */\n                    this.chart = void 0;\n                this.fontMetrics = void 0;\n                this.legend = void 0;\n                this.maxLabel = void 0;\n                this.movementX = void 0;\n                this.ranges = void 0;\n                this.selected = void 0;\n                this.visible = void 0;\n                this.symbols = void 0;\n                this.options = void 0;\n                this.setState = noop;\n                this.init(options, legend);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Create basic bubbleLegend properties similar to item in legend.\n             * @private\n             */\n            BubbleLegendItem.prototype.init = function (options, legend) {\n                this.options = options;\n                this.visible = true;\n                this.chart = legend.chart;\n                this.legend = legend;\n            };\n            /**\n             * Depending on the position option, add bubbleLegend to legend items.\n             *\n             * @private\n             *\n             * @param {Array<(Highcharts.Point|Highcharts.Series)>} items\n             *        All legend items\n             */\n            BubbleLegendItem.prototype.addToLegend = function (items) {\n                // Insert bubbleLegend into legend items\n                items.splice(this.options.legendIndex, 0, this);\n            };\n            /**\n             * Calculate ranges, sizes and call the next steps of bubbleLegend\n             * creation.\n             *\n             * @private\n             *\n             * @param {Highcharts.Legend} legend\n             *        Legend instance\n             */\n            BubbleLegendItem.prototype.drawLegendSymbol = function (legend) {\n                var chart = this.chart,\n                    itemDistance = pick(legend.options.itemDistance, 20),\n                    legendItem = this.legendItem || {},\n                    options = this.options,\n                    ranges = options.ranges,\n                    connectorDistance = options.connectorDistance;\n                var connectorSpace;\n                // Predict label dimensions\n                this.fontMetrics = chart.renderer.fontMetrics(options.labels.style.fontSize);\n                // Do not create bubbleLegend now if ranges or ranges valeus are not\n                // specified or if are empty array.\n                if (!ranges || !ranges.length || !isNumber(ranges[0].value)) {\n                    legend.options.bubbleLegend.autoRanges = true;\n                    return;\n                }\n                // Sort ranges to right render order\n                stableSort(ranges, function (a, b) {\n                    return b.value - a.value;\n                });\n                this.ranges = ranges;\n                this.setOptions();\n                this.render();\n                // Get max label size\n                var maxLabel = this.getMaxLabelSize(),\n                    radius = this.ranges[0].radius,\n                    size = radius * 2;\n                // Space for connectors and labels.\n                connectorSpace =\n                    connectorDistance - radius + maxLabel.width;\n                connectorSpace = connectorSpace > 0 ? connectorSpace : 0;\n                this.maxLabel = maxLabel;\n                this.movementX = options.labels.align === 'left' ?\n                    connectorSpace : 0;\n                legendItem.labelWidth = size + connectorSpace + itemDistance;\n                legendItem.labelHeight = size + this.fontMetrics.h / 2;\n            };\n            /**\n             * Set style options for each bubbleLegend range.\n             * @private\n             */\n            BubbleLegendItem.prototype.setOptions = function () {\n                var ranges = this.ranges,\n                    options = this.options,\n                    series = this.chart.series[options.seriesIndex],\n                    baseline = this.legend.baseline,\n                    bubbleAttribs = {\n                        zIndex: options.zIndex,\n                        'stroke-width': options.borderWidth\n                    },\n                    connectorAttribs = {\n                        zIndex: options.zIndex,\n                        'stroke-width': options.connectorWidth\n                    },\n                    labelAttribs = {\n                        align: (this.legend.options.rtl ||\n                            options.labels.align === 'left') ? 'right' : 'left',\n                        zIndex: options.zIndex\n                    },\n                    fillOpacity = series.options.marker.fillOpacity,\n                    styledMode = this.chart.styledMode;\n                // Allow to parts of styles be used individually for range\n                ranges.forEach(function (range, i) {\n                    if (!styledMode) {\n                        bubbleAttribs.stroke = pick(range.borderColor, options.borderColor, series.color);\n                        bubbleAttribs.fill = pick(range.color, options.color, fillOpacity !== 1 ?\n                            color(series.color).setOpacity(fillOpacity)\n                                .get('rgba') :\n                            series.color);\n                        connectorAttribs.stroke = pick(range.connectorColor, options.connectorColor, series.color);\n                    }\n                    // Set options needed for rendering each range\n                    ranges[i].radius = this.getRangeRadius(range.value);\n                    ranges[i] = merge(ranges[i], {\n                        center: (ranges[0].radius - ranges[i].radius +\n                            baseline)\n                    });\n                    if (!styledMode) {\n                        merge(true, ranges[i], {\n                            bubbleAttribs: merge(bubbleAttribs),\n                            connectorAttribs: merge(connectorAttribs),\n                            labelAttribs: labelAttribs\n                        });\n                    }\n                }, this);\n            };\n            /**\n             * Calculate radius for each bubble range,\n             * used code from BubbleSeries.js 'getRadius' method.\n             *\n             * @private\n             *\n             * @param {number} value\n             *        Range value\n             *\n             * @return {number|null}\n             *         Radius for one range\n             */\n            BubbleLegendItem.prototype.getRangeRadius = function (value) {\n                var options = this.options,\n                    seriesIndex = this.options.seriesIndex,\n                    bubbleSeries = this.chart.series[seriesIndex],\n                    zMax = options.ranges[0].value,\n                    zMin = options.ranges[options.ranges.length - 1].value,\n                    minSize = options.minSize,\n                    maxSize = options.maxSize;\n                return bubbleSeries.getRadius.call(this, zMin, zMax, minSize, maxSize, value);\n            };\n            /**\n             * Render the legendItem group.\n             * @private\n             */\n            BubbleLegendItem.prototype.render = function () {\n                var legendItem = this.legendItem || {},\n                    renderer = this.chart.renderer,\n                    zThreshold = this.options.zThreshold;\n                if (!this.symbols) {\n                    this.symbols = {\n                        connectors: [],\n                        bubbleItems: [],\n                        labels: []\n                    };\n                }\n                // Nesting SVG groups to enable handleOverflow\n                legendItem.symbol = renderer.g('bubble-legend');\n                legendItem.label = renderer.g('bubble-legend-item');\n                // To enable default 'hideOverlappingLabels' method\n                legendItem.symbol.translateX = 0;\n                legendItem.symbol.translateY = 0;\n                for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {\n                    var range = _a[_i];\n                    if (range.value >= zThreshold) {\n                        this.renderRange(range);\n                    }\n                }\n                // To use handleOverflow method\n                legendItem.symbol.add(legendItem.label);\n                legendItem.label.add(legendItem.group);\n                this.hideOverlappingLabels();\n            };\n            /**\n             * Render one range, consisting of bubble symbol, connector and label.\n             *\n             * @private\n             *\n             * @param {Highcharts.LegendBubbleLegendRangesOptions} range\n             *        Range options\n             */\n            BubbleLegendItem.prototype.renderRange = function (range) {\n                var mainRange = this.ranges[0],\n                    legend = this.legend,\n                    options = this.options,\n                    labelsOptions = options.labels,\n                    chart = this.chart,\n                    bubbleSeries = chart.series[options.seriesIndex],\n                    renderer = chart.renderer,\n                    symbols = this.symbols,\n                    labels = symbols.labels,\n                    elementCenter = range.center,\n                    absoluteRadius = Math.abs(range.radius),\n                    connectorDistance = options.connectorDistance || 0,\n                    labelsAlign = labelsOptions.align,\n                    rtl = legend.options.rtl,\n                    borderWidth = options.borderWidth,\n                    connectorWidth = options.connectorWidth,\n                    posX = mainRange.radius || 0,\n                    posY = elementCenter - absoluteRadius -\n                        borderWidth / 2 + connectorWidth / 2,\n                    fontMetrics = this.fontMetrics,\n                    labelMovement = fontMetrics.f / 2 -\n                        (fontMetrics.h - fontMetrics.f) / 2,\n                    crispMovement = (posY % 1 ? 1 : 0.5) -\n                        (connectorWidth % 2 ? 0 : 0.5),\n                    styledMode = renderer.styledMode;\n                var connectorLength = rtl || labelsAlign === 'left' ?\n                        -connectorDistance : connectorDistance;\n                // Set options for centered labels\n                if (labelsAlign === 'center') {\n                    connectorLength = 0; // do not use connector\n                    options.connectorDistance = 0;\n                    range.labelAttribs.align = 'center';\n                }\n                var labelY = posY + options.labels.y,\n                    labelX = posX + connectorLength + options.labels.x;\n                // Render bubble symbol\n                symbols.bubbleItems.push(renderer\n                    .circle(posX, elementCenter + crispMovement, absoluteRadius)\n                    .attr(styledMode ? {} : range.bubbleAttribs)\n                    .addClass((styledMode ?\n                    'highcharts-color-' +\n                        bubbleSeries.colorIndex + ' ' :\n                    '') +\n                    'highcharts-bubble-legend-symbol ' +\n                    (options.className || '')).add(this.legendItem.symbol));\n                // Render connector\n                symbols.connectors.push(renderer\n                    .path(renderer.crispLine([\n                    ['M', posX, posY],\n                    ['L', posX + connectorLength, posY]\n                ], options.connectorWidth))\n                    .attr((styledMode ? {} : range.connectorAttribs))\n                    .addClass((styledMode ?\n                    'highcharts-color-' +\n                        this.options.seriesIndex + ' ' : '') +\n                    'highcharts-bubble-legend-connectors ' +\n                    (options.connectorClassName || '')).add(this.legendItem.symbol));\n                // Render label\n                var label = renderer\n                        .text(this.formatLabel(range),\n                    labelX,\n                    labelY + labelMovement)\n                        .attr((styledMode ? {} : range.labelAttribs))\n                        .css(styledMode ? {} : labelsOptions.style)\n                        .addClass('highcharts-bubble-legend-labels ' +\n                        (options.labels.className || '')).add(this.legendItem.symbol);\n                labels.push(label);\n                // To enable default 'hideOverlappingLabels' method\n                label.placed = true;\n                label.alignAttr = {\n                    x: labelX,\n                    y: labelY + labelMovement\n                };\n            };\n            /**\n             * Get the label which takes up the most space.\n             * @private\n             */\n            BubbleLegendItem.prototype.getMaxLabelSize = function () {\n                var labels = this.symbols.labels;\n                var maxLabel,\n                    labelSize;\n                labels.forEach(function (label) {\n                    labelSize = label.getBBox(true);\n                    if (maxLabel) {\n                        maxLabel = labelSize.width > maxLabel.width ?\n                            labelSize : maxLabel;\n                    }\n                    else {\n                        maxLabel = labelSize;\n                    }\n                });\n                return maxLabel || {};\n            };\n            /**\n             * Get formatted label for range.\n             *\n             * @private\n             *\n             * @param {Highcharts.LegendBubbleLegendRangesOptions} range\n             *        Range options\n             *\n             * @return {string}\n             *         Range label text\n             */\n            BubbleLegendItem.prototype.formatLabel = function (range) {\n                var options = this.options,\n                    formatter = options.labels.formatter,\n                    format = options.labels.format;\n                var numberFormatter = this.chart.numberFormatter;\n                return format ? F.format(format, range) :\n                    formatter ? formatter.call(range) :\n                        numberFormatter(range.value, 1);\n            };\n            /**\n             * By using default chart 'hideOverlappingLabels' method, hide or show\n             * labels and connectors.\n             * @private\n             */\n            BubbleLegendItem.prototype.hideOverlappingLabels = function () {\n                var chart = this.chart,\n                    allowOverlap = this.options.labels.allowOverlap,\n                    symbols = this.symbols;\n                if (!allowOverlap && symbols) {\n                    chart.hideOverlappingLabels(symbols.labels);\n                    // Hide or show connectors\n                    symbols.labels.forEach(function (label, index) {\n                        if (!label.newOpacity) {\n                            symbols.connectors[index].hide();\n                        }\n                        else if (label.newOpacity !== label.oldOpacity) {\n                            symbols.connectors[index].show();\n                        }\n                    });\n                }\n            };\n            /**\n             * Calculate ranges from created series.\n             *\n             * @private\n             *\n             * @return {Array<Highcharts.LegendBubbleLegendRangesOptions>}\n             *         Array of range objects\n             */\n            BubbleLegendItem.prototype.getRanges = function () {\n                var bubbleLegend = this.legend.bubbleLegend,\n                    series = bubbleLegend.chart.series,\n                    rangesOptions = bubbleLegend.options.ranges;\n                var ranges,\n                    zData,\n                    minZ = Number.MAX_VALUE,\n                    maxZ = -Number.MAX_VALUE;\n                series.forEach(function (s) {\n                    // Find the min and max Z, like in bubble series\n                    if (s.isBubble && !s.ignoreSeries) {\n                        zData = s.zData.filter(isNumber);\n                        if (zData.length) {\n                            minZ = pick(s.options.zMin, Math.min(minZ, Math.max(arrayMin(zData), s.options.displayNegative === false ?\n                                s.options.zThreshold :\n                                -Number.MAX_VALUE)));\n                            maxZ = pick(s.options.zMax, Math.max(maxZ, arrayMax(zData)));\n                        }\n                    }\n                });\n                // Set values for ranges\n                if (minZ === maxZ) {\n                    // Only one range if min and max values are the same.\n                    ranges = [{ value: maxZ }];\n                }\n                else {\n                    ranges = [\n                        { value: minZ },\n                        { value: (minZ + maxZ) / 2 },\n                        { value: maxZ, autoRanges: true }\n                    ];\n                }\n                // Prevent reverse order of ranges after redraw\n                if (rangesOptions.length && rangesOptions[0].radius) {\n                    ranges.reverse();\n                }\n                // Merge ranges values with user options\n                ranges.forEach(function (range, i) {\n                    if (rangesOptions && rangesOptions[i]) {\n                        ranges[i] = merge(rangesOptions[i], range);\n                    }\n                });\n                return ranges;\n            };\n            /**\n             * Calculate bubble legend sizes from rendered series.\n             *\n             * @private\n             *\n             * @return {Array<number,number>}\n             *         Calculated min and max bubble sizes\n             */\n            BubbleLegendItem.prototype.predictBubbleSizes = function () {\n                var chart = this.chart,\n                    fontMetrics = this.fontMetrics,\n                    legendOptions = chart.legend.options,\n                    floating = legendOptions.floating,\n                    horizontal = legendOptions.layout === 'horizontal',\n                    lastLineHeight = horizontal ? chart.legend.lastLineHeight : 0,\n                    plotSizeX = chart.plotSizeX,\n                    plotSizeY = chart.plotSizeY,\n                    bubbleSeries = chart.series[this.options.seriesIndex],\n                    pxSizes = bubbleSeries.getPxExtremes(),\n                    minSize = Math.ceil(pxSizes.minPxSize),\n                    maxPxSize = Math.ceil(pxSizes.maxPxSize),\n                    plotSize = Math.min(plotSizeY,\n                    plotSizeX);\n                var calculatedSize,\n                    maxSize = bubbleSeries.options.maxSize;\n                // Calculate prediceted max size of bubble\n                if (floating || !(/%$/.test(maxSize))) {\n                    calculatedSize = maxPxSize;\n                }\n                else {\n                    maxSize = parseFloat(maxSize);\n                    calculatedSize = ((plotSize + lastLineHeight -\n                        fontMetrics.h / 2) * maxSize / 100) / (maxSize / 100 + 1);\n                    // Get maxPxSize from bubble series if calculated bubble legend\n                    // size will not affect to bubbles series.\n                    if ((horizontal && plotSizeY - calculatedSize >=\n                        plotSizeX) || (!horizontal && plotSizeX -\n                        calculatedSize >= plotSizeY)) {\n                        calculatedSize = maxPxSize;\n                    }\n                }\n                return [minSize, Math.ceil(calculatedSize)];\n            };\n            /**\n             * Correct ranges with calculated sizes.\n             * @private\n             */\n            BubbleLegendItem.prototype.updateRanges = function (min, max) {\n                var bubbleLegendOptions = this.legend.options.bubbleLegend;\n                bubbleLegendOptions.minSize = min;\n                bubbleLegendOptions.maxSize = max;\n                bubbleLegendOptions.ranges = this.getRanges();\n            };\n            /**\n             * Because of the possibility of creating another legend line, predicted\n             * bubble legend sizes may differ by a few pixels, so it is necessary to\n             * correct them.\n             * @private\n             */\n            BubbleLegendItem.prototype.correctSizes = function () {\n                var legend = this.legend,\n                    chart = this.chart,\n                    bubbleSeries = chart.series[this.options.seriesIndex],\n                    pxSizes = bubbleSeries.getPxExtremes(),\n                    bubbleSeriesSize = pxSizes.maxPxSize,\n                    bubbleLegendSize = this.options.maxSize;\n                if (Math.abs(Math.ceil(bubbleSeriesSize) - bubbleLegendSize) >\n                    1) {\n                    this.updateRanges(this.options.minSize, pxSizes.maxPxSize);\n                    legend.render();\n                }\n            };\n            return BubbleLegendItem;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * @interface Highcharts.BubbleLegendFormatterContextObject\n         */ /**\n        * The center y position of the range.\n        * @name Highcharts.BubbleLegendFormatterContextObject#center\n        * @type {number}\n        */ /**\n        * The radius of the bubble range.\n        * @name Highcharts.BubbleLegendFormatterContextObject#radius\n        * @type {number}\n        */ /**\n        * The bubble value.\n        * @name Highcharts.BubbleLegendFormatterContextObject#value\n        * @type {number}\n        */\n        ''; // detach doclets above\n\n        return BubbleLegendItem;\n    });\n    _registerModule(_modules, 'Series/Bubble/BubbleLegendComposition.js', [_modules['Series/Bubble/BubbleLegendDefaults.js'], _modules['Series/Bubble/BubbleLegendItem.js'], _modules['Core/Defaults.js'], _modules['Core/Utilities.js']], function (BubbleLegendDefaults, BubbleLegendItem, D, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Highsoft AS\n         *\n         *  Author: Pawe Potaczek\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var setOptions = D.setOptions;\n        var addEvent = U.addEvent,\n            objectEach = U.objectEach,\n            wrap = U.wrap;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedClasses = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * If ranges are not specified, determine ranges from rendered bubble series\n         * and render legend again.\n         */\n        function chartDrawChartBox(proceed, options, callback) {\n            var chart = this,\n                legend = chart.legend,\n                bubbleSeries = getVisibleBubbleSeriesIndex(chart) >= 0;\n            var bubbleLegendOptions,\n                bubbleSizes,\n                legendItem;\n            if (legend && legend.options.enabled && legend.bubbleLegend &&\n                legend.options.bubbleLegend.autoRanges && bubbleSeries) {\n                bubbleLegendOptions = legend.bubbleLegend.options;\n                bubbleSizes = legend.bubbleLegend.predictBubbleSizes();\n                legend.bubbleLegend.updateRanges(bubbleSizes[0], bubbleSizes[1]);\n                // Disable animation on init\n                if (!bubbleLegendOptions.placed) {\n                    legend.group.placed = false;\n                    legend.allItems.forEach(function (item) {\n                        legendItem = item.legendItem || {};\n                        if (legendItem.group) {\n                            legendItem.group.translateY = null;\n                        }\n                    });\n                }\n                // Create legend with bubbleLegend\n                legend.render();\n                chart.getMargins();\n                chart.axes.forEach(function (axis) {\n                    if (axis.visible) { // #11448\n                        axis.render();\n                    }\n                    if (!bubbleLegendOptions.placed) {\n                        axis.setScale();\n                        axis.updateNames();\n                        // Disable axis animation on init\n                        objectEach(axis.ticks, function (tick) {\n                            tick.isNew = true;\n                            tick.isNewLabel = true;\n                        });\n                    }\n                });\n                bubbleLegendOptions.placed = true;\n                // After recalculate axes, calculate margins again.\n                chart.getMargins();\n                // Call default 'drawChartBox' method.\n                proceed.call(chart, options, callback);\n                // Check bubble legend sizes and correct them if necessary.\n                legend.bubbleLegend.correctSizes();\n                // Correct items positions with different dimensions in legend.\n                retranslateItems(legend, getLinesHeights(legend));\n            }\n            else {\n                proceed.call(chart, options, callback);\n                // Allow color change on static bubble legend after click on legend\n                if (legend && legend.options.enabled && legend.bubbleLegend) {\n                    legend.render();\n                    retranslateItems(legend, getLinesHeights(legend));\n                }\n            }\n        }\n        /**\n         * Compose classes for use with Bubble series.\n         * @private\n         *\n         * @param {Highcharts.Chart} ChartClass\n         * Core chart class to use with Bubble series.\n         *\n         * @param {Highcharts.Legend} LegendClass\n         * Core legend class to use with Bubble series.\n         *\n         * @param {Highcharts.Series} SeriesClass\n         * Core series class to use with Bubble series.\n         */\n        function compose(ChartClass, LegendClass, SeriesClass) {\n            if (composedClasses.indexOf(ChartClass) === -1) {\n                composedClasses.push(ChartClass);\n                setOptions({\n                    // Set default bubble legend options\n                    legend: {\n                        bubbleLegend: BubbleLegendDefaults\n                    }\n                });\n                wrap(ChartClass.prototype, 'drawChartBox', chartDrawChartBox);\n            }\n            if (composedClasses.indexOf(LegendClass) === -1) {\n                composedClasses.push(LegendClass);\n                addEvent(LegendClass, 'afterGetAllItems', onLegendAfterGetAllItems);\n            }\n            if (composedClasses.indexOf(SeriesClass) === -1) {\n                composedClasses.push(SeriesClass);\n                addEvent(SeriesClass, 'legendItemClick', onSeriesLegendItemClick);\n            }\n        }\n        /**\n         * Check if there is at least one visible bubble series.\n         *\n         * @private\n         * @function getVisibleBubbleSeriesIndex\n         * @param {Highcharts.Chart} chart\n         * Chart to check.\n         * @return {number}\n         * First visible bubble series index\n         */\n        function getVisibleBubbleSeriesIndex(chart) {\n            var series = chart.series;\n            var i = 0;\n            while (i < series.length) {\n                if (series[i] &&\n                    series[i].isBubble &&\n                    series[i].visible &&\n                    series[i].zData.length) {\n                    return i;\n                }\n                i++;\n            }\n            return -1;\n        }\n        /**\n         * Calculate height for each row in legend.\n         *\n         * @private\n         * @function getLinesHeights\n         *\n         * @param {Highcharts.Legend} legend\n         * Legend to calculate from.\n         *\n         * @return {Array<Highcharts.Dictionary<number>>}\n         * Informations about line height and items amount\n         */\n        function getLinesHeights(legend) {\n            var items = legend.allItems,\n                lines = [],\n                length = items.length;\n            var lastLine,\n                legendItem,\n                legendItem2,\n                i = 0,\n                j = 0;\n            for (i = 0; i < length; i++) {\n                legendItem = items[i].legendItem || {};\n                legendItem2 = (items[i + 1] || {}).legendItem || {};\n                if (legendItem.labelHeight) {\n                    // for bubbleLegend\n                    items[i].itemHeight = legendItem.labelHeight;\n                }\n                if ( // Line break\n                items[i] === items[length - 1] ||\n                    legendItem.y !== legendItem2.y) {\n                    lines.push({ height: 0 });\n                    lastLine = lines[lines.length - 1];\n                    // Find the highest item in line\n                    for (j; j <= i; j++) {\n                        if (items[j].itemHeight > lastLine.height) {\n                            lastLine.height = items[j].itemHeight;\n                        }\n                    }\n                    lastLine.step = i;\n                }\n            }\n            return lines;\n        }\n        /**\n         * Start the bubble legend creation process.\n         */\n        function onLegendAfterGetAllItems(e) {\n            var legend = this,\n                bubbleLegend = legend.bubbleLegend,\n                legendOptions = legend.options,\n                options = legendOptions.bubbleLegend,\n                bubbleSeriesIndex = getVisibleBubbleSeriesIndex(legend.chart);\n            // Remove unnecessary element\n            if (bubbleLegend && bubbleLegend.ranges && bubbleLegend.ranges.length) {\n                // Allow change the way of calculating ranges in update\n                if (options.ranges.length) {\n                    options.autoRanges =\n                        !!options.ranges[0].autoRanges;\n                }\n                // Update bubbleLegend dimensions in each redraw\n                legend.destroyItem(bubbleLegend);\n            }\n            // Create bubble legend\n            if (bubbleSeriesIndex >= 0 &&\n                legendOptions.enabled &&\n                options.enabled) {\n                options.seriesIndex = bubbleSeriesIndex;\n                legend.bubbleLegend = new BubbleLegendItem(options, legend);\n                legend.bubbleLegend.addToLegend(e.allItems);\n            }\n        }\n        /**\n         * Toggle bubble legend depending on the visible status of bubble series.\n         */\n        function onSeriesLegendItemClick() {\n            var series = this,\n                chart = series.chart,\n                visible = series.visible,\n                legend = series.chart.legend;\n            var status;\n            if (legend && legend.bubbleLegend) {\n                // Temporary correct 'visible' property\n                series.visible = !visible;\n                // Save future status for getRanges method\n                series.ignoreSeries = visible;\n                // Check if at lest one bubble series is visible\n                status = getVisibleBubbleSeriesIndex(chart) >= 0;\n                // Hide bubble legend if all bubble series are disabled\n                if (legend.bubbleLegend.visible !== status) {\n                    // Show or hide bubble legend\n                    legend.update({\n                        bubbleLegend: { enabled: status }\n                    });\n                    legend.bubbleLegend.visible = status; // Restore default status\n                }\n                series.visible = visible;\n            }\n        }\n        /**\n         * Correct legend items translation in case of different elements heights.\n         *\n         * @private\n         * @function Highcharts.Legend#retranslateItems\n         *\n         * @param {Highcharts.Legend} legend\n         * Legend to translate in.\n         *\n         * @param {Array<Highcharts.Dictionary<number>>} lines\n         * Informations about line height and items amount\n         */\n        function retranslateItems(legend, lines) {\n            var items = legend.allItems,\n                rtl = legend.options.rtl;\n            var orgTranslateX,\n                orgTranslateY,\n                movementX,\n                legendItem,\n                actualLine = 0;\n            items.forEach(function (item, index) {\n                legendItem = item.legendItem || {};\n                if (!legendItem.group) {\n                    return;\n                }\n                orgTranslateX = legendItem.group.translateX || 0;\n                orgTranslateY = legendItem.y || 0;\n                movementX = item.movementX;\n                if (movementX || (rtl && item.ranges)) {\n                    movementX = rtl ?\n                        orgTranslateX - item.options.maxSize / 2 :\n                        orgTranslateX + movementX;\n                    legendItem.group.attr({ translateX: movementX });\n                }\n                if (index > lines[actualLine].step) {\n                    actualLine++;\n                }\n                legendItem.group.attr({\n                    translateY: Math.round(orgTranslateY + lines[actualLine].height / 2)\n                });\n                legendItem.y = orgTranslateY + lines[actualLine].height / 2;\n            });\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var BubbleLegendComposition = {\n                compose: compose\n            };\n\n        return BubbleLegendComposition;\n    });\n    _registerModule(_modules, 'Series/Bubble/BubblePoint.js', [_modules['Core/Series/Point.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (Point, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var ScatterPoint = SeriesRegistry.seriesTypes.scatter.prototype.pointClass;\n        var extend = U.extend;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var BubblePoint = /** @class */ (function (_super) {\n                __extends(BubblePoint, _super);\n            function BubblePoint() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.options = void 0;\n                _this.series = void 0;\n                return _this;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * @private\n             */\n            BubblePoint.prototype.haloPath = function (size) {\n                return Point.prototype.haloPath.call(this, \n                // #6067\n                size === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + size);\n            };\n            return BubblePoint;\n        }(ScatterPoint));\n        /* *\n         *\n         *  Class Prototype\n         *\n         * */\n        extend(BubblePoint.prototype, {\n            ttBelow: false\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return BubblePoint;\n    });\n    _registerModule(_modules, 'Series/Bubble/BubbleSeries.js', [_modules['Series/Bubble/BubbleLegendComposition.js'], _modules['Series/Bubble/BubblePoint.js'], _modules['Core/Color/Color.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (BubbleLegendComposition, BubblePoint, Color, H, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var color = Color.parse;\n        var noop = H.noop;\n        var Series = SeriesRegistry.series,\n            _a = SeriesRegistry.seriesTypes,\n            columnProto = _a.column.prototype,\n            ScatterSeries = _a.scatter;\n        var addEvent = U.addEvent,\n            arrayMax = U.arrayMax,\n            arrayMin = U.arrayMin,\n            clamp = U.clamp,\n            extend = U.extend,\n            isNumber = U.isNumber,\n            merge = U.merge,\n            pick = U.pick;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedClasses = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Add logic to pad each axis with the amount of pixels necessary to avoid the\n         * bubbles to overflow.\n         */\n        function axisBeforePadding() {\n            var _this = this;\n            var axisLength = this.len,\n                chart = this.chart,\n                isXAxis = this.isXAxis,\n                dataKey = isXAxis ? 'xData' : 'yData',\n                min = this.min,\n                range = this.max - min;\n            var pxMin = 0,\n                pxMax = axisLength,\n                transA = axisLength / range,\n                hasActiveSeries;\n            // Handle padding on the second pass, or on redraw\n            this.series.forEach(function (series) {\n                if (series.bubblePadding &&\n                    (series.visible || !chart.options.chart.ignoreHiddenSeries)) {\n                    // Correction for #1673\n                    _this.allowZoomOutside = true;\n                    hasActiveSeries = true;\n                    var data = series[dataKey];\n                    if (isXAxis) {\n                        (series.onPoint || series).getRadii(0, 0, series);\n                        if (series.onPoint) {\n                            series.radii = series.onPoint.radii;\n                        }\n                    }\n                    if (range > 0) {\n                        var i = data.length;\n                        while (i--) {\n                            if (isNumber(data[i]) &&\n                                _this.dataMin <= data[i] &&\n                                data[i] <= _this.max) {\n                                var radius = series.radii && series.radii[i] || 0;\n                                pxMin = Math.min(((data[i] - min) * transA) - radius, pxMin);\n                                pxMax = Math.max(((data[i] - min) * transA) + radius, pxMax);\n                            }\n                        }\n                    }\n                }\n            });\n            // Apply the padding to the min and max properties\n            if (hasActiveSeries && range > 0 && !this.logarithmic) {\n                pxMax -= axisLength;\n                transA *= (axisLength +\n                    Math.max(0, pxMin) - // #8901\n                    Math.min(pxMax, axisLength)) / axisLength;\n                [\n                    ['min', 'userMin', pxMin],\n                    ['max', 'userMax', pxMax]\n                ].forEach(function (keys) {\n                    if (typeof pick(_this.options[keys[0]], _this[keys[1]]) === 'undefined') {\n                        _this[keys[0]] += keys[2] / transA;\n                    }\n                });\n            }\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var BubbleSeries = /** @class */ (function (_super) {\n                __extends(BubbleSeries, _super);\n            function BubbleSeries() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.maxPxSize = void 0;\n                _this.minPxSize = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                _this.radii = void 0;\n                _this.yData = void 0;\n                _this.zData = void 0;\n                return _this;\n            }\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            BubbleSeries.compose = function (AxisClass, ChartClass, LegendClass, SeriesClass) {\n                BubbleLegendComposition.compose(ChartClass, LegendClass, SeriesClass);\n                if (composedClasses.indexOf(AxisClass) === -1) {\n                    composedClasses.push(AxisClass);\n                    AxisClass.prototype.beforePadding = axisBeforePadding;\n                }\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Perform animation on the bubbles\n             * @private\n             */\n            BubbleSeries.prototype.animate = function (init) {\n                if (!init &&\n                    this.points.length < this.options.animationLimit // #8099\n                ) {\n                    this.points.forEach(function (point) {\n                        var graphic = point.graphic;\n                        if (graphic && graphic.width) { // URL symbols don't have width\n                            // Start values\n                            if (!this.hasRendered) {\n                                graphic.attr({\n                                    x: point.plotX,\n                                    y: point.plotY,\n                                    width: 1,\n                                    height: 1\n                                });\n                            }\n                            // Run animation\n                            graphic.animate(this.markerAttribs(point), this.options.animation);\n                        }\n                    }, this);\n                }\n            };\n            /**\n             * Get the radius for each point based on the minSize, maxSize and each\n             * point's Z value. This must be done prior to Series.translate because\n             * the axis needs to add padding in accordance with the point sizes.\n             * @private\n             */\n            BubbleSeries.prototype.getRadii = function () {\n                var _this = this;\n                var zData = this.zData,\n                    yData = this.yData,\n                    radii = [];\n                var len,\n                    i,\n                    value,\n                    zExtremes = this.chart.bubbleZExtremes;\n                var _a = this.getPxExtremes(),\n                    minPxSize = _a.minPxSize,\n                    maxPxSize = _a.maxPxSize;\n                // Get the collective Z extremes of all bubblish series. The chart-level\n                // `bubbleZExtremes` are only computed once, and reset on `updatedData`\n                // in any member series.\n                if (!zExtremes) {\n                    var zMin_1 = Number.MAX_VALUE;\n                    var zMax_1 = -Number.MAX_VALUE;\n                    var valid_1;\n                    this.chart.series.forEach(function (otherSeries) {\n                        if (otherSeries.bubblePadding && (otherSeries.visible ||\n                            !_this.chart.options.chart.ignoreHiddenSeries)) {\n                            var zExtremes_1 = (otherSeries.onPoint || otherSeries).getZExtremes();\n                            if (zExtremes_1) {\n                                zMin_1 = Math.min(zMin_1 || zExtremes_1.zMin, zExtremes_1.zMin);\n                                zMax_1 = Math.max(zMax_1 || zExtremes_1.zMax, zExtremes_1.zMax);\n                                valid_1 = true;\n                            }\n                        }\n                    });\n                    if (valid_1) {\n                        zExtremes = { zMin: zMin_1, zMax: zMax_1 };\n                        this.chart.bubbleZExtremes = zExtremes;\n                    }\n                    else {\n                        zExtremes = { zMin: 0, zMax: 0 };\n                    }\n                }\n                // Set the shape type and arguments to be picked up in drawPoints\n                for (i = 0, len = zData.length; i < len; i++) {\n                    value = zData[i];\n                    // Separate method to get individual radius for bubbleLegend\n                    radii.push(this.getRadius(zExtremes.zMin, zExtremes.zMax, minPxSize, maxPxSize, value, yData && yData[i]));\n                }\n                this.radii = radii;\n            };\n            /**\n             * Get the individual radius for one point.\n             * @private\n             */\n            BubbleSeries.prototype.getRadius = function (zMin, zMax, minSize, maxSize, value, yValue) {\n                var options = this.options,\n                    sizeByArea = options.sizeBy !== 'width',\n                    zThreshold = options.zThreshold;\n                var zRange = zMax - zMin,\n                    pos = 0.5;\n                // #8608 - bubble should be visible when z is undefined\n                if (yValue === null || value === null) {\n                    return null;\n                }\n                if (isNumber(value)) {\n                    // When sizing by threshold, the absolute value of z determines\n                    // the size of the bubble.\n                    if (options.sizeByAbsoluteValue) {\n                        value = Math.abs(value - zThreshold);\n                        zMax = zRange = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));\n                        zMin = 0;\n                    }\n                    // Issue #4419 - if value is less than zMin, push a radius that's\n                    // always smaller than the minimum size\n                    if (value < zMin) {\n                        return minSize / 2 - 1;\n                    }\n                    // Relative size, a number between 0 and 1\n                    if (zRange > 0) {\n                        pos = (value - zMin) / zRange;\n                    }\n                }\n                if (sizeByArea && pos >= 0) {\n                    pos = Math.sqrt(pos);\n                }\n                return Math.ceil(minSize + pos * (maxSize - minSize)) / 2;\n            };\n            /**\n             * Define hasData function for non-cartesian series.\n             * Returns true if the series has points at all.\n             * @private\n             */\n            BubbleSeries.prototype.hasData = function () {\n                return !!this.processedXData.length; // != 0\n            };\n            /**\n             * @private\n             */\n            BubbleSeries.prototype.pointAttribs = function (point, state) {\n                var markerOptions = this.options.marker,\n                    fillOpacity = markerOptions.fillOpacity,\n                    attr = Series.prototype.pointAttribs.call(this,\n                    point,\n                    state);\n                if (fillOpacity !== 1) {\n                    attr.fill = color(attr.fill)\n                        .setOpacity(fillOpacity)\n                        .get('rgba');\n                }\n                return attr;\n            };\n            /**\n             * Extend the base translate method to handle bubble size\n             * @private\n             */\n            BubbleSeries.prototype.translate = function () {\n                // Run the parent method\n                _super.prototype.translate.call(this);\n                this.getRadii();\n                this.translateBubble();\n            };\n            BubbleSeries.prototype.translateBubble = function () {\n                var _a = this,\n                    data = _a.data,\n                    radii = _a.radii;\n                var minPxSize = this.getPxExtremes().minPxSize;\n                // Set the shape type and arguments to be picked up in drawPoints\n                var i = data.length;\n                while (i--) {\n                    var point = data[i];\n                    var radius = radii ? radii[i] : 0; // #1737\n                        if (isNumber(radius) && radius >= minPxSize / 2) {\n                            // Shape arguments\n                            point.marker = extend(point.marker, {\n                                radius: radius,\n                                width: 2 * radius,\n                                height: 2 * radius\n                            });\n                        // Alignment box for the data label\n                        point.dlBox = {\n                            x: point.plotX - radius,\n                            y: point.plotY - radius,\n                            width: 2 * radius,\n                            height: 2 * radius\n                        };\n                    }\n                    else { // below zThreshold\n                        // #1691\n                        point.shapeArgs = point.plotY = point.dlBox = void 0;\n                        point.isInside = false; // #17281\n                    }\n                }\n            };\n            BubbleSeries.prototype.getPxExtremes = function () {\n                var smallestSize = Math.min(this.chart.plotWidth,\n                    this.chart.plotHeight);\n                var getPxSize = function (length) {\n                        var isPercent;\n                    if (typeof length === 'string') {\n                        isPercent = /%$/.test(length);\n                        length = parseInt(length, 10);\n                    }\n                    return isPercent ? smallestSize * length / 100 : length;\n                };\n                var minPxSize = getPxSize(pick(this.options.minSize, 8));\n                // Prioritize min size if conflict to make sure bubbles are\n                // always visible. #5873\n                var maxPxSize = Math.max(getPxSize(pick(this.options.maxSize, '20%')),\n                    minPxSize);\n                return { minPxSize: minPxSize, maxPxSize: maxPxSize };\n            };\n            BubbleSeries.prototype.getZExtremes = function () {\n                var options = this.options,\n                    zData = (this.zData || []).filter(isNumber);\n                if (zData.length) {\n                    var zMin = pick(options.zMin,\n                        clamp(arrayMin(zData),\n                        options.displayNegative === false ?\n                            (options.zThreshold || 0) :\n                            -Number.MAX_VALUE,\n                        Number.MAX_VALUE));\n                    var zMax = pick(options.zMax,\n                        arrayMax(zData));\n                    if (isNumber(zMin) && isNumber(zMax)) {\n                        return { zMin: zMin, zMax: zMax };\n                    }\n                }\n            };\n            /**\n             * A bubble series is a three dimensional series type where each point\n             * renders an X, Y and Z value. Each points is drawn as a bubble where the\n             * position along the X and Y axes mark the X and Y values, and the size of\n             * the bubble relates to the Z value.\n             *\n             * @sample {highcharts} highcharts/demo/bubble/\n             *         Bubble chart\n             *\n             * @extends      plotOptions.scatter\n             * @excluding    cluster\n             * @product      highcharts highstock\n             * @requires     highcharts-more\n             * @optionparent plotOptions.bubble\n             */\n            BubbleSeries.defaultOptions = merge(ScatterSeries.defaultOptions, {\n                dataLabels: {\n                    formatter: function () {\n                        var numberFormatter = this.series.chart.numberFormatter;\n                        var z = this.point.z;\n                        return isNumber(z) ? numberFormatter(z, -1) : '';\n                    },\n                    inside: true,\n                    verticalAlign: 'middle'\n                },\n                /**\n                 * If there are more points in the series than the `animationLimit`, the\n                 * animation won't run. Animation affects overall performance and\n                 * doesn't work well with heavy data series.\n                 *\n                 * @since 6.1.0\n                 */\n                animationLimit: 250,\n                /**\n                 * Whether to display negative sized bubbles. The threshold is given\n                 * by the [zThreshold](#plotOptions.bubble.zThreshold) option, and negative\n                 * bubbles can be visualized by setting\n                 * [negativeColor](#plotOptions.bubble.negativeColor).\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-negative/\n                 *         Negative bubbles\n                 *\n                 * @type      {boolean}\n                 * @default   true\n                 * @since     3.0\n                 * @apioption plotOptions.bubble.displayNegative\n                 */\n                /**\n                 * @extends   plotOptions.series.marker\n                 * @excluding enabled, enabledThreshold, height, radius, width\n                 */\n                marker: {\n                    lineColor: null,\n                    lineWidth: 1,\n                    /**\n                     * The fill opacity of the bubble markers.\n                     */\n                    fillOpacity: 0.5,\n                    /**\n                     * In bubble charts, the radius is overridden and determined based\n                     * on the point's data value.\n                     *\n                     * @ignore-option\n                     */\n                    radius: null,\n                    states: {\n                        hover: {\n                            radiusPlus: 0\n                        }\n                    },\n                    /**\n                     * A predefined shape or symbol for the marker. Possible values are\n                     * \"circle\", \"square\", \"diamond\", \"triangle\" and \"triangle-down\".\n                     *\n                     * Additionally, the URL to a graphic can be given on the form\n                     * `url(graphic.png)`. Note that for the image to be applied to\n                     * exported charts, its URL needs to be accessible by the export\n                     * server.\n                     *\n                     * Custom callbacks for symbol path generation can also be added to\n                     * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then\n                     * used by its method name, as shown in the demo.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/bubble-symbol/\n                     *         Bubble chart with various symbols\n                     * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/\n                     *         General chart with predefined, graphic and custom markers\n                     *\n                     * @type  {Highcharts.SymbolKeyValue|string}\n                     * @since 5.0.11\n                     */\n                    symbol: 'circle'\n                },\n                /**\n                 * Minimum bubble size. Bubbles will automatically size between the\n                 * `minSize` and `maxSize` to reflect the `z` value of each bubble.\n                 * Can be either pixels (when no unit is given), or a percentage of\n                 * the smallest one of the plot width and height.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-size/\n                 *         Bubble size\n                 *\n                 * @type    {number|string}\n                 * @since   3.0\n                 * @product highcharts highstock\n                 */\n                minSize: 8,\n                /**\n                 * Maximum bubble size. Bubbles will automatically size between the\n                 * `minSize` and `maxSize` to reflect the `z` value of each bubble.\n                 * Can be either pixels (when no unit is given), or a percentage of\n                 * the smallest one of the plot width and height.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-size/\n                 *         Bubble size\n                 *\n                 * @type    {number|string}\n                 * @since   3.0\n                 * @product highcharts highstock\n                 */\n                maxSize: '20%',\n                /**\n                 * When a point's Z value is below the\n                 * [zThreshold](#plotOptions.bubble.zThreshold)\n                 * setting, this color is used.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-negative/\n                 *         Negative bubbles\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.bubble.negativeColor\n                 */\n                /**\n                 * Whether the bubble's value should be represented by the area or the\n                 * width of the bubble. The default, `area`, corresponds best to the\n                 * human perception of the size of each bubble.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-sizeby/\n                 *         Comparison of area and size\n                 *\n                 * @type       {Highcharts.BubbleSizeByValue}\n                 * @default    area\n                 * @since      3.0.7\n                 * @apioption  plotOptions.bubble.sizeBy\n                 */\n                /**\n                 * When this is true, the absolute value of z determines the size of\n                 * the bubble. This means that with the default `zThreshold` of 0, a\n                 * bubble of value -1 will have the same size as a bubble of value 1,\n                 * while a bubble of value 0 will have a smaller size according to\n                 * `minSize`.\n                 *\n                 * @sample    {highcharts} highcharts/plotoptions/bubble-sizebyabsolutevalue/\n                 *            Size by absolute value, various thresholds\n                 *\n                 * @type      {boolean}\n                 * @default   false\n                 * @since     4.1.9\n                 * @product   highcharts\n                 * @apioption plotOptions.bubble.sizeByAbsoluteValue\n                 */\n                /**\n                 * When this is true, the series will not cause the Y axis to cross\n                 * the zero plane (or [threshold](#plotOptions.series.threshold) option)\n                 * unless the data actually crosses the plane.\n                 *\n                 * For example, if `softThreshold` is `false`, a series of 0, 1, 2,\n                 * 3 will make the Y axis show negative values according to the\n                 * `minPadding` option. If `softThreshold` is `true`, the Y axis starts\n                 * at 0.\n                 *\n                 * @since   4.1.9\n                 * @product highcharts\n                 */\n                softThreshold: false,\n                states: {\n                    hover: {\n                        halo: {\n                            size: 5\n                        }\n                    }\n                },\n                tooltip: {\n                    pointFormat: '({point.x}, {point.y}), Size: {point.z}'\n                },\n                turboThreshold: 0,\n                /**\n                 * The minimum for the Z value range. Defaults to the highest Z value\n                 * in the data.\n                 *\n                 * @see [zMin](#plotOptions.bubble.zMin)\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/\n                 *         Z has a possible range of 0-100\n                 *\n                 * @type      {number}\n                 * @since     4.0.3\n                 * @product   highcharts\n                 * @apioption plotOptions.bubble.zMax\n                 */\n                /**\n                 * @default   z\n                 * @apioption plotOptions.bubble.colorKey\n                 */\n                /**\n                 * The minimum for the Z value range. Defaults to the lowest Z value\n                 * in the data.\n                 *\n                 * @see [zMax](#plotOptions.bubble.zMax)\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/\n                 *         Z has a possible range of 0-100\n                 *\n                 * @type      {number}\n                 * @since     4.0.3\n                 * @product   highcharts\n                 * @apioption plotOptions.bubble.zMin\n                 */\n                /**\n                 * When [displayNegative](#plotOptions.bubble.displayNegative) is `false`,\n                 * bubbles with lower Z values are skipped. When `displayNegative`\n                 * is `true` and a [negativeColor](#plotOptions.bubble.negativeColor)\n                 * is given, points with lower Z is colored.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/bubble-negative/\n                 *         Negative bubbles\n                 *\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                zThreshold: 0,\n                zoneAxis: 'z'\n            });\n            return BubbleSeries;\n        }(ScatterSeries));\n        extend(BubbleSeries.prototype, {\n            alignDataLabel: columnProto.alignDataLabel,\n            applyZones: noop,\n            bubblePadding: true,\n            buildKDTree: noop,\n            directTouch: true,\n            isBubble: true,\n            pointArrayMap: ['y', 'z'],\n            pointClass: BubblePoint,\n            parallelArrays: ['x', 'y', 'z'],\n            trackerGroups: ['group', 'dataLabelsGroup'],\n            specialGroup: 'group',\n            zoneAxis: 'z'\n        });\n        // On updated data in any series, delete the chart-level Z extremes cache\n        addEvent(BubbleSeries, 'updatedData', function (e) {\n            delete e.target.chart.bubbleZExtremes;\n        });\n        // After removing series, delete the chart-level Z extremes cache, #17502.\n        addEvent(BubbleSeries, 'remove', function (e) {\n            delete e.target.chart.bubbleZExtremes;\n        });\n        SeriesRegistry.registerSeriesType('bubble', BubbleSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * @typedef {\"area\"|\"width\"} Highcharts.BubbleSizeByValue\n         */\n        ''; // detach doclets above\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `bubble` series. If the [type](#series.bubble.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.bubble\n         * @excluding dataParser, dataURL, stack\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption series.bubble\n         */\n        /**\n         * An array of data points for the series. For the `bubble` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n         *    to `x,y,z`. If the first value is a string, it is applied as the name of\n         *    the point, and the `x` value is inferred. The `x` value can also be\n         *    omitted, in which case the inner arrays should be of length 2\\. Then the\n         *    `x` value is automatically calculated, either starting at 0 and\n         *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n         *    series options.\n         *    ```js\n         *    data: [\n         *        [0, 1, 2],\n         *        [1, 5, 5],\n         *        [2, 0, 2]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.bubble.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        y: 1,\n         *        z: 1,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        y: 5,\n         *        z: 4,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n         * @extends   series.line.data\n         * @product   highcharts\n         * @apioption series.bubble.data\n         */\n        /**\n         * @extends     series.line.data.marker\n         * @excluding   enabledThreshold, height, radius, width\n         * @product     highcharts\n         * @apioption   series.bubble.data.marker\n         */\n        /**\n         * The size value for each bubble. The bubbles' diameters are computed\n         * based on the `z`, and controlled by series options like `minSize`,\n         * `maxSize`, `sizeBy`, `zMin` and `zMax`.\n         *\n         * @type      {number|null}\n         * @product   highcharts\n         * @apioption series.bubble.data.z\n         */\n        /**\n         * @excluding enabled, enabledThreshold, height, radius, width\n         * @apioption series.bubble.marker\n         */\n        ''; // adds doclets above to transpiled file\n\n        return BubbleSeries;\n    });\n    _registerModule(_modules, 'Series/ColumnRange/ColumnRangePoint.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var _a = SeriesRegistry.seriesTypes,\n            columnProto = _a.column.prototype.pointClass.prototype,\n            AreaRangePoint = _a.arearange.prototype.pointClass;\n        var extend = U.extend,\n            isNumber = U.isNumber;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var ColumnRangePoint = /** @class */ (function (_super) {\n                __extends(ColumnRangePoint, _super);\n            function ColumnRangePoint() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.options = void 0;\n                _this.series = void 0;\n                return _this;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            ColumnRangePoint.prototype.isValid = function () {\n                return isNumber(this.low);\n            };\n            return ColumnRangePoint;\n        }(AreaRangePoint));\n        extend(ColumnRangePoint.prototype, {\n            setState: columnProto.setState\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ColumnRangePoint;\n    });\n    _registerModule(_modules, 'Series/ColumnRange/ColumnRangeSeries.js', [_modules['Series/ColumnRange/ColumnRangePoint.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (ColumnRangePoint, H, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var noop = H.noop;\n        var _a = SeriesRegistry.seriesTypes,\n            AreaRangeSeries = _a.arearange,\n            ColumnSeries = _a.column,\n            columnProto = _a.column.prototype;\n        var clamp = U.clamp,\n            extend = U.extend,\n            isNumber = U.isNumber,\n            merge = U.merge,\n            pick = U.pick;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * The column range is a cartesian series type with higher and lower\n         * Y values along an X axis. To display horizontal bars, set\n         * [chart.inverted](#chart.inverted) to `true`.\n         *\n         * @sample {highcharts|highstock} highcharts/demo/columnrange/\n         *         Inverted column range\n         *\n         * @extends      plotOptions.column\n         * @since        2.3.0\n         * @excluding    negativeColor, stacking, softThreshold, threshold\n         * @product      highcharts highstock\n         * @requires     highcharts-more\n         * @optionparent plotOptions.columnrange\n         */\n        var columnRangeOptions = {\n                /**\n                 * Extended data labels for range series types. Range series data labels\n                 * have no `x` and `y` options. Instead,\n            they have `xLow`,\n            `xHigh`,\n                 * `yLow` and `yHigh` options to allow the higher and lower data label\n                 * sets individually.\n                 *\n                 * @declare   Highcharts.SeriesAreaRangeDataLabelsOptionsObject\n                 * @extends   plotOptions.arearange.dataLabels\n                 * @since     2.3.0\n                 * @product   highcharts highstock\n                 * @apioption plotOptions.columnrange.dataLabels\n                 */\n                pointRange: null,\n                /** @ignore-option */\n                marker: null,\n                states: {\n                    hover: {\n                        /** @ignore-option */\n                        halo: false\n                    }\n                }\n            };\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The ColumnRangeSeries class\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.columnrange\n         *\n         * @augments Highcharts.Series\n         */\n        var ColumnRangeSeries = /** @class */ (function (_super) {\n                __extends(ColumnRangeSeries, _super);\n            function ColumnRangeSeries() {\n                return _super !== null && _super.apply(this, arguments) || this;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            ColumnRangeSeries.prototype.setOptions = function () {\n                // #14359 Prevent side-effect from stacking.\n                merge(true, arguments[0], { stacking: void 0 });\n                return AreaRangeSeries.prototype.setOptions.apply(this, arguments);\n            };\n            // eslint-disable-next-line valid-jsdoc\n            /**\n             * Translate data points from raw values x and y to plotX and plotY\n             * @private\n             */\n            ColumnRangeSeries.prototype.translate = function () {\n                var _this = this;\n                var yAxis = this.yAxis,\n                    xAxis = this.xAxis,\n                    startAngleRad = xAxis.startAngleRad,\n                    chart = this.chart,\n                    isRadial = this.xAxis.isRadial,\n                    safeDistance = Math.max(chart.chartWidth,\n                    chart.chartHeight) + 999;\n                var height,\n                    heightDifference,\n                    start,\n                    plotHigh,\n                    y;\n                // eslint-disable-next-line valid-jsdoc\n                /**\n                 * Don't draw too far outside plot area (#6835)\n                 * @private\n                 */\n                function safeBounds(pixelPos) {\n                    return clamp(pixelPos, -safeDistance, safeDistance);\n                }\n                columnProto.translate.apply(this);\n                // Set plotLow and plotHigh\n                this.points.forEach(function (point) {\n                    var shapeArgs = point.shapeArgs || {},\n                        minPointLength = _this.options.minPointLength,\n                        plotY = point.plotY,\n                        plotHigh = yAxis.translate(point.high, 0, 1, 0, 1);\n                    if (isNumber(plotHigh) && isNumber(plotY)) {\n                        point.plotHigh = safeBounds(plotHigh);\n                        point.plotLow = safeBounds(plotY);\n                        // adjust shape\n                        y = point.plotHigh;\n                        height = pick(point.rectPlotY, point.plotY) - point.plotHigh;\n                        // Adjust for minPointLength\n                        if (Math.abs(height) < minPointLength) {\n                            heightDifference = (minPointLength - height);\n                            height += heightDifference;\n                            y -= heightDifference / 2;\n                            // Adjust for negative ranges or reversed Y axis (#1457)\n                        }\n                        else if (height < 0) {\n                            height *= -1;\n                            y -= height;\n                        }\n                        if (isRadial && _this.polar) {\n                            start = point.barX + startAngleRad;\n                            point.shapeType = 'arc';\n                            point.shapeArgs = _this.polar.arc(y + height, y, start, start + point.pointWidth);\n                        }\n                        else {\n                            shapeArgs.height = height;\n                            shapeArgs.y = y;\n                            var _a = shapeArgs.x,\n                                x = _a === void 0 ? 0 : _a,\n                                _b = shapeArgs.width,\n                                width = _b === void 0 ? 0 : _b;\n                            point.tooltipPos = chart.inverted ?\n                                [\n                                    yAxis.len + yAxis.pos - chart.plotLeft - y -\n                                        height / 2,\n                                    xAxis.len + xAxis.pos - chart.plotTop - x -\n                                        width / 2,\n                                    height\n                                ] : [\n                                xAxis.left - chart.plotLeft + x + width / 2,\n                                yAxis.pos - chart.plotTop + y + height / 2,\n                                height\n                            ]; // don't inherit from column tooltip position - #3372\n                        }\n                    }\n                });\n            };\n            // Overrides from modules that may be loaded after this module\n            // @todo move to compositions\n            // public crispCol(): BBoxObject {\n            //     return columnProto.crispCol.apply(this, arguments as any);\n            // }\n            // public drawPoints(): void {\n            //     return columnProto.drawPoints.apply(this, arguments as any);\n            // }\n            // public drawTracker(): void {\n            //     return columnProto.drawTracker.apply(this, arguments as any);\n            // }\n            // public getColumnMetrics(): ColumnMetricsObject {\n            //     return columnProto.getColumnMetrics.apply(this, arguments as any);\n            // }\n            ColumnRangeSeries.prototype.pointAttribs = function () {\n                return columnProto.pointAttribs.apply(this, arguments);\n            };\n            // public adjustForMissingColumns(): number {\n            //     return columnProto.adjustForMissingColumns.apply(this, arguments);\n            // }\n            // public animate(): void {\n            //     return columnProto.animate.apply(this, arguments as any);\n            // }\n            ColumnRangeSeries.prototype.translate3dPoints = function () {\n                return columnProto.translate3dPoints.apply(this, arguments);\n            };\n            ColumnRangeSeries.prototype.translate3dShapes = function () {\n                return columnProto.translate3dShapes.apply(this, arguments);\n            };\n            /* *\n             *\n             *  Static Properties\n             *\n             * */\n            ColumnRangeSeries.defaultOptions = merge(ColumnSeries.defaultOptions, AreaRangeSeries.defaultOptions, columnRangeOptions);\n            return ColumnRangeSeries;\n        }(AreaRangeSeries));\n        extend(ColumnRangeSeries.prototype, {\n            directTouch: true,\n            pointClass: ColumnRangePoint,\n            trackerGroups: ['group', 'dataLabelsGroup'],\n            adjustForMissingColumns: columnProto.adjustForMissingColumns,\n            animate: columnProto.animate,\n            crispCol: columnProto.crispCol,\n            drawGraph: noop,\n            drawPoints: columnProto.drawPoints,\n            getSymbol: noop,\n            drawTracker: columnProto.drawTracker,\n            getColumnMetrics: columnProto.getColumnMetrics\n            // pointAttribs: columnProto.pointAttribs,\n            // polarArc: columnProto.polarArc\n            // translate3dPoints: columnProto.translate3dPoints,\n            // translate3dShapes: columnProto.translate3dShapes\n        });\n        SeriesRegistry.registerSeriesType('columnrange', ColumnRangeSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `columnrange` series. If the [type](#series.columnrange.type)\n         * option is not specified, it is inherited from\n         * [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.columnrange\n         * @excluding dataParser, dataURL, stack, stacking\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption series.columnrange\n         */\n        /**\n         * An array of data points for the series. For the `columnrange` series\n         * type, points can be given in the following ways:\n         *\n         * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n         *    to `x,low,high`. If the first value is a string, it is applied as the name\n         *    of the point, and the `x` value is inferred. The `x` value can also be\n         *    omitted, in which case the inner arrays should be of length 2\\. Then the\n         *    `x` value is automatically calculated, either starting at 0 and\n         *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n         *    series options.\n         *    ```js\n         *    data: [\n         *        [0, 4, 2],\n         *        [1, 2, 1],\n         *        [2, 9, 10]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.columnrange.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        low: 0,\n         *        high: 4,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        low: 5,\n         *        high: 3,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n         * @extends   series.arearange.data\n         * @excluding marker\n         * @product   highcharts highstock\n         * @apioption series.columnrange.data\n         */\n        /**\n         * @extends   series.columnrange.dataLabels\n         * @product   highcharts highstock\n         * @apioption series.columnrange.data.dataLabels\n         */\n        /**\n         * @excluding halo, lineWidth, lineWidthPlus, marker\n         * @product   highcharts highstock\n         * @apioption series.columnrange.states.hover\n         */\n        /**\n         * @excluding halo, lineWidth, lineWidthPlus, marker\n         * @product   highcharts highstock\n         * @apioption series.columnrange.states.select\n         */\n        ''; // adds doclets above into transpiled\n\n        return ColumnRangeSeries;\n    });\n    _registerModule(_modules, 'Series/ColumnPyramid/ColumnPyramidSeries.js', [_modules['Series/Column/ColumnSeries.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (ColumnSeries, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Sebastian Bochan\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var colProto = ColumnSeries.prototype;\n        var clamp = U.clamp,\n            extend = U.extend,\n            merge = U.merge,\n            pick = U.pick;\n        /**\n         * The ColumnPyramidSeries class\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.columnpyramid\n         *\n         * @augments Highcharts.Series\n         */\n        var ColumnPyramidSeries = /** @class */ (function (_super) {\n                __extends(ColumnPyramidSeries, _super);\n            function ColumnPyramidSeries() {\n                /* *\n                 *\n                 * Static properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                return _this;\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            /* eslint-disable-next-line valid-jsdoc */\n            /**\n             * Overrides the column translate method\n             * @private\n             */\n            ColumnPyramidSeries.prototype.translate = function () {\n                var series = this,\n                    chart = series.chart,\n                    options = series.options,\n                    dense = series.dense =\n                        series.closestPointRange * series.xAxis.transA < 2,\n                    borderWidth = series.borderWidth = pick(options.borderWidth,\n                    dense ? 0 : 1 // #3635\n                    ),\n                    yAxis = series.yAxis,\n                    threshold = options.threshold,\n                    translatedThreshold = series.translatedThreshold =\n                        yAxis.getThreshold(threshold),\n                    minPointLength = pick(options.minPointLength, 5),\n                    metrics = series.getColumnMetrics(),\n                    pointWidth = metrics.width, \n                    // postprocessed for border width\n                    seriesBarW = series.barW =\n                        Math.max(pointWidth, 1 + 2 * borderWidth),\n                    pointXOffset = series.pointXOffset = metrics.offset;\n                if (chart.inverted) {\n                    translatedThreshold -= 0.5; // #3355\n                }\n                // When the pointPadding is 0,\n                // we want the pyramids to be packed tightly,\n                // so we allow individual pyramids to have individual sizes.\n                // When pointPadding is greater,\n                // we strive for equal-width columns (#2694).\n                if (options.pointPadding) {\n                    seriesBarW = Math.ceil(seriesBarW);\n                }\n                colProto.translate.apply(series);\n                // Record the new values\n                series.points.forEach(function (point) {\n                    var yBottom = pick(point.yBottom,\n                        translatedThreshold),\n                        safeDistance = 999 + Math.abs(yBottom),\n                        plotY = clamp(point.plotY, -safeDistance,\n                        yAxis.len + safeDistance), \n                        // Don't draw too far outside plot area\n                        // (#1303, #2241, #4264)\n                        barX = point.plotX + pointXOffset,\n                        barW = seriesBarW / 2,\n                        barY = Math.min(plotY,\n                        yBottom),\n                        barH = Math.max(plotY,\n                        yBottom) - barY,\n                        stackTotal,\n                        stackHeight,\n                        topPointY,\n                        topXwidth,\n                        bottomXwidth,\n                        invBarPos,\n                        x1,\n                        x2,\n                        x3,\n                        x4,\n                        y1,\n                        y2;\n                    point.barX = barX;\n                    point.pointWidth = pointWidth;\n                    // Fix the tooltip on center of grouped pyramids\n                    // (#1216, #424, #3648)\n                    point.tooltipPos = chart.inverted ?\n                        [\n                            yAxis.len + yAxis.pos - chart.plotLeft - plotY,\n                            series.xAxis.len - barX - barW,\n                            barH\n                        ] :\n                        [\n                            barX + barW,\n                            plotY + yAxis.pos - chart.plotTop,\n                            barH\n                        ];\n                    stackTotal =\n                        threshold + (point.total || point.y);\n                    // overwrite stacktotal (always 100 / -100)\n                    if (options.stacking === 'percent') {\n                        stackTotal =\n                            threshold + (point.y < 0) ?\n                                -100 :\n                                100;\n                    }\n                    // get the highest point (if stack, extract from total)\n                    topPointY = yAxis.toPixels((stackTotal), true);\n                    // calculate height of stack (in pixels)\n                    stackHeight =\n                        chart.plotHeight - topPointY -\n                            (chart.plotHeight - translatedThreshold);\n                    // topXwidth and bottomXwidth = width of lines from the center\n                    // calculated from tanges proportion.\n                    // Cannot be a NaN #12514\n                    topXwidth = stackHeight ?\n                        (barW * (barY - topPointY)) / stackHeight : 0;\n                    // like topXwidth, but with height of point\n                    bottomXwidth = stackHeight ?\n                        (barW * (barY + barH - topPointY)) / stackHeight :\n                        0;\n                    /*\n                            /\\\n                           /  \\\n                    x1,y1,------ x2,y1\n                        /      \\\n                       ----------\n                    x4,y2        x3,y2\n                    */\n                    x1 = barX - topXwidth + barW;\n                    x2 = barX + topXwidth + barW;\n                    x3 = barX + bottomXwidth + barW;\n                    x4 = barX - bottomXwidth + barW;\n                    y1 = barY - minPointLength;\n                    y2 = barY + barH;\n                    if (point.y < 0) {\n                        y1 = barY;\n                        y2 = barY + barH + minPointLength;\n                    }\n                    // inverted chart\n                    if (chart.inverted) {\n                        invBarPos = yAxis.width - barY;\n                        stackHeight =\n                            topPointY - (yAxis.width - translatedThreshold);\n                        // proportion tanges\n                        topXwidth = (barW *\n                            (topPointY - invBarPos)) / stackHeight;\n                        bottomXwidth = (barW *\n                            (topPointY - (invBarPos - barH))) / stackHeight;\n                        x1 = barX + barW + topXwidth; // top bottom\n                        x2 = x1 - 2 * topXwidth; // top top\n                        x3 = barX - bottomXwidth + barW; // bottom top\n                        x4 = barX + bottomXwidth + barW; // bottom bottom\n                        y1 = barY;\n                        y2 = barY + barH - minPointLength;\n                        if (point.y < 0) {\n                            y2 = barY + barH + minPointLength;\n                        }\n                    }\n                    // Register shape type and arguments to be used in drawPoints\n                    point.shapeType = 'path';\n                    point.shapeArgs = {\n                        // args for datalabels positioning\n                        x: x1,\n                        y: y1,\n                        width: x2 - x1,\n                        height: barH,\n                        // path of pyramid\n                        d: [\n                            ['M', x1, y1],\n                            ['L', x2, y1],\n                            ['L', x3, y2],\n                            ['L', x4, y2],\n                            ['Z']\n                        ]\n                    };\n                });\n            };\n            /**\n             * Column pyramid series display one pyramid per value along an X axis.\n             * To display horizontal pyramids, set [chart.inverted](#chart.inverted) to\n             * `true`.\n             *\n             * @sample {highcharts|highstock} highcharts/demo/column-pyramid/\n             *         Column pyramid\n             * @sample {highcharts|highstock} highcharts/plotoptions/columnpyramid-stacked/\n             *         Column pyramid stacked\n             * @sample {highcharts|highstock} highcharts/plotoptions/columnpyramid-inverted/\n             *         Column pyramid inverted\n             *\n             * @extends      plotOptions.column\n             * @since        7.0.0\n             * @product      highcharts highstock\n             * @excluding    boostThreshold, borderRadius, crisp, depth, edgeColor,\n             *               edgeWidth, groupZPadding, negativeColor, softThreshold,\n             *               threshold, zoneAxis, zones, boostBlending\n             * @requires     highcharts-more\n             * @optionparent plotOptions.columnpyramid\n             */\n            ColumnPyramidSeries.defaultOptions = merge(ColumnSeries.defaultOptions, {\n            // Nothing here\n            });\n            return ColumnPyramidSeries;\n        }(ColumnSeries));\n        SeriesRegistry.registerSeriesType('columnpyramid', ColumnPyramidSeries);\n        /* *\n         *\n         * Default export\n         *\n         * */\n        /* *\n         *\n         * API Options\n         *\n         * */\n        /**\n         * A `columnpyramid` series. If the [type](#series.columnpyramid.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.columnpyramid\n         * @excluding connectEnds, connectNulls, dashStyle, dataParser, dataURL,\n         *            gapSize, gapUnit, linecap, lineWidth, marker, step,\n         *            boostThreshold, boostBlending\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption series.columnpyramid\n         */\n        /**\n         * @excluding halo, lineWidth, lineWidthPlus, marker\n         * @product   highcharts highstock\n         * @apioption series.columnpyramid.states.hover\n         */\n        /**\n         * @excluding halo, lineWidth, lineWidthPlus, marker\n         * @product   highcharts highstock\n         * @apioption series.columnpyramid.states.select\n         */\n        /**\n         * An array of data points for the series. For the `columnpyramid` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of numerical values. In this case, the numerical values will be\n         *    interpreted as `y` options. The `x` values will be automatically\n         *    calculated, either starting at 0 and incremented by 1, or from\n         *    `pointStart` and `pointInterval` given in the series options. If the axis\n         *    has categories, these will be used. Example:\n         *    ```js\n         *    data: [0, 5, 3, 5]\n         *    ```\n         *\n         * 2. An array of arrays with 2 values. In this case, the values correspond to\n         *    `x,y`. If the first value is a string, it is applied as the name of the\n         *    point, and the `x` value is inferred.\n         *    ```js\n         *    data: [\n         *        [0, 6],\n         *        [1, 2],\n         *        [2, 6]\n         *    ]\n         *    ```\n         *\n         * 3. An array of objects with named values. The objects are point configuration\n         *    objects as seen below. If the total number of data points exceeds the\n         *    series' [turboThreshold](#series.columnpyramid.turboThreshold), this\n         *    option is not available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        y: 9,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        y: 6,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         Numerical values\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n         * @extends   series.line.data\n         * @excluding marker\n         * @product   highcharts highstock\n         * @apioption series.columnpyramid.data\n         */\n        ''; // adds doclets above to transpiled file;\n\n        return ColumnPyramidSeries;\n    });\n    _registerModule(_modules, 'Series/ErrorBar/ErrorBarSeriesDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * Error bars are a graphical representation of the variability of data and\n         * are used on graphs to indicate the error, or uncertainty in a reported\n         * measurement.\n         *\n         * @sample highcharts/demo/error-bar/\n         *         Error bars on a column series\n         * @sample highcharts/series-errorbar/on-scatter/\n         *         Error bars on a scatter series\n         * @sample highcharts/series-errorbar/datalabels/\n         *         Error bars with data labels\n         *\n         * @extends      plotOptions.boxplot\n         * @excluding    boostBlending, boostThreshold\n         * @product      highcharts\n         * @requires     highcharts-more\n         * @optionparent plotOptions.errorbar\n         */\n        var ErrorBarSeriesDefaults = {\n                /**\n                 * The main color of the bars. This can be overridden by\n                 * [stemColor](#plotOptions.errorbar.stemColor) and\n                 * [whiskerColor](#plotOptions.errorbar.whiskerColor) individually.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @default #000000\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                color: \"#000000\" /* Palette.neutralColor100 */,\n                grouping: false,\n                /**\n                 * The parent series of the error bar. The default value links it to\n                 * the previous series. Otherwise,\n            use the id of the parent series.\n                 *\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                linkedTo: ':previous',\n                tooltip: {\n                    pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'\n                },\n                /**\n                 * The line width of the whiskers,\n            the horizontal lines marking\n                 * low and high values. When `null`,\n            the general\n                 * [lineWidth](#plotOptions.errorbar.lineWidth) applies.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/\n                 *         Error bar styling\n                 *\n                 * @type    {number}\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                whiskerWidth: null\n            };\n        /**\n         * A `errorbar` series. If the [type](#series.errorbar.type) option\n         * is not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.errorbar\n         * @excluding dataParser, dataURL, stack, stacking, boostThreshold,\n         *            boostBlending\n         * @product   highcharts\n         * @requires  highcharts-more\n         * @apioption series.errorbar\n         */\n        /**\n         * An array of data points for the series. For the `errorbar` series\n         * type, points can be given in the following ways:\n         *\n         * 1. An array of arrays with 3 or 2 values. In this case, the values correspond\n         *    to `x,low,high`. If the first value is a string, it is applied as the name\n         *    of the point, and the `x` value is inferred. The `x` value can also be\n         *    omitted, in which case the inner arrays should be of length 2\\. Then the\n         *    `x` value is automatically calculated, either starting at 0 and\n         *    incremented by 1, or from `pointStart` and `pointInterval` given in the\n         *    series options.\n         *    ```js\n         *    data: [\n         *        [0, 10, 2],\n         *        [1, 1, 8],\n         *        [2, 4, 5]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.errorbar.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        low: 0,\n         *        high: 0,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        low: 5,\n         *        high: 5,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number>|Array<(number|string),number,number>|*>}\n         * @extends   series.arearange.data\n         * @excluding dataLabels, drilldown, marker, states\n         * @product   highcharts\n         * @apioption series.errorbar.data\n         */\n        ''; // adds doclets above to transpiled file\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ErrorBarSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/ErrorBar/ErrorBarSeries.js', [_modules['Series/BoxPlot/BoxPlotSeries.js'], _modules['Series/Column/ColumnSeries.js'], _modules['Series/ErrorBar/ErrorBarSeriesDefaults.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (BoxPlotSeries, ColumnSeries, ErrorBarSeriesDefaults, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var AreaRangeSeries = SeriesRegistry.seriesTypes.arearange;\n        var addEvent = U.addEvent,\n            merge = U.merge,\n            extend = U.extend;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Errorbar series type\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.errorbar\n         *\n         * @augments Highcharts.Series\n         *\n         */\n        var ErrorBarSeries = /** @class */ (function (_super) {\n                __extends(ErrorBarSeries, _super);\n            function ErrorBarSeries() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                return _this;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            ErrorBarSeries.prototype.getColumnMetrics = function () {\n                // Get the width and X offset, either on top of the linked series\n                // column or standalone\n                return ((this.linkedParent && this.linkedParent.columnMetrics) ||\n                    ColumnSeries.prototype.getColumnMetrics.call(this));\n            };\n            ErrorBarSeries.prototype.drawDataLabels = function () {\n                var valKey = this.pointValKey;\n                if (AreaRangeSeries) {\n                    AreaRangeSeries.prototype.drawDataLabels.call(this);\n                    // Arearange drawDataLabels does not reset point.y to high,\n                    // but to low after drawing (#4133)\n                    this.data.forEach(function (point) {\n                        point.y = point[valKey];\n                    });\n                }\n            };\n            ErrorBarSeries.prototype.toYData = function (point) {\n                // return a plain array for speedy calculation\n                return [point.low, point.high];\n            };\n            ErrorBarSeries.defaultOptions = merge(BoxPlotSeries.defaultOptions, ErrorBarSeriesDefaults);\n            return ErrorBarSeries;\n        }(BoxPlotSeries));\n        addEvent(ErrorBarSeries, 'afterTranslate', function () {\n            this.points.forEach(function (point) {\n                point.plotLow = point.plotY;\n            });\n        }, { order: 0 });\n        extend(ErrorBarSeries.prototype, {\n            // pointClass: ErrorBarPoint, // just a declaration\n            pointArrayMap: ['low', 'high'],\n            pointValKey: 'high',\n            doQuartiles: false\n        });\n        SeriesRegistry.registerSeriesType('errorbar', ErrorBarSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ErrorBarSeries;\n    });\n    _registerModule(_modules, 'Series/Gauge/GaugePoint.js', [_modules['Core/Series/SeriesRegistry.js']], function (SeriesRegistry) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var Point = SeriesRegistry.series.prototype.pointClass;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var GaugePoint = /** @class */ (function (_super) {\n                __extends(GaugePoint, _super);\n            function GaugePoint() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.options = void 0;\n                _this.series = void 0;\n                _this.shapeArgs = void 0;\n                return _this;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Don't do any hover colors or anything\n             * @private\n             */\n            GaugePoint.prototype.setState = function (state) {\n                this.state = state;\n            };\n            return GaugePoint;\n        }(Point));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return GaugePoint;\n    });\n    _registerModule(_modules, 'Series/Gauge/GaugeSeries.js', [_modules['Series/Gauge/GaugePoint.js'], _modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (GaugePoint, H, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var noop = H.noop;\n        var Series = SeriesRegistry.series,\n            ColumnSeries = SeriesRegistry.seriesTypes.column;\n        var clamp = U.clamp,\n            isNumber = U.isNumber,\n            extend = U.extend,\n            merge = U.merge,\n            pick = U.pick,\n            pInt = U.pInt;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         *\n         * The `gauge` series type\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.map\n         *\n         * @augments Highcharts.Series\n         */\n        var GaugeSeries = /** @class */ (function (_super) {\n                __extends(GaugeSeries, _super);\n            function GaugeSeries() {\n                /* *\n                 *\n                 *  Static properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.data = void 0;\n                _this.points = void 0;\n                _this.options = void 0;\n                _this.yAxis = void 0;\n                return _this;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Calculate paths etc\n             * @private\n             */\n            GaugeSeries.prototype.translate = function () {\n                var series = this,\n                    yAxis = series.yAxis,\n                    options = series.options,\n                    center = yAxis.center;\n                series.generatePoints();\n                series.points.forEach(function (point) {\n                    var dialOptions = merge(options.dial,\n                        point.dial),\n                        radius = (pInt(dialOptions.radius) * center[2]) / 200,\n                        baseLength = (pInt(dialOptions.baseLength) * radius) / 100,\n                        rearLength = (pInt(dialOptions.rearLength) * radius) / 100,\n                        baseWidth = dialOptions.baseWidth,\n                        topWidth = dialOptions.topWidth;\n                    var overshoot = options.overshoot,\n                        rotation = yAxis.startAngleRad + yAxis.translate(point.y,\n                        void 0,\n                        void 0,\n                        void 0,\n                        true);\n                    // Handle the wrap and overshoot options\n                    if (isNumber(overshoot) || options.wrap === false) {\n                        overshoot = isNumber(overshoot) ?\n                            (overshoot / 180 * Math.PI) : 0;\n                        rotation = clamp(rotation, yAxis.startAngleRad - overshoot, yAxis.endAngleRad + overshoot);\n                    }\n                    rotation = rotation * 180 / Math.PI;\n                    point.shapeType = 'path';\n                    var d = dialOptions.path || [\n                            ['M', -rearLength, -baseWidth / 2],\n                            ['L',\n                        baseLength, -baseWidth / 2],\n                            ['L',\n                        radius, -topWidth / 2],\n                            ['L',\n                        radius,\n                        topWidth / 2],\n                            ['L',\n                        baseLength,\n                        baseWidth / 2],\n                            ['L', -rearLength,\n                        baseWidth / 2],\n                            ['Z']\n                        ];\n                    point.shapeArgs = {\n                        d: d,\n                        translateX: center[0],\n                        translateY: center[1],\n                        rotation: rotation\n                    };\n                    // Positions for data label\n                    point.plotX = center[0];\n                    point.plotY = center[1];\n                });\n            };\n            /**\n             * Draw the points where each point is one needle\n             * @private\n             */\n            GaugeSeries.prototype.drawPoints = function () {\n                var series = this,\n                    chart = series.chart,\n                    center = series.yAxis.center,\n                    pivot = series.pivot,\n                    options = series.options,\n                    pivotOptions = options.pivot,\n                    renderer = chart.renderer;\n                series.points.forEach(function (point) {\n                    var graphic = point.graphic,\n                        shapeArgs = point.shapeArgs,\n                        d = shapeArgs.d,\n                        dialOptions = merge(options.dial,\n                        point.dial); // #1233\n                        if (graphic) {\n                            graphic.animate(shapeArgs);\n                        shapeArgs.d = d; // animate alters it\n                    }\n                    else {\n                        point.graphic =\n                            renderer[point.shapeType](shapeArgs)\n                                .attr({\n                                // required by VML when animation is false\n                                rotation: shapeArgs.rotation,\n                                zIndex: 1\n                            })\n                                .addClass('highcharts-dial')\n                                .add(series.group);\n                    }\n                    // Presentational attributes\n                    if (!chart.styledMode) {\n                        point.graphic[graphic ? 'animate' : 'attr']({\n                            stroke: dialOptions.borderColor,\n                            'stroke-width': dialOptions.borderWidth,\n                            fill: dialOptions.backgroundColor\n                        });\n                    }\n                });\n                // Add or move the pivot\n                if (pivot) {\n                    pivot.animate({\n                        translateX: center[0],\n                        translateY: center[1]\n                    });\n                }\n                else if (pivotOptions) {\n                    series.pivot =\n                        renderer.circle(0, 0, pivotOptions.radius)\n                            .attr({\n                            zIndex: 2\n                        })\n                            .addClass('highcharts-pivot')\n                            .translate(center[0], center[1])\n                            .add(series.group);\n                    // Presentational attributes\n                    if (!chart.styledMode) {\n                        series.pivot.attr({\n                            fill: pivotOptions.backgroundColor,\n                            stroke: pivotOptions.borderColor,\n                            'stroke-width': pivotOptions.borderWidth\n                        });\n                    }\n                }\n            };\n            /**\n             * Animate the arrow up from startAngle\n             * @private\n             */\n            GaugeSeries.prototype.animate = function (init) {\n                var series = this;\n                if (!init) {\n                    series.points.forEach(function (point) {\n                        var graphic = point.graphic;\n                        if (graphic) {\n                            // start value\n                            graphic.attr({\n                                rotation: series.yAxis.startAngleRad * 180 / Math.PI\n                            });\n                            // animate\n                            graphic.animate({\n                                rotation: point.shapeArgs.rotation\n                            }, series.options.animation);\n                        }\n                    });\n                }\n            };\n            /**\n             * @private\n             */\n            GaugeSeries.prototype.render = function () {\n                this.group = this.plotGroup('group', 'series', this.visible ? 'inherit' : 'hidden', this.options.zIndex, this.chart.seriesGroup);\n                Series.prototype.render.call(this);\n                this.group.clip(this.chart.clipRect);\n            };\n            /**\n             * Extend the basic setData method by running processData and generatePoints\n             * immediately, in order to access the points from the legend.\n             * @private\n             */\n            GaugeSeries.prototype.setData = function (data, redraw) {\n                Series.prototype.setData.call(this, data, false);\n                this.processData();\n                this.generatePoints();\n                if (pick(redraw, true)) {\n                    this.chart.redraw();\n                }\n            };\n            /**\n             * Define hasData function for non-cartesian series.\n             * Returns true if the series has points at all.\n             * @private\n             */\n            GaugeSeries.prototype.hasData = function () {\n                return !!this.points.length; // != 0\n            };\n            /**\n             * Gauges are circular plots displaying one or more values with a dial\n             * pointing to values along the perimeter.\n             *\n             * @sample highcharts/demo/gauge-speedometer/\n             *         Gauge chart\n             *\n             * @extends      plotOptions.line\n             * @excluding    animationLimit, boostThreshold, colorAxis, colorKey,\n             *               connectEnds, connectNulls, cropThreshold, dashStyle,\n             *               dragDrop, findNearestPointBy, getExtremesFromAll, marker,\n             *               negativeColor, pointPlacement, shadow, softThreshold,\n             *               stacking, states, step, threshold, turboThreshold, xAxis,\n             *               zoneAxis, zones, dataSorting, boostBlending\n             * @product      highcharts\n             * @requires     highcharts-more\n             * @optionparent plotOptions.gauge\n             */\n            GaugeSeries.defaultOptions = merge(Series.defaultOptions, {\n                /**\n                 * When this option is `true`, the dial will wrap around the axes.\n                 * For instance, in a full-range gauge going from 0 to 360, a value\n                 * of 400 will point to 40\\. When `wrap` is `false`, the dial stops\n                 * at 360.\n                 *\n                 * @see [overshoot](#plotOptions.gauge.overshoot)\n                 *\n                 * @type      {boolean}\n                 * @default   true\n                 * @since     3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.gauge.wrap\n                 */\n                /**\n                 * Data labels for the gauge. For gauges, the data labels are\n                 * enabled by default and shown in a bordered box below the point.\n                 *\n                 * @since   2.3.0\n                 * @product highcharts\n                 */\n                dataLabels: {\n                    borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n                    borderRadius: 3,\n                    borderWidth: 1,\n                    crop: false,\n                    defer: false,\n                    enabled: true,\n                    verticalAlign: 'top',\n                    y: 15,\n                    zIndex: 2\n                },\n                /**\n                 * Options for the dial or arrow pointer of the gauge.\n                 *\n                 * In styled mode, the dial is styled with the\n                 * `.highcharts-gauge-series .highcharts-dial` rule.\n                 *\n                 * @sample {highcharts} highcharts/css/gauge/\n                 *         Styled mode\n                 *\n                 * @type    {*}\n                 * @since   2.3.0\n                 * @product highcharts\n                 */\n                dial: {\n                    /**\n                     * The background or fill color of the gauge's dial.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @default   #000000\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.backgroundColor\n                     */\n                    backgroundColor: \"#000000\" /* Palette.neutralColor100 */,\n                    /**\n                     * The length of the dial's base part, relative to the total\n                     * radius or length of the dial.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {string}\n                     * @default   70%\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.baseLength\n                     */\n                    baseLength: '70%',\n                    /**\n                     * The pixel width of the base of the gauge dial. The base is\n                     * the part closest to the pivot, defined by baseLength.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {number}\n                     * @default   3\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.baseWidth\n                     */\n                    baseWidth: 3,\n                    /**\n                     * The border color or stroke of the gauge's dial. By default,\n                     * the borderWidth is 0, so this must be set in addition to a\n                     * custom border color.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @default   #cccccc\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.borderColor\n                     */\n                    borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n                    /**\n                     * The width of the gauge dial border in pixels.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {number}\n                     * @default   0\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.borderWidth\n                     */\n                    borderWidth: 0,\n                    /**\n                     * An array with an SVG path for the custom dial.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-path/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {Highcharts.SVGPathArray}\n                     * @since 10.2.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.path\n                     */\n                    /**\n                     * The radius or length of the dial, in percentages relative to\n                     * the radius of the gauge itself.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {string}\n                     * @default   80%\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.radius\n                     */\n                    radius: '80%',\n                    /**\n                     * The length of the dial's rear end, the part that extends out\n                     * on the other side of the pivot. Relative to the dial's\n                     * length.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {string}\n                     * @default   10%\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.rearLength\n                     */\n                    rearLength: '10%',\n                    /**\n                     * The width of the top of the dial, closest to the perimeter.\n                     * The pivot narrows in from the base to the top.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-dial/\n                     *         Dial options demonstrated\n                     *\n                     * @type      {number}\n                     * @default   1\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.dial.topWidth\n                     */\n                    topWidth: 1\n                },\n                /**\n                 * Allow the dial to overshoot the end of the perimeter axis by\n                 * this many degrees. Say if the gauge axis goes from 0 to 60, a\n                 * value of 100, or 1000, will show 5 degrees beyond the end of the\n                 * axis when this option is set to 5.\n                 *\n                 * @see [wrap](#plotOptions.gauge.wrap)\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/gauge-overshoot/\n                 *         Allow 5 degrees overshoot\n                 *\n                 * @type      {number}\n                 * @since     3.0.10\n                 * @product   highcharts\n                 * @apioption plotOptions.gauge.overshoot\n                 */\n                /**\n                 * Options for the pivot or the center point of the gauge.\n                 *\n                 * In styled mode, the pivot is styled with the\n                 * `.highcharts-gauge-series .highcharts-pivot` rule.\n                 *\n                 * @sample {highcharts} highcharts/css/gauge/\n                 *         Styled mode\n                 *\n                 * @type    {*}\n                 * @since   2.3.0\n                 * @product highcharts\n                 */\n                pivot: {\n                    /**\n                     * The pixel radius of the pivot.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-pivot/\n                     *         Pivot options demonstrated\n                     *\n                     * @type      {number}\n                     * @default   5\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.pivot.radius\n                     */\n                    radius: 5,\n                    /**\n                     * The border or stroke width of the pivot.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-pivot/\n                     *         Pivot options demonstrated\n                     *\n                     * @type      {number}\n                     * @default   0\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.pivot.borderWidth\n                     */\n                    borderWidth: 0,\n                    /**\n                     * The border or stroke color of the pivot. In able to change\n                     * this, the borderWidth must also be set to something other\n                     * than the default 0.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-pivot/\n                     *         Pivot options demonstrated\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @default   #cccccc\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.pivot.borderColor\n                     */\n                    borderColor: \"#cccccc\" /* Palette.neutralColor20 */,\n                    /**\n                     * The background color or fill of the pivot.\n                     *\n                     * @sample {highcharts} highcharts/plotoptions/gauge-pivot/\n                     *         Pivot options demonstrated\n                     *\n                     * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                     * @default   #000000\n                     * @since     2.3.0\n                     * @product   highcharts\n                     * @apioption plotOptions.gauge.pivot.backgroundColor\n                     */\n                    backgroundColor: \"#000000\" /* Palette.neutralColor100 */\n                },\n                tooltip: {\n                    headerFormat: ''\n                },\n                /**\n                 * Whether to display this particular series or series type in the\n                 * legend. Defaults to false for gauge series.\n                 *\n                 * @since   2.3.0\n                 * @product highcharts\n                 */\n                showInLegend: false\n                // Prototype members\n            });\n            return GaugeSeries;\n        }(Series));\n        extend(GaugeSeries.prototype, {\n            // chart.angular will be set to true when a gauge series is present,\n            // and this will be used on the axes\n            angular: true,\n            directTouch: true,\n            drawGraph: noop,\n            drawTracker: ColumnSeries.prototype.drawTracker,\n            fixedBox: true,\n            forceDL: true,\n            noSharedTooltip: true,\n            pointClass: GaugePoint,\n            trackerGroups: ['group', 'dataLabelsGroup']\n        });\n        SeriesRegistry.registerSeriesType('gauge', GaugeSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API options\n         *\n         * */\n        /**\n         * A `gauge` series. If the [type](#series.gauge.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.gauge\n         * @excluding animationLimit, boostThreshold, connectEnds, connectNulls,\n         *            cropThreshold, dashStyle, dataParser, dataURL, findNearestPointBy,\n         *            getExtremesFromAll, marker, negativeColor, pointPlacement, shadow,\n         *            softThreshold, stack, stacking, states, step, threshold,\n         *            turboThreshold, zoneAxis, zones, dataSorting, boostBlending\n         * @product   highcharts\n         * @requires  highcharts-more\n         * @apioption series.gauge\n         */\n        /**\n         * An array of data points for the series. For the `gauge` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of numerical values. In this case, the numerical values will be\n         *    interpreted as `y` options. Example:\n         *    ```js\n         *    data: [0, 5, 3, 5]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.gauge.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        y: 6,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        y: 8,\n         *        name: \"Point1\",\n         *       color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * The typical gauge only contains a single data value.\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         Numerical values\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<number|null|*>}\n         * @extends   series.line.data\n         * @excluding drilldown, marker, x\n         * @product   highcharts\n         * @apioption series.gauge.data\n         */\n        ''; // adds the doclets above in the transpiled file\n\n        return GaugeSeries;\n    });\n    _registerModule(_modules, 'Series/DragNodesComposition.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var addEvent = U.addEvent;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedClasses = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function compose(ChartClass) {\n            if (composedClasses.indexOf(ChartClass) === -1) {\n                composedClasses.push(ChartClass);\n                addEvent(ChartClass, 'load', onChartLoad);\n            }\n        }\n        /**\n         * Draggable mode:\n         * @private\n         */\n        function onChartLoad() {\n            var chart = this;\n            var mousedownUnbinder,\n                mousemoveUnbinder,\n                mouseupUnbinder;\n            if (chart.container) {\n                mousedownUnbinder = addEvent(chart.container, 'mousedown', function (event) {\n                    var point = chart.hoverPoint;\n                    if (point &&\n                        point.series &&\n                        point.series.hasDraggableNodes &&\n                        point.series.options.draggable) {\n                        point.series.onMouseDown(point, event);\n                        mousemoveUnbinder = addEvent(chart.container, 'mousemove', function (e) { return (point &&\n                            point.series &&\n                            point.series.onMouseMove(point, e)); });\n                        mouseupUnbinder = addEvent(chart.container.ownerDocument, 'mouseup', function (e) {\n                            mousemoveUnbinder();\n                            mouseupUnbinder();\n                            return point &&\n                                point.series &&\n                                point.series.onMouseUp(point, e);\n                        });\n                    }\n                });\n            }\n            addEvent(chart, 'destroy', function () {\n                mousedownUnbinder();\n            });\n        }\n        /**\n         * Mouse down action, initializing drag&drop mode.\n         *\n         * @private\n         * @param {Highcharts.Point} point\n         *        The point that event occured.\n         * @param {Highcharts.PointerEventObject} event\n         *        Browser event, before normalization.\n         */\n        function onMouseDown(point, event) {\n            var normalizedEvent = this.chart.pointer.normalize(event);\n            point.fixedPosition = {\n                chartX: normalizedEvent.chartX,\n                chartY: normalizedEvent.chartY,\n                plotX: point.plotX,\n                plotY: point.plotY\n            };\n            point.inDragMode = true;\n        }\n        /**\n         * Mouse move action during drag&drop.\n         *\n         * @private\n         *\n         * @param {global.Event} event\n         *        Browser event, before normalization.\n         * @param {Highcharts.Point} point\n         *        The point that event occured.\n         *\n         */\n        function onMouseMove(point, event) {\n            if (point.fixedPosition && point.inDragMode) {\n                var series = this,\n                    chart = series.chart,\n                    normalizedEvent = chart.pointer.normalize(event),\n                    diffX = point.fixedPosition.chartX - normalizedEvent.chartX,\n                    diffY = point.fixedPosition.chartY - normalizedEvent.chartY,\n                    graphLayoutsLookup = chart.graphLayoutsLookup;\n                var newPlotX = void 0,\n                    newPlotY = void 0;\n                // At least 5px to apply change (avoids simple click):\n                if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {\n                    newPlotX = point.fixedPosition.plotX - diffX;\n                    newPlotY = point.fixedPosition.plotY - diffY;\n                    if (chart.isInsidePlot(newPlotX, newPlotY)) {\n                        point.plotX = newPlotX;\n                        point.plotY = newPlotY;\n                        point.hasDragged = true;\n                        this.redrawHalo(point);\n                        graphLayoutsLookup.forEach(function (layout) {\n                            layout.restartSimulation();\n                        });\n                    }\n                }\n            }\n        }\n        /**\n         * Mouse up action, finalizing drag&drop.\n         *\n         * @private\n         * @param {Highcharts.Point} point\n         *        The point that event occured.\n         */\n        function onMouseUp(point, _event) {\n            if (point.fixedPosition) {\n                if (point.hasDragged) {\n                    if (this.layout.enableSimulation) {\n                        this.layout.start();\n                    }\n                    else {\n                        this.chart.redraw();\n                    }\n                }\n                point.inDragMode = point.hasDragged = false;\n                if (!this.options.fixedDraggable) {\n                    delete point.fixedPosition;\n                }\n            }\n        }\n        /**\n         * Redraw halo on mousemove during the drag&drop action.\n         *\n         * @private\n         * @param {Highcharts.Point} point\n         *        The point that should show halo.\n         */\n        function redrawHalo(point) {\n            if (point && this.halo) {\n                this.halo.attr({\n                    d: point.haloPath(this.options.states.hover.halo.size)\n                });\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var DragNodesComposition = {\n                compose: compose,\n                onMouseDown: onMouseDown,\n                onMouseMove: onMouseMove,\n                onMouseUp: onMouseUp,\n                redrawHalo: redrawHalo\n            };\n\n        return DragNodesComposition;\n    });\n    _registerModule(_modules, 'Series/GraphLayoutComposition.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Utilities.js']], function (A, U) {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var setAnimation = A.setAnimation;\n        var addEvent = U.addEvent;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedClasses = [];\n        var integrations = {};\n        var layouts = {};\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function compose(ChartClass) {\n            if (composedClasses.indexOf(ChartClass)) {\n                composedClasses.push(ChartClass);\n                addEvent(ChartClass, 'afterPrint', onChartAfterPrint);\n                addEvent(ChartClass, 'beforePrint', onChartBeforePrint);\n                addEvent(ChartClass, 'predraw', onChartPredraw);\n                addEvent(ChartClass, 'render', onChartRender);\n            }\n        }\n        /**\n         * Re-enable simulation after print.\n         * @private\n         */\n        function onChartAfterPrint() {\n            if (this.graphLayoutsLookup) {\n                this.graphLayoutsLookup.forEach(function (layout) {\n                    // return to default simulation\n                    layout.updateSimulation();\n                });\n                this.redraw();\n            }\n        }\n        /**\n         * Disable simulation before print if enabled.\n         * @private\n         */\n        function onChartBeforePrint() {\n            if (this.graphLayoutsLookup) {\n                this.graphLayoutsLookup.forEach(function (layout) {\n                    layout.updateSimulation(false);\n                });\n                this.redraw();\n            }\n        }\n        /**\n         * Clear previous layouts.\n         * @private\n         */\n        function onChartPredraw() {\n            if (this.graphLayoutsLookup) {\n                this.graphLayoutsLookup.forEach(function (layout) {\n                    layout.stop();\n                });\n            }\n        }\n        /**\n         * @private\n         */\n        function onChartRender() {\n            var systemsStable,\n                afterRender = false;\n            var layoutStep = function (layout) {\n                    if (layout.maxIterations-- &&\n                        isFinite(layout.temperature) &&\n                        !layout.isStable() &&\n                        !layout.enableSimulation) {\n                        // Hook similar to build-in addEvent, but instead of\n                        // creating whole events logic, use just a function.\n                        // It's faster which is important for rAF code.\n                        // Used e.g. in packed-bubble series for bubble radius\n                        // calculations\n                        if (layout.beforeStep) {\n                            layout.beforeStep();\n                    }\n                    layout.step();\n                    systemsStable = false;\n                    afterRender = true;\n                }\n            };\n            if (this.graphLayoutsLookup) {\n                setAnimation(false, this);\n                // Start simulation\n                this.graphLayoutsLookup.forEach(function (layout) { return layout.start(); });\n                // Just one sync step, to run different layouts similar to\n                // async mode.\n                while (!systemsStable) {\n                    systemsStable = true;\n                    this.graphLayoutsLookup.forEach(layoutStep);\n                }\n                if (afterRender) {\n                    this.series.forEach(function (series) {\n                        if (series && series.layout) {\n                            series.render();\n                        }\n                    });\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var GraphLayoutComposition = {\n                compose: compose,\n                integrations: integrations,\n                layouts: layouts\n            };\n\n        return GraphLayoutComposition;\n    });\n    _registerModule(_modules, 'Series/PackedBubble/PackedBubblePoint.js', [_modules['Core/Chart/Chart.js'], _modules['Core/Series/Point.js'], _modules['Core/Series/SeriesRegistry.js']], function (Chart, Point, SeriesRegistry) {\n        /* *\n         *\n         *  (c) 2010-2021 Grzegorz Blachlinski, Sebastian Bochan\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var BubblePoint = SeriesRegistry.seriesTypes.bubble.prototype.pointClass;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var PackedBubblePoint = /** @class */ (function (_super) {\n                __extends(PackedBubblePoint, _super);\n            function PackedBubblePoint() {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.degree = NaN;\n                _this.mass = NaN;\n                _this.radius = NaN;\n                _this.options = void 0;\n                _this.series = void 0;\n                _this.value = null;\n                return _this;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Destroy point.\n             * Then remove point from the layout.\n             * @private\n             */\n            PackedBubblePoint.prototype.destroy = function () {\n                if (this.series.layout) {\n                    this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);\n                }\n                return Point.prototype.destroy.apply(this, arguments);\n            };\n            PackedBubblePoint.prototype.firePointEvent = function () {\n                var point = this,\n                    series = this.series,\n                    seriesOptions = series.options;\n                if (this.isParentNode && seriesOptions.parentNode) {\n                    var temp = seriesOptions.allowPointSelect;\n                    seriesOptions.allowPointSelect = (seriesOptions.parentNode.allowPointSelect);\n                    Point.prototype.firePointEvent.apply(this, arguments);\n                    seriesOptions.allowPointSelect = temp;\n                }\n                else {\n                    Point.prototype.firePointEvent.apply(this, arguments);\n                }\n            };\n            PackedBubblePoint.prototype.select = function () {\n                var point = this,\n                    series = this.series,\n                    chart = series.chart;\n                if (point.isParentNode) {\n                    chart.getSelectedPoints = chart.getSelectedParentNodes;\n                    Point.prototype.select.apply(this, arguments);\n                    chart.getSelectedPoints = Chart.prototype.getSelectedPoints;\n                }\n                else {\n                    Point.prototype.select.apply(this, arguments);\n                }\n            };\n            return PackedBubblePoint;\n        }(BubblePoint));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return PackedBubblePoint;\n    });\n    _registerModule(_modules, 'Series/PackedBubble/PackedBubbleSeriesDefaults.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        var isNumber = U.isNumber;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * A packed bubble series is a two dimensional series type, where each point\n         * renders a value in X, Y position. Each point is drawn as a bubble\n         * where the bubbles don't overlap with each other and the radius\n         * of the bubble relates to the value.\n         *\n         * @sample highcharts/demo/packed-bubble/\n         *         Packed bubble chart\n         * @sample highcharts/demo/packed-bubble-split/\n         *         Split packed bubble chart\n         *\n         * @extends      plotOptions.bubble\n         * @excluding    connectEnds, connectNulls, cropThreshold, dragDrop, jitter,\n         *               keys, pointPlacement, sizeByAbsoluteValue, step, xAxis,\n         *               yAxis, zMax, zMin, dataSorting, boostThreshold,\n         *               boostBlending\n         * @product      highcharts\n         * @since        7.0.0\n         * @requires     highcharts-more\n         * @optionparent plotOptions.packedbubble\n         *\n         * @private\n         */\n        var PackedBubbleSeriesDefaults = {\n                /**\n                 * Minimum bubble size. Bubbles will automatically size between the\n                 * `minSize` and `maxSize` to reflect the value of each bubble.\n                 * Can be either pixels (when no unit is given),\n            or a percentage of\n                 * the smallest one of the plot width and height,\n            divided by the square\n                 * root of total number of points.\n                 *\n                 * @sample highcharts/plotoptions/bubble-size/\n                 *         Bubble size\n                 *\n                 * @type {number|string}\n                 *\n                 * @private\n                 */\n                minSize: '10%',\n                /**\n                 * Maximum bubble size. Bubbles will automatically size between the\n                 * `minSize` and `maxSize` to reflect the value of each bubble.\n                 * Can be either pixels (when no unit is given),\n            or a percentage of\n                 * the smallest one of the plot width and height,\n            divided by the square\n                 * root of total number of points.\n                 *\n                 * @sample highcharts/plotoptions/bubble-size/\n                 *         Bubble size\n                 *\n                 * @type {number|string}\n                 *\n                 * @private\n                 */\n                maxSize: '50%',\n                sizeBy: 'area',\n                zoneAxis: 'y',\n                crisp: false,\n                tooltip: {\n                    pointFormat: 'Value: {point.value}'\n                },\n                /**\n                 * Flag to determine if nodes are draggable or not. Available for\n                 * graph with useSimulation set to true only.\n                 *\n                 * @since 7.1.0\n                 *\n                 * @private\n                 */\n                draggable: true,\n                /**\n                 * An option is giving a possibility to choose between using simulation\n                 * for calculating bubble positions. These reflects in both animation\n                 * and final position of bubbles. Simulation is also adding options to\n                 * the series graph based on used layout. In case of big data sets,\n            with\n                 * any performance issues,\n            it is possible to disable animation and pack\n                 * bubble in a simple circular way.\n                 *\n                 * @sample highcharts/series-packedbubble/spiral/\n                 *         useSimulation set to false\n                 *\n                 * @since 7.1.0\n                 *\n                 * @private\n                 */\n                useSimulation: true,\n                /**\n                 * Series options for parent nodes.\n                 *\n                 * @since 8.1.1\n                 *\n                 * @private\n                 */\n                parentNode: {\n                    /**\n                     * Allow this series' parent nodes to be selected\n                     * by clicking on the graph.\n                     *\n                     * @since 8.1.1\n                     */\n                    allowPointSelect: false\n                },\n                /**\n                /**\n                 *\n                 * @declare Highcharts.SeriesPackedBubbleDataLabelsOptionsObject\n                 *\n                 * @private\n                 */\n                dataLabels: {\n                    /**\n                     * The\n                     * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)\n                     * specifying what to show for _node_ in the networkgraph. In v7.0\n                     * defaults to `{key}`,\n            since v7.1 defaults to `undefined` and\n                     * `formatter` is used instead.\n                     *\n                     * @type      {string}\n                     * @since     7.0.0\n                     * @apioption plotOptions.packedbubble.dataLabels.format\n                     */\n                    // eslint-disable-next-line valid-jsdoc\n                    /**\n                     * Callback JavaScript function to format the data label for a node.\n                     * Note that if a `format` is defined,\n            the format takes precedence\n                     * and the formatter is ignored.\n                     *\n                     * @type  {Highcharts.SeriesPackedBubbleDataLabelsFormatterCallbackFunction}\n                     * @since 7.0.0\n                     */\n                    formatter: function () {\n                        var numberFormatter = this.series.chart.numberFormatter;\n                    var value = this.point.value;\n                    return isNumber(value) ? numberFormatter(value, -1) : '';\n                },\n                /**\n                 * @type      {string}\n                 * @since     7.1.0\n                 * @apioption plotOptions.packedbubble.dataLabels.parentNodeFormat\n                 */\n                // eslint-disable-next-line valid-jsdoc\n                /**\n                 * @type  {Highcharts.SeriesPackedBubbleDataLabelsFormatterCallbackFunction}\n                 * @since 7.1.0\n                 */\n                parentNodeFormatter: function () {\n                    return this.name;\n                },\n                /**\n                 * @sample {highcharts} highcharts/series-packedbubble/packed-dashboard\n                 *         Dashboard with dataLabels on parentNodes\n                 *\n                 * @declare Highcharts.SeriesPackedBubbleDataLabelsTextPathOptionsObject\n                 * @since   7.1.0\n                 */\n                parentNodeTextPath: {\n                    /**\n                     * Presentation attributes for the text path.\n                     *\n                     * @type      {Highcharts.SVGAttributes}\n                     * @since     7.1.0\n                     * @apioption plotOptions.packedbubble.dataLabels.attributes\n                     */\n                    /**\n                     * Enable or disable `textPath` option for link's or marker's\n                     * data labels.\n                     *\n                     * @since 7.1.0\n                     */\n                    enabled: true\n                },\n                /**\n                 * Options for a _node_ label text which should follow marker's\n                 * shape.\n                 *\n                 * **Note:** Only SVG-based renderer supports this option.\n                 *\n                 * @extends   plotOptions.series.dataLabels.textPath\n                 * @apioption plotOptions.packedbubble.dataLabels.textPath\n                 */\n                padding: 0,\n                style: {\n                    transition: 'opacity 2000ms'\n                }\n            },\n            /**\n             * Options for layout algorithm when simulation is enabled. Inside there\n             * are options to change the speed, padding, initial bubbles positions\n             * and more.\n             *\n             * @extends   plotOptions.networkgraph.layoutAlgorithm\n             * @excluding approximation, attractiveForce, repulsiveForce, theta\n             * @since     7.1.0\n             *\n             * @private\n             */\n            layoutAlgorithm: {\n                /**\n                 * Initial layout algorithm for positioning nodes. Can be one of\n                 * the built-in options (\"circle\", \"random\") or a function where\n                 * positions should be set on each node (`this.nodes`) as\n                 * `node.plotX` and `node.plotY`.\n                 *\n                 * @sample highcharts/series-networkgraph/initial-positions/\n                 *         Initial positions with callback\n                 *\n                 * @type {\"circle\"|\"random\"|Function}\n                 */\n                initialPositions: 'circle',\n                /**\n                 * @sample highcharts/series-packedbubble/initial-radius/\n                 *         Initial radius set to 200\n                 *\n                 * @extends   plotOptions.networkgraph.layoutAlgorithm.initialPositionRadius\n                 * @excluding states\n                 */\n                initialPositionRadius: 20,\n                /**\n                 * The distance between two bubbles, when the algorithm starts to\n                 * treat two bubbles as overlapping. The `bubblePadding` is also the\n                 * expected distance between all the bubbles on simulation end.\n                 */\n                bubblePadding: 5,\n                /**\n                 * Whether bubbles should interact with their parentNode to keep\n                 * them inside.\n                 */\n                parentNodeLimit: false,\n                /**\n                 * Whether series should interact with each other or not. When\n                 * `parentNodeLimit` is set to true, thi option should be set to\n                 * false to avoid sticking points in wrong series parentNode.\n                 */\n                seriesInteraction: true,\n                /**\n                 * In case of split series, this option allows user to drag and\n                 * drop points between series, for changing point related series.\n                 *\n                 * @sample highcharts/series-packedbubble/packed-dashboard/\n                 *         Example of drag'n drop bubbles for bubble kanban\n                 */\n                dragBetweenSeries: false,\n                /**\n                 * Layout algorithm options for parent nodes.\n                 *\n                 * @extends   plotOptions.networkgraph.layoutAlgorithm\n                 * @excluding approximation, attractiveForce, enableSimulation,\n                 *            repulsiveForce, theta\n                 */\n                parentNodeOptions: {\n                    maxIterations: 400,\n                    gravitationalConstant: 0.03,\n                    maxSpeed: 50,\n                    initialPositionRadius: 100,\n                    seriesInteraction: true,\n                    /**\n                     * Styling options for parentNodes markers. Similar to\n                     * line.marker options.\n                     *\n                     * @sample highcharts/series-packedbubble/parentnode-style/\n                     *         Bubble size\n                     *\n                     * @extends   plotOptions.series.marker\n                     * @excluding states\n                     */\n                    marker: {\n                        fillColor: null,\n                        fillOpacity: 1,\n                        lineWidth: null,\n                        lineColor: null,\n                        symbol: 'circle'\n                    }\n                },\n                enableSimulation: true,\n                /**\n                 * Type of the algorithm used when positioning bubbles.\n                 * @ignore-option\n                 */\n                type: 'packedbubble',\n                /**\n                 * Integration type. Integration determines how forces are applied\n                 * on particles. The `packedbubble` integration is based on\n                 * the networkgraph `verlet` integration, where the new position\n                 * is based on a previous position without velocity:\n                 * `newPosition += previousPosition - newPosition`.\n                 *\n                 * @sample highcharts/series-networkgraph/forces/\n                 *\n                 * @ignore-option\n                 */\n                integration: 'packedbubble',\n                maxIterations: 1000,\n                /**\n                 * Whether to split series into individual groups or to mix all\n                 * series together.\n                 *\n                 * @since   7.1.0\n                 * @default false\n                 */\n                splitSeries: false,\n                /**\n                 * Max speed that node can get in one iteration. In terms of\n                 * simulation, it's a maximum translation (in pixels) that a node\n                 * can move (in both, x and y, dimensions). While `friction` is\n                 * applied on all nodes, max speed is applied only for nodes that\n                 * move very fast, for example small or disconnected ones.\n                 *\n                 * @see [layoutAlgorithm.integration](#series.networkgraph.layoutAlgorithm.integration)\n                 *\n                 * @see [layoutAlgorithm.friction](#series.networkgraph.layoutAlgorithm.friction)\n                 */\n                maxSpeed: 5,\n                gravitationalConstant: 0.01,\n                friction: -0.981\n            }\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A `packedbubble` series. If the [type](#series.packedbubble.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @type      {Object}\n         * @extends   series,plotOptions.packedbubble\n         * @excluding cropThreshold, dataParser, dataSorting, dataURL, dragDrop, stack,\n         *            boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  highcharts-more\n         * @apioption series.packedbubble\n         */\n        /**\n         * An array of data points for the series. For the `packedbubble` series type,\n         * points can be given in the following ways:\n         *\n         * 1.  An array of `values`.\n         *\n         *  ```js\n         *     data: [5, 1, 20]\n         *  ```\n         *\n         * 2.  An array of objects with named values. The objects are point\n         * configuration objects as seen below. If the total number of data points\n         * exceeds the series' [turboThreshold](#series.packedbubble.turboThreshold),\n         * this option is not available.\n         *\n         *  ```js\n         *     data: [{\n         *         value: 1,\n         *         name: \"Point2\",\n         *         color: \"#00FF00\"\n         *     }, {\n         *         value: 5,\n         *         name: \"Point1\",\n         *         color: \"#FF00FF\"\n         *     }]\n         *  ```\n         *\n         * @type      {Array<Object|Array>}\n         * @extends   series.line.data\n         * @excluding marker, x, y\n         * @sample    {highcharts} highcharts/series/data-array-of-objects/\n         *            Config objects\n         * @product   highcharts\n         * @apioption series.packedbubble.data\n         */\n        /**\n         * @type      {Highcharts.SeriesPackedBubbleDataLabelsOptionsObject|Array<Highcharts.SeriesPackedBubbleDataLabelsOptionsObject>}\n         * @product   highcharts\n         * @apioption series.packedbubble.data.dataLabels\n         */\n        /**\n         * @excluding enabled,enabledThreshold,height,radius,width\n         * @product   highcharts\n         * @apioption series.packedbubble.marker\n         */\n        ''; // adds doclets above to transpiled file\n\n        return PackedBubbleSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/Networkgraph/VerletIntegration.js', [], function () {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Attractive force.\n         *\n         * In Verlet integration, force is applied on a node immidatelly to it's\n         * `plotX` and `plotY` position.\n         *\n         * @private\n         * @param {Highcharts.Point} link\n         *        Link that connects two nodes\n         * @param {number} force\n         *        Force calcualated in `repulsiveForceFunction`\n         * @param {Highcharts.PositionObject} distance\n         *        Distance between two nodes e.g. `{x, y}`\n         */\n        function attractive(link, force, distanceXY) {\n            var massFactor = link.getMass(),\n                translatedX = -distanceXY.x * force * this.diffTemperature,\n                translatedY = -distanceXY.y * force * this.diffTemperature;\n            if (!link.fromNode.fixedPosition) {\n                link.fromNode.plotX -=\n                    translatedX * massFactor.fromNode / link.fromNode.degree;\n                link.fromNode.plotY -=\n                    translatedY * massFactor.fromNode / link.fromNode.degree;\n            }\n            if (!link.toNode.fixedPosition) {\n                link.toNode.plotX +=\n                    translatedX * massFactor.toNode / link.toNode.degree;\n                link.toNode.plotY +=\n                    translatedY * massFactor.toNode / link.toNode.degree;\n            }\n        }\n        /**\n         * Attractive force funtion. Can be replaced by API's\n         * `layoutAlgorithm.attractiveForce`\n         *\n         * @private\n         * @param {number} d current distance between two nodes\n         * @param {number} k expected distance between two nodes\n         * @return {number} force\n         */\n        function attractiveForceFunction(d, k) {\n            // Used in API:\n            return (k - d) / d;\n        }\n        /**\n         * Barycenter force. Calculate and applys barycenter forces on the\n         * nodes. Making them closer to the center of their barycenter point.\n         *\n         * In Verlet integration, force is applied on a node immidatelly to it's\n         * `plotX` and `plotY` position.\n         *\n         * @private\n         */\n        function barycenter() {\n            var gravitationalConstant = this.options.gravitationalConstant,\n                xFactor = this.barycenter.xFactor,\n                yFactor = this.barycenter.yFactor;\n            // To consider:\n            xFactor = (xFactor - (this.box.left + this.box.width) / 2) *\n                gravitationalConstant;\n            yFactor = (yFactor - (this.box.top + this.box.height) / 2) *\n                gravitationalConstant;\n            this.nodes.forEach(function (node) {\n                if (!node.fixedPosition) {\n                    node.plotX -=\n                        xFactor / node.mass / node.degree;\n                    node.plotY -=\n                        yFactor / node.mass / node.degree;\n                }\n            });\n        }\n        /**\n         * Estiamte the best possible distance between two nodes, making graph\n         * readable.\n         * @private\n         */\n        function getK(layout) {\n            return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.5);\n        }\n        /**\n         * Integration method.\n         *\n         * In Verlet integration, forces are applied on node immidatelly to it's\n         * `plotX` and `plotY` position.\n         *\n         * Verlet without velocity:\n         *\n         *    x(n+1) = 2 * x(n) - x(n-1) + A(T) * deltaT ^ 2\n         *\n         * where:\n         *     - x(n+1) - new position\n         *     - x(n) - current position\n         *     - x(n-1) - previous position\n         *\n         * Assuming A(t) = 0 (no acceleration) and (deltaT = 1) we get:\n         *\n         *     x(n+1) = x(n) + (x(n) - x(n-1))\n         *\n         * where:\n         *     - (x(n) - x(n-1)) - position change\n         *\n         * TO DO:\n         * Consider Verlet with velocity to support additional\n         * forces. Or even Time-Corrected Verlet by Jonathan\n         * \"lonesock\" Dummer\n         *\n         * @private\n         * @param {Highcharts.NetworkgraphLayout} layout layout object\n         * @param {Highcharts.Point} node node that should be translated\n         */\n        function integrate(layout, node) {\n            var friction = -layout.options.friction,\n                maxSpeed = layout.options.maxSpeed,\n                prevX = node.prevX,\n                prevY = node.prevY, \n                // Apply friciton:\n                diffX = ((node.plotX + node.dispX -\n                    prevX) * friction),\n                diffY = ((node.plotY + node.dispY -\n                    prevY) * friction),\n                abs = Math.abs,\n                signX = abs(diffX) / (diffX || 1), // need to deal with 0\n                signY = abs(diffY) / (diffY || 1);\n            // Apply max speed:\n            diffX = signX * Math.min(maxSpeed, Math.abs(diffX));\n            diffY = signY * Math.min(maxSpeed, Math.abs(diffY));\n            // Store for the next iteration:\n            node.prevX = node.plotX + node.dispX;\n            node.prevY = node.plotY + node.dispY;\n            // Update positions:\n            node.plotX += diffX;\n            node.plotY += diffY;\n            node.temperature = layout.vectorLength({\n                x: diffX,\n                y: diffY\n            });\n        }\n        /**\n         * Repulsive force.\n         *\n         * In Verlet integration, force is applied on a node immidatelly to it's\n         * `plotX` and `plotY` position.\n         *\n         * @private\n         * @param {Highcharts.Point} node\n         *        Node that should be translated by force.\n         * @param {number} force\n         *        Force calcualated in `repulsiveForceFunction`\n         * @param {Highcharts.PositionObject} distance\n         *        Distance between two nodes e.g. `{x, y}`\n         */\n        function repulsive(node, force, distanceXY) {\n            var factor = force * this.diffTemperature / node.mass / node.degree;\n            if (!node.fixedPosition) {\n                node.plotX += distanceXY.x * factor;\n                node.plotY += distanceXY.y * factor;\n            }\n        }\n        /**\n         * Repulsive force funtion. Can be replaced by API's\n         * `layoutAlgorithm.repulsiveForce`\n         *\n         * @private\n         * @param {number} d current distance between two nodes\n         * @param {number} k expected distance between two nodes\n         * @return {number} force\n         */\n        function repulsiveForceFunction(d, k) {\n            // Used in API:\n            return (k - d) / d * (k > d ? 1 : 0); // Force only for close nodes\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var VerletIntegration = {\n                attractive: attractive,\n                attractiveForceFunction: attractiveForceFunction,\n                barycenter: barycenter,\n                getK: getK,\n                integrate: integrate,\n                repulsive: repulsive,\n                repulsiveForceFunction: repulsiveForceFunction\n            };\n\n        return VerletIntegration;\n    });\n    _registerModule(_modules, 'Series/PackedBubble/PackedBubbleIntegration.js', [_modules['Core/Globals.js'], _modules['Series/Networkgraph/VerletIntegration.js']], function (H, VerletIntegration) {\n        /* *\n         *\n         *  (c) 2010-2021 Grzegorz Blachlinski, Sebastian Bochan\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var noop = H.noop;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function barycenter() {\n            var layout = this,\n                gravitationalConstant = layout.options.gravitationalConstant,\n                box = layout.box,\n                nodes = layout.nodes;\n            var centerX,\n                centerY;\n            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n                var node = nodes_1[_i];\n                if (layout.options.splitSeries && !node.isParentNode) {\n                    centerX = node.series.parentNode.plotX;\n                    centerY = node.series.parentNode.plotY;\n                }\n                else {\n                    centerX = box.width / 2;\n                    centerY = box.height / 2;\n                }\n                if (!node.fixedPosition) {\n                    node.plotX -=\n                        (node.plotX - centerX) *\n                            gravitationalConstant /\n                            (node.mass * Math.sqrt(nodes.length));\n                    node.plotY -=\n                        (node.plotY - centerY) *\n                            gravitationalConstant /\n                            (node.mass * Math.sqrt(nodes.length));\n                }\n            }\n        }\n        /**\n         * @private\n         */\n        function repulsive(node, force, distanceXY, repNode) {\n            var factor = (force * this.diffTemperature / node.mass /\n                    node.degree),\n                x = distanceXY.x * factor,\n                y = distanceXY.y * factor;\n            if (!node.fixedPosition) {\n                node.plotX += x;\n                node.plotY += y;\n            }\n            if (!repNode.fixedPosition) {\n                repNode.plotX -= x;\n                repNode.plotY -= y;\n            }\n        }\n        /**\n         * @private\n         */\n        function repulsiveForceFunction(d, k, node, repNode) {\n            return Math.min(d, (node.marker.radius +\n                repNode.marker.radius) / 2);\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var PackedBubbleIntegration = {\n                barycenter: barycenter,\n                getK: noop,\n                integrate: VerletIntegration.integrate,\n                repulsive: repulsive,\n                repulsiveForceFunction: repulsiveForceFunction\n            };\n\n        return PackedBubbleIntegration;\n    });\n    _registerModule(_modules, 'Series/Networkgraph/EulerIntegration.js', [], function () {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Attractive force.\n         *\n         * In Euler integration, force is stored in a node, not changing it's\n         * position. Later, in `integrate()` forces are applied on nodes.\n         *\n         * @private\n         * @param {Highcharts.Point} link\n         *        Link that connects two nodes\n         * @param {number} force\n         *        Force calcualated in `repulsiveForceFunction`\n         * @param {Highcharts.PositionObject} distanceXY\n         *        Distance between two nodes e.g. `{x, y}`\n         * @param {number} distanceR\n             */\n        function attractive(link, force, distanceXY, distanceR) {\n            var massFactor = link.getMass(),\n                translatedX = (distanceXY.x / distanceR) * force,\n                translatedY = (distanceXY.y / distanceR) * force;\n            if (!link.fromNode.fixedPosition) {\n                link.fromNode.dispX -=\n                    translatedX * massFactor.fromNode / link.fromNode.degree;\n                link.fromNode.dispY -=\n                    translatedY * massFactor.fromNode / link.fromNode.degree;\n            }\n            if (!link.toNode.fixedPosition) {\n                link.toNode.dispX +=\n                    translatedX * massFactor.toNode / link.toNode.degree;\n                link.toNode.dispY +=\n                    translatedY * massFactor.toNode / link.toNode.degree;\n            }\n        }\n        /**\n         * Attractive force funtion. Can be replaced by API's\n         * `layoutAlgorithm.attractiveForce`\n         *\n         * Other forces that can be used:\n         *\n         * basic, not recommended:\n         *    `function (d, k) { return d / k }`\n         *\n         * @private\n         * @param {number} d current distance between two nodes\n         * @param {number} k expected distance between two nodes\n         * @return {number} force\n         */\n        function attractiveForceFunction(d, k) {\n            return d * d / k;\n        }\n        /**\n         * Barycenter force. Calculate and applys barycenter forces on the\n         * nodes. Making them closer to the center of their barycenter point.\n         *\n         * In Euler integration, force is stored in a node, not changing it's\n         * position. Later, in `integrate()` forces are applied on nodes.\n         *\n         * @private\n         */\n        function barycenter() {\n            var gravitationalConstant = this.options.gravitationalConstant,\n                xFactor = this.barycenter.xFactor,\n                yFactor = this.barycenter.yFactor;\n            this.nodes.forEach(function (node) {\n                if (!node.fixedPosition) {\n                    var degree = node.getDegree(),\n                        phi = degree * (1 + degree / 2);\n                    node.dispX += ((xFactor - node.plotX) *\n                        gravitationalConstant *\n                        phi / node.degree);\n                    node.dispY += ((yFactor - node.plotY) *\n                        gravitationalConstant *\n                        phi / node.degree);\n                }\n            });\n        }\n        /**\n         * Estiamte the best possible distance between two nodes, making graph\n         * readable.\n         * @private\n         */\n        function getK(layout) {\n            return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.3);\n        }\n        /**\n         * Integration method.\n         *\n         * In Euler integration, force were stored in a node, not changing it's\n         * position. Now, in the integrator method, we apply changes.\n         *\n         * Euler:\n         *\n         * Basic form: `x(n+1) = x(n) + v(n)`\n         *\n         * With Rengoild-Fruchterman we get:\n         * `x(n+1) = x(n) + v(n) / length(v(n)) * min(v(n), temperature(n))`\n         * where:\n         * - `x(n+1)`: next position\n         * - `x(n)`: current position\n         * - `v(n)`: velocity (comes from net force)\n         * - `temperature(n)`: current temperature\n         *\n         * Known issues:\n         * Oscillations when force vector has the same magnitude but opposite\n         * direction in the next step. Potentially solved by decreasing force by\n         * `v * (1 / node.degree)`\n         *\n         * Note:\n         * Actually `min(v(n), temperature(n))` replaces simulated annealing.\n         *\n         * @private\n         * @param {Highcharts.NetworkgraphLayout} layout\n         *        Layout object\n         * @param {Highcharts.Point} node\n         *        Node that should be translated\n         */\n        function integrate(layout, node) {\n            var distanceR;\n            node.dispX +=\n                node.dispX * layout.options.friction;\n            node.dispY +=\n                node.dispY * layout.options.friction;\n            distanceR = node.temperature = layout.vectorLength({\n                x: node.dispX,\n                y: node.dispY\n            });\n            if (distanceR !== 0) {\n                node.plotX += (node.dispX / distanceR *\n                    Math.min(Math.abs(node.dispX), layout.temperature));\n                node.plotY += (node.dispY / distanceR *\n                    Math.min(Math.abs(node.dispY), layout.temperature));\n            }\n        }\n        /**\n         * Repulsive force.\n         *\n         * @private\n         * @param {Highcharts.Point} node\n         *        Node that should be translated by force.\n         * @param {number} force\n         *        Force calcualated in `repulsiveForceFunction`\n         * @param {Highcharts.PositionObject} distanceXY\n         *        Distance between two nodes e.g. `{x, y}`\n         */\n        function repulsive(node, force, distanceXY, distanceR) {\n            node.dispX +=\n                (distanceXY.x / distanceR) * force / node.degree;\n            node.dispY +=\n                (distanceXY.y / distanceR) * force / node.degree;\n        }\n        /**\n         * Repulsive force funtion. Can be replaced by API's\n         * `layoutAlgorithm.repulsiveForce`.\n         *\n         * Other forces that can be used:\n         *\n         * basic, not recommended:\n         *    `function (d, k) { return k / d }`\n         *\n         * standard:\n         *    `function (d, k) { return k * k / d }`\n         *\n         * grid-variant:\n         *    `function (d, k) { return k * k / d * (2 * k - d > 0 ? 1 : 0) }`\n         *\n         * @private\n         * @param {number} d current distance between two nodes\n         * @param {number} k expected distance between two nodes\n         * @return {number} force\n         */\n        function repulsiveForceFunction(d, k) {\n            return k * k / d;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        var EulerIntegration = {\n                attractive: attractive,\n                attractiveForceFunction: attractiveForceFunction,\n                barycenter: barycenter,\n                getK: getK,\n                integrate: integrate,\n                repulsive: repulsive,\n                repulsiveForceFunction: repulsiveForceFunction\n            };\n\n        return EulerIntegration;\n    });\n    _registerModule(_modules, 'Series/Networkgraph/QuadTreeNode.js', [], function () {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The QuadTree node class. Used in Networkgraph chart as a base for Barnes-Hut\n         * approximation.\n         *\n         * @private\n         * @class\n         * @name Highcharts.QuadTreeNode\n         *\n         * @param {Highcharts.Dictionary<number>} box\n         *        Available space for the node\n         */\n        var QuadTreeNode = /** @class */ (function () {\n                /* *\n                 *\n                 *  Constructor\n                 *\n                 * */\n                function QuadTreeNode(box) {\n                    /* *\n                     *\n                     *  Properties\n                     *\n                     * */\n                    /**\n                     * Read only. If QuadTreeNode is an external node, Point is stored in\n                     * `this.body`.\n                     *\n                     * @name Highcharts.QuadTreeNode#body\n                     * @type {boolean|Highcharts.Point}\n                     */\n                    this.body = false;\n                /**\n                 * Read only. Internal nodes when created are empty to reserve the\n                 * space. If Point is added to this QuadTreeNode, QuadTreeNode is no\n                 * longer empty.\n                 *\n                 * @name Highcharts.QuadTreeNode#isEmpty\n                 * @type {boolean}\n                 */\n                this.isEmpty = false;\n                /**\n                 * Read only. Flag to determine if QuadTreeNode is internal (and has\n                 * subnodes with mass and central position) or external (bound to\n                 * Point).\n                 *\n                 * @name Highcharts.QuadTreeNode#isInternal\n                 * @type {boolean}\n                 */\n                this.isInternal = false;\n                /**\n                 * Read only. Array of subnodes. Empty if QuadTreeNode has just one\n                 * Point. When added another Point to this QuadTreeNode, array is\n                 * filled with four subnodes.\n                 *\n                 * @name Highcharts.QuadTreeNode#nodes\n                 * @type {Array<Highcharts.QuadTreeNode>}\n                 */\n                this.nodes = [];\n                /**\n                 * Read only. The available space for node.\n                 *\n                 * @name Highcharts.QuadTreeNode#box\n                 * @type {Highcharts.Dictionary<number>}\n                 */\n                this.box = box;\n                /**\n                 * Read only. The minium of width and height values.\n                 *\n                 * @name Highcharts.QuadTreeNode#boxSize\n                 * @type {number}\n                 */\n                this.boxSize = Math.min(box.width, box.height);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * When inserting another node into the box, that already hove one node,\n             * divide the available space into another four quadrants.\n             *\n             * Indexes of quadrants are:\n             * ```\n             * -------------               -------------\n             * |           |               |     |     |\n             * |           |               |  0  |  1  |\n             * |           |   divide()    |     |     |\n             * |     1     | ----------->  -------------\n             * |           |               |     |     |\n             * |           |               |  3  |  2  |\n             * |           |               |     |     |\n             * -------------               -------------\n             * ```\n             */\n            QuadTreeNode.prototype.divideBox = function () {\n                var halfWidth = this.box.width / 2,\n                    halfHeight = this.box.height / 2;\n                // Top left\n                this.nodes[0] = new QuadTreeNode({\n                    left: this.box.left,\n                    top: this.box.top,\n                    width: halfWidth,\n                    height: halfHeight\n                });\n                // Top right\n                this.nodes[1] = new QuadTreeNode({\n                    left: this.box.left + halfWidth,\n                    top: this.box.top,\n                    width: halfWidth,\n                    height: halfHeight\n                });\n                // Bottom right\n                this.nodes[2] = new QuadTreeNode({\n                    left: this.box.left + halfWidth,\n                    top: this.box.top + halfHeight,\n                    width: halfWidth,\n                    height: halfHeight\n                });\n                // Bottom left\n                this.nodes[3] = new QuadTreeNode({\n                    left: this.box.left,\n                    top: this.box.top + halfHeight,\n                    width: halfWidth,\n                    height: halfHeight\n                });\n            };\n            /**\n             * Determine which of the quadrants should be used when placing node in\n             * the QuadTree. Returned index is always in range `< 0 , 3 >`.\n             * @private\n             */\n            QuadTreeNode.prototype.getBoxPosition = function (point) {\n                var left = point.plotX < this.box.left + this.box.width / 2,\n                    top = point.plotY < this.box.top + this.box.height / 2;\n                var index;\n                if (left) {\n                    if (top) {\n                        // Top left\n                        index = 0;\n                    }\n                    else {\n                        // Bottom left\n                        index = 3;\n                    }\n                }\n                else {\n                    if (top) {\n                        // Top right\n                        index = 1;\n                    }\n                    else {\n                        // Bottom right\n                        index = 2;\n                    }\n                }\n                return index;\n            };\n            /**\n             * Insert recursively point(node) into the QuadTree. If the given\n             * quadrant is already occupied, divide it into smaller quadrants.\n             *\n             * @param {Highcharts.Point} point\n             *        Point/node to be inserted\n             * @param {number} depth\n             *        Max depth of the QuadTree\n             */\n            QuadTreeNode.prototype.insert = function (point, depth) {\n                var newQuadTreeNode;\n                if (this.isInternal) {\n                    // Internal node:\n                    this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);\n                }\n                else {\n                    this.isEmpty = false;\n                    if (!this.body) {\n                        // First body in a quadrant:\n                        this.isInternal = false;\n                        this.body = point;\n                    }\n                    else {\n                        if (depth) {\n                            // Every other body in a quadrant:\n                            this.isInternal = true;\n                            this.divideBox();\n                            // Reinsert main body only once:\n                            if (this.body !== true) {\n                                this.nodes[this.getBoxPosition(this.body)]\n                                    .insert(this.body, depth - 1);\n                                this.body = true;\n                            }\n                            // Add second body:\n                            this.nodes[this.getBoxPosition(point)]\n                                .insert(point, depth - 1);\n                        }\n                        else {\n                            // We are below max allowed depth. That means either:\n                            // - really huge number of points\n                            // - falling two points into exactly the same position\n                            // In this case, create another node in the QuadTree.\n                            //\n                            // Alternatively we could add some noise to the\n                            // position, but that could result in different\n                            // rendered chart in exporting.\n                            newQuadTreeNode = new QuadTreeNode({\n                                top: point.plotX || NaN,\n                                left: point.plotY || NaN,\n                                // Width/height below 1px\n                                width: 0.1,\n                                height: 0.1\n                            });\n                            newQuadTreeNode.body = point;\n                            newQuadTreeNode.isInternal = false;\n                            this.nodes.push(newQuadTreeNode);\n                        }\n                    }\n                }\n            };\n            /**\n             * Each quad node requires it's mass and center position. That mass and\n             * position is used to imitate real node in the layout by approximation.\n             */\n            QuadTreeNode.prototype.updateMassAndCenter = function () {\n                var mass = 0,\n                    plotX = 0,\n                    plotY = 0;\n                if (this.isInternal) {\n                    // Calcualte weightened mass of the quad node:\n                    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n                        var pointMass = _a[_i];\n                        if (!pointMass.isEmpty) {\n                            mass += pointMass.mass;\n                            plotX += pointMass.plotX * pointMass.mass;\n                            plotY += pointMass.plotY * pointMass.mass;\n                        }\n                    }\n                    plotX /= mass;\n                    plotY /= mass;\n                }\n                else if (this.body) {\n                    // Just one node, use coordinates directly:\n                    mass = this.body.mass;\n                    plotX = this.body.plotX;\n                    plotY = this.body.plotY;\n                }\n                // Store details:\n                this.mass = mass;\n                this.plotX = plotX;\n                this.plotY = plotY;\n            };\n            return QuadTreeNode;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return QuadTreeNode;\n    });\n    _registerModule(_modules, 'Series/Networkgraph/QuadTree.js', [_modules['Series/Networkgraph/QuadTreeNode.js']], function (QuadTreeNode) {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The QuadTree class. Used in Networkgraph chart as a base for Barnes-Hut\n         * approximation.\n         *\n         * @private\n         * @class\n         * @name Highcharts.QuadTree\n         *\n         * @param {number} x\n         *        Left position of the plotting area\n         * @param {number} y\n         *        Top position of the plotting area\n         * @param {number} width\n         *        Width of the plotting area\n         * @param {number} height\n         *        Height of the plotting area\n         */\n        var QuadTree = /** @class */ (function () {\n                /* *\n                 *\n                 *  Constructor\n                 *\n                 * */\n                function QuadTree(x, y, width, height) {\n                    // Boundary rectangle:\n                    this.box = {\n                        left: x,\n                        top: y,\n                        width: width,\n                        height: height\n                    };\n                this.maxDepth = 25;\n                this.root = new QuadTreeNode(this.box);\n                this.root.isInternal = true;\n                this.root.isRoot = true;\n                this.root.divideBox();\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Calculate mass of the each QuadNode in the tree.\n             */\n            QuadTree.prototype.calculateMassAndCenter = function () {\n                this.visitNodeRecursive(null, null, function (node) {\n                    node.updateMassAndCenter();\n                });\n            };\n            /**\n             * Insert nodes into the QuadTree\n             *\n             * @param {Array<Highcharts.Point>} points\n             *        Points as nodes\n             */\n            QuadTree.prototype.insertNodes = function (points) {\n                for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n                    var point = points_1[_i];\n                    this.root.insert(point, this.maxDepth);\n                }\n            };\n            /**\n             * Depfth first treversal (DFS). Using `before` and `after` callbacks,\n             * we can get two results: preorder and postorder traversals, reminder:\n             *\n             * ```\n             *     (a)\n             *     / \\\n             *   (b) (c)\n             *   / \\\n             * (d) (e)\n             * ```\n             *\n             * DFS (preorder): `a -> b -> d -> e -> c`\n             *\n             * DFS (postorder): `d -> e -> b -> c -> a`\n             *\n             * @param {Highcharts.QuadTreeNode|null} node\n             *        QuadTree node\n             * @param {Function} [beforeCallback]\n             *        Function to be called before visiting children nodes.\n             * @param {Function} [afterCallback]\n             *        Function to be called after visiting children nodes.\n             */\n            QuadTree.prototype.visitNodeRecursive = function (node, beforeCallback, afterCallback) {\n                var goFurther;\n                if (!node) {\n                    node = this.root;\n                }\n                if (node === this.root && beforeCallback) {\n                    goFurther = beforeCallback(node);\n                }\n                if (goFurther === false) {\n                    return;\n                }\n                for (var _i = 0, _a = node.nodes; _i < _a.length; _i++) {\n                    var qtNode = _a[_i];\n                    if (qtNode.isInternal) {\n                        if (beforeCallback) {\n                            goFurther = beforeCallback(qtNode);\n                        }\n                        if (goFurther === false) {\n                            continue;\n                        }\n                        this.visitNodeRecursive(qtNode, beforeCallback, afterCallback);\n                    }\n                    else if (qtNode.body) {\n                        if (beforeCallback) {\n                            beforeCallback(qtNode.body);\n                        }\n                    }\n                    if (afterCallback) {\n                        afterCallback(qtNode);\n                    }\n                }\n                if (node === this.root && afterCallback) {\n                    afterCallback(node);\n                }\n            };\n            return QuadTree;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return QuadTree;\n    });\n    _registerModule(_modules, 'Series/Networkgraph/ReingoldFruchtermanLayout.js', [_modules['Series/Networkgraph/EulerIntegration.js'], _modules['Core/Globals.js'], _modules['Series/GraphLayoutComposition.js'], _modules['Series/Networkgraph/QuadTree.js'], _modules['Core/Utilities.js'], _modules['Series/Networkgraph/VerletIntegration.js']], function (EulerIntegration, H, GraphLayout, QuadTree, U, VerletIntegration) {\n        /* *\n         *\n         *  Networkgraph series\n         *\n         *  (c) 2010-2021 Pawe Fus\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var win = H.win;\n        var clamp = U.clamp,\n            defined = U.defined,\n            isFunction = U.isFunction,\n            pick = U.pick;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Reingold-Fruchterman algorithm from\n         * \"Graph Drawing by Force-directed Placement\" paper.\n         * @private\n         */\n        var ReingoldFruchtermanLayout = /** @class */ (function () {\n                function ReingoldFruchtermanLayout() {\n                    /* *\n                     *\n                     *  Static Functions\n                     *\n                     * */\n                    this.attractiveForce = void 0;\n                this.box = {};\n                this.currentStep = 0;\n                this.initialRendering = true;\n                this.integration = void 0;\n                this.links = [];\n                this.nodes = [];\n                this.options = void 0;\n                this.quadTree = void 0;\n                this.repulsiveForce = void 0;\n                this.series = [];\n                this.simulation = false;\n            }\n            ReingoldFruchtermanLayout.compose = function (ChartClass) {\n                GraphLayout.compose(ChartClass);\n                GraphLayout.integrations.euler = EulerIntegration;\n                GraphLayout.integrations.verlet = VerletIntegration;\n                GraphLayout.layouts['reingold-fruchterman'] =\n                    ReingoldFruchtermanLayout;\n            };\n            ReingoldFruchtermanLayout.prototype.init = function (options) {\n                this.options = options;\n                this.nodes = [];\n                this.links = [];\n                this.series = [];\n                this.box = {\n                    x: 0,\n                    y: 0,\n                    width: 0,\n                    height: 0\n                };\n                this.setInitialRendering(true);\n                this.integration =\n                    GraphLayout.integrations[options.integration];\n                this.enableSimulation = options.enableSimulation;\n                this.attractiveForce = pick(options.attractiveForce, this.integration.attractiveForceFunction);\n                this.repulsiveForce = pick(options.repulsiveForce, this.integration.repulsiveForceFunction);\n                this.approximation = options.approximation;\n            };\n            ReingoldFruchtermanLayout.prototype.updateSimulation = function (enable) {\n                this.enableSimulation = pick(enable, this.options.enableSimulation);\n            };\n            ReingoldFruchtermanLayout.prototype.start = function () {\n                var layout = this,\n                    series = this.series,\n                    options = this.options;\n                layout.currentStep = 0;\n                layout.forces = series[0] && series[0].forces || [];\n                layout.chart = series[0] && series[0].chart;\n                if (layout.initialRendering) {\n                    layout.initPositions();\n                    // Render elements in initial positions:\n                    series.forEach(function (s) {\n                        s.finishedAnimating = true; // #13169\n                        s.render();\n                    });\n                }\n                layout.setK();\n                layout.resetSimulation(options);\n                if (layout.enableSimulation) {\n                    layout.step();\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.step = function () {\n                var _this = this;\n                var anyLayout = this,\n                    allSeries = this.series;\n                // Algorithm:\n                this.currentStep++;\n                if (this.approximation === 'barnes-hut') {\n                    this.createQuadTree();\n                    this.quadTree.calculateMassAndCenter();\n                }\n                for (var _i = 0, _a = this.forces || []; _i < _a.length; _i++) {\n                    var forceName = _a[_i];\n                    anyLayout[forceName + 'Forces'](this.temperature);\n                }\n                // Limit to the plotting area and cool down:\n                this.applyLimits();\n                // Cool down the system:\n                this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep);\n                this.prevSystemTemperature = this.systemTemperature;\n                this.systemTemperature = this.getSystemTemperature();\n                if (this.enableSimulation) {\n                    for (var _b = 0, allSeries_1 = allSeries; _b < allSeries_1.length; _b++) {\n                        var series = allSeries_1[_b];\n                        // Chart could be destroyed during the simulation\n                        if (series.chart) {\n                            series.render();\n                        }\n                    }\n                    if (this.maxIterations-- &&\n                        isFinite(this.temperature) &&\n                        !this.isStable()) {\n                        if (this.simulation) {\n                            win.cancelAnimationFrame(this.simulation);\n                        }\n                        this.simulation = win.requestAnimationFrame(function () { return _this.step(); });\n                    }\n                    else {\n                        this.simulation = false;\n                    }\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.stop = function () {\n                if (this.simulation) {\n                    win.cancelAnimationFrame(this.simulation);\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.setArea = function (x, y, w, h) {\n                this.box = {\n                    left: x,\n                    top: y,\n                    width: w,\n                    height: h\n                };\n            };\n            ReingoldFruchtermanLayout.prototype.setK = function () {\n                // Optimal distance between nodes,\n                // available space around the node:\n                this.k = this.options.linkLength || this.integration.getK(this);\n            };\n            ReingoldFruchtermanLayout.prototype.addElementsToCollection = function (elements, collection) {\n                for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\n                    var element = elements_1[_i];\n                    if (collection.indexOf(element) === -1) {\n                        collection.push(element);\n                    }\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.removeElementFromCollection = function (element, collection) {\n                var index = collection.indexOf(element);\n                if (index !== -1) {\n                    collection.splice(index, 1);\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.clear = function () {\n                this.nodes.length = 0;\n                this.links.length = 0;\n                this.series.length = 0;\n                this.resetSimulation();\n            };\n            ReingoldFruchtermanLayout.prototype.resetSimulation = function () {\n                this.forcedStop = false;\n                this.systemTemperature = 0;\n                this.setMaxIterations();\n                this.setTemperature();\n                this.setDiffTemperature();\n            };\n            ReingoldFruchtermanLayout.prototype.restartSimulation = function () {\n                if (!this.simulation) {\n                    // When dragging nodes, we don't need to calculate\n                    // initial positions and rendering nodes:\n                    this.setInitialRendering(false);\n                    // Start new simulation:\n                    if (!this.enableSimulation) {\n                        // Run only one iteration to speed things up:\n                        this.setMaxIterations(1);\n                    }\n                    else {\n                        this.start();\n                    }\n                    if (this.chart) {\n                        this.chart.redraw();\n                    }\n                    // Restore defaults:\n                    this.setInitialRendering(true);\n                }\n                else {\n                    // Extend current simulation:\n                    this.resetSimulation();\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.setMaxIterations = function (maxIterations) {\n                this.maxIterations = pick(maxIterations, this.options.maxIterations);\n            };\n            ReingoldFruchtermanLayout.prototype.setTemperature = function () {\n                this.temperature = this.startTemperature =\n                    Math.sqrt(this.nodes.length);\n            };\n            ReingoldFruchtermanLayout.prototype.setDiffTemperature = function () {\n                this.diffTemperature = this.startTemperature /\n                    (this.options.maxIterations + 1);\n            };\n            ReingoldFruchtermanLayout.prototype.setInitialRendering = function (enable) {\n                this.initialRendering = enable;\n            };\n            ReingoldFruchtermanLayout.prototype.createQuadTree = function () {\n                this.quadTree = new QuadTree(this.box.left, this.box.top, this.box.width, this.box.height);\n                this.quadTree.insertNodes(this.nodes);\n            };\n            ReingoldFruchtermanLayout.prototype.initPositions = function () {\n                var initialPositions = this.options.initialPositions;\n                if (isFunction(initialPositions)) {\n                    initialPositions.call(this);\n                    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n                        var node = _a[_i];\n                        if (!defined(node.prevX)) {\n                            node.prevX = node.plotX;\n                        }\n                        if (!defined(node.prevY)) {\n                            node.prevY = node.plotY;\n                        }\n                        node.dispX = 0;\n                        node.dispY = 0;\n                    }\n                }\n                else if (initialPositions === 'circle') {\n                    this.setCircularPositions();\n                }\n                else {\n                    this.setRandomPositions();\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.setCircularPositions = function () {\n                var box = this.box,\n                    nodes = this.nodes,\n                    nodesLength = nodes.length + 1,\n                    angle = 2 * Math.PI / nodesLength,\n                    rootNodes = nodes.filter(function (node) {\n                        return node.linksTo.length === 0;\n                }), visitedNodes = {}, radius = this.options.initialPositionRadius, addToNodes = function (node) {\n                    for (var _i = 0, _a = node.linksFrom || []; _i < _a.length; _i++) {\n                        var link = _a[_i];\n                        if (!visitedNodes[link.toNode.id]) {\n                            visitedNodes[link.toNode.id] = true;\n                            sortedNodes.push(link.toNode);\n                            addToNodes(link.toNode);\n                        }\n                    }\n                };\n                var sortedNodes = [];\n                // Start with identified root nodes an sort the nodes by their\n                // hierarchy. In trees, this ensures that branches don't cross\n                // eachother.\n                for (var _i = 0, rootNodes_1 = rootNodes; _i < rootNodes_1.length; _i++) {\n                    var rootNode = rootNodes_1[_i];\n                    sortedNodes.push(rootNode);\n                    addToNodes(rootNode);\n                }\n                // Cyclic tree, no root node found\n                if (!sortedNodes.length) {\n                    sortedNodes = nodes;\n                    // Dangling, cyclic trees\n                }\n                else {\n                    for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {\n                        var node_1 = nodes_1[_a];\n                        if (sortedNodes.indexOf(node_1) === -1) {\n                            sortedNodes.push(node_1);\n                        }\n                    }\n                }\n                var node;\n                // Initial positions are laid out along a small circle, appearing\n                // as a cluster in the middle\n                for (var i = 0, iEnd = sortedNodes.length; i < iEnd; ++i) {\n                    node = sortedNodes[i];\n                    node.plotX = node.prevX = pick(node.plotX, box.width / 2 + radius * Math.cos(i * angle));\n                    node.plotY = node.prevY = pick(node.plotY, box.height / 2 + radius * Math.sin(i * angle));\n                    node.dispX = 0;\n                    node.dispY = 0;\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.setRandomPositions = function () {\n                var box = this.box,\n                    nodes = this.nodes,\n                    nodesLength = nodes.length + 1, \n                    /**\n                     * Return a repeatable,\n                    quasi-random number based on an integer\n                     * input. For the initial positions\n                     * @private\n                     */\n                    unrandom = function (n) {\n                        var rand = n * n / Math.PI;\n                    rand = rand - Math.floor(rand);\n                    return rand;\n                };\n                var node;\n                // Initial positions:\n                for (var i = 0, iEnd = nodes.length; i < iEnd; ++i) {\n                    node = nodes[i];\n                    node.plotX = node.prevX = pick(node.plotX, box.width * unrandom(i));\n                    node.plotY = node.prevY = pick(node.plotY, box.height * unrandom(nodesLength + i));\n                    node.dispX = 0;\n                    node.dispY = 0;\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.force = function (name) {\n                var args = [];\n                for (var _i = 1; _i < arguments.length; _i++) {\n                    args[_i - 1] = arguments[_i];\n                }\n                this.integration[name].apply(this, args);\n            };\n            ReingoldFruchtermanLayout.prototype.barycenterForces = function () {\n                this.getBarycenter();\n                this.force('barycenter');\n            };\n            ReingoldFruchtermanLayout.prototype.getBarycenter = function () {\n                var systemMass = 0,\n                    cx = 0,\n                    cy = 0;\n                for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n                    var node = _a[_i];\n                    cx += node.plotX * node.mass;\n                    cy += node.plotY * node.mass;\n                    systemMass += node.mass;\n                }\n                this.barycenter = {\n                    x: cx,\n                    y: cy,\n                    xFactor: cx / systemMass,\n                    yFactor: cy / systemMass\n                };\n                return this.barycenter;\n            };\n            ReingoldFruchtermanLayout.prototype.barnesHutApproximation = function (node, quadNode) {\n                var distanceXY = this.getDistXY(node,\n                    quadNode),\n                    distanceR = this.vectorLength(distanceXY);\n                var goDeeper,\n                    force;\n                if (node !== quadNode && distanceR !== 0) {\n                    if (quadNode.isInternal) {\n                        // Internal node:\n                        if (quadNode.boxSize / distanceR <\n                            this.options.theta &&\n                            distanceR !== 0) {\n                            // Treat as an external node:\n                            force = this.repulsiveForce(distanceR, this.k);\n                            this.force('repulsive', node, force * quadNode.mass, distanceXY, distanceR);\n                            goDeeper = false;\n                        }\n                        else {\n                            // Go deeper:\n                            goDeeper = true;\n                        }\n                    }\n                    else {\n                        // External node, direct force:\n                        force = this.repulsiveForce(distanceR, this.k);\n                        this.force('repulsive', node, force * quadNode.mass, distanceXY, distanceR);\n                    }\n                }\n                return goDeeper;\n            };\n            ReingoldFruchtermanLayout.prototype.repulsiveForces = function () {\n                var _this = this;\n                if (this.approximation === 'barnes-hut') {\n                    var _loop_1 = function (node) {\n                            this_1.quadTree.visitNodeRecursive(null,\n                        function (quadNode) { return (_this.barnesHutApproximation(node,\n                        quadNode)); });\n                    };\n                    var this_1 = this;\n                    for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n                        var node = _a[_i];\n                        _loop_1(node);\n                    }\n                }\n                else {\n                    var force = void 0,\n                        distanceR = void 0,\n                        distanceXY = void 0;\n                    for (var _b = 0, _c = this.nodes; _b < _c.length; _b++) {\n                        var node = _c[_b];\n                        for (var _d = 0, _e = this.nodes; _d < _e.length; _d++) {\n                            var repNode = _e[_d];\n                            if (\n                            // Node cannot repulse itself:\n                            node !== repNode &&\n                                // Only close nodes affect each other:\n                                // layout.getDistR(node, repNode) < 2 * k &&\n                                // Not dragged:\n                                !node.fixedPosition) {\n                                distanceXY = this.getDistXY(node, repNode);\n                                distanceR = this.vectorLength(distanceXY);\n                                if (distanceR !== 0) {\n                                    force = this.repulsiveForce(distanceR, this.k);\n                                    this.force('repulsive', node, force * repNode.mass, distanceXY, distanceR);\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.attractiveForces = function () {\n                var distanceXY,\n                    distanceR,\n                    force;\n                for (var _i = 0, _a = this.links; _i < _a.length; _i++) {\n                    var link = _a[_i];\n                    if (link.fromNode && link.toNode) {\n                        distanceXY = this.getDistXY(link.fromNode, link.toNode);\n                        distanceR = this.vectorLength(distanceXY);\n                        if (distanceR !== 0) {\n                            force = this.attractiveForce(distanceR, this.k);\n                            this.force('attractive', link, force, distanceXY, distanceR);\n                        }\n                    }\n                }\n            };\n            ReingoldFruchtermanLayout.prototype.applyLimits = function () {\n                var nodes = this.nodes;\n                for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {\n                    var node = nodes_2[_i];\n                    if (node.fixedPosition) {\n                        return;\n                    }\n                    this.integration.integrate(this, node);\n                    this.applyLimitBox(node, this.box);\n                    // Reset displacement:\n                    node.dispX = 0;\n                    node.dispY = 0;\n                }\n            };\n            /**\n             * External box that nodes should fall. When hitting an edge, node\n             * should stop or bounce.\n             * @private\n             */\n            ReingoldFruchtermanLayout.prototype.applyLimitBox = function (node, box) {\n                var radius = node.radius;\n                /*\n                TO DO: Consider elastic collision instead of stopping.\n                o' means end position when hitting plotting area edge:\n\n                - \"inelastic\":\n                o\n                    \\\n                ______\n                |  o'\n                |   \\\n                |    \\\n\n                - \"elastic\"/\"bounced\":\n                o\n                    \\\n                ______\n                |  ^\n                | / \\\n                |o'  \\\n\n                Euler sample:\n                if (plotX < 0) {\n                    plotX = 0;\n                    dispX *= -1;\n                }\n\n                if (plotX > box.width) {\n                    plotX = box.width;\n                    dispX *= -1;\n                }\n\n                */\n                // Limit X-coordinates:\n                node.plotX = clamp(node.plotX, box.left + radius, box.width - radius);\n                // Limit Y-coordinates:\n                node.plotY = clamp(node.plotY, box.top + radius, box.height - radius);\n            };\n            /**\n             * From \"A comparison of simulated annealing cooling strategies\" by\n             * Nourani and Andresen work.\n             * @private\n             */\n            ReingoldFruchtermanLayout.prototype.coolDown = function (temperature, temperatureStep, currentStep) {\n                // Logarithmic:\n                /*\n                return Math.sqrt(this.nodes.length) -\n                    Math.log(\n                        currentStep * layout.diffTemperature\n                    );\n                */\n                // Exponential:\n                /*\n                let alpha = 0.1;\n                layout.temperature = Math.sqrt(layout.nodes.length) *\n                    Math.pow(alpha, layout.diffTemperature);\n                */\n                // Linear:\n                return temperature - temperatureStep * currentStep;\n            };\n            ReingoldFruchtermanLayout.prototype.isStable = function () {\n                return Math.abs(this.systemTemperature -\n                    this.prevSystemTemperature) < 0.00001 || this.temperature <= 0;\n            };\n            ReingoldFruchtermanLayout.prototype.getSystemTemperature = function () {\n                var value = 0;\n                for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {\n                    var node = _a[_i];\n                    value += node.temperature;\n                }\n                return value;\n            };\n            ReingoldFruchtermanLayout.prototype.vectorLength = function (vector) {\n                return Math.sqrt(vector.x * vector.x + vector.y * vector.y);\n            };\n            ReingoldFruchtermanLayout.prototype.getDistR = function (nodeA, nodeB) {\n                var distance = this.getDistXY(nodeA,\n                    nodeB);\n                return this.vectorLength(distance);\n            };\n            ReingoldFruchtermanLayout.prototype.getDistXY = function (nodeA, nodeB) {\n                var xDist = nodeA.plotX - nodeB.plotX,\n                    yDist = nodeA.plotY - nodeB.plotY;\n                return {\n                    x: xDist,\n                    y: yDist,\n                    absX: Math.abs(xDist),\n                    absY: Math.abs(yDist)\n                };\n            };\n            return ReingoldFruchtermanLayout;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ReingoldFruchtermanLayout;\n    });\n    _registerModule(_modules, 'Series/PackedBubble/PackedBubbleLayout.js', [_modules['Series/GraphLayoutComposition.js'], _modules['Series/PackedBubble/PackedBubbleIntegration.js'], _modules['Series/Networkgraph/ReingoldFruchtermanLayout.js'], _modules['Core/Utilities.js']], function (GraphLayout, PackedBubbleIntegration, ReingoldFruchtermanLayout, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Grzegorz Blachlinski, Sebastian Bochan\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var addEvent = U.addEvent,\n            pick = U.pick;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedClasses = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function chartGetSelectedParentNodes() {\n            var allSeries = this.series,\n                selectedParentsNodes = [];\n            allSeries.forEach(function (series) {\n                if (series.parentNode && series.parentNode.selected) {\n                    selectedParentsNodes.push(series.parentNode);\n                }\n            });\n            return selectedParentsNodes;\n        }\n        /**\n         * Remove accumulated data points to redistribute all of them again\n         * (i.e after hiding series by legend)\n         * @private\n         */\n        function onChartBeforeRedraw() {\n            if (this.allDataPoints) {\n                delete this.allDataPoints;\n            }\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        var PackedBubbleLayout = /** @class */ (function (_super) {\n                __extends(PackedBubbleLayout, _super);\n            function PackedBubbleLayout() {\n                /* *\n                 *\n                 *  Static Functions\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.index = NaN;\n                _this.nodes = [];\n                _this.options = void 0;\n                _this.series = [];\n                return _this;\n            }\n            PackedBubbleLayout.compose = function (ChartClass) {\n                ReingoldFruchtermanLayout.compose(ChartClass);\n                GraphLayout.integrations.packedbubble = PackedBubbleIntegration;\n                GraphLayout.layouts.packedbubble = PackedBubbleLayout;\n                if (composedClasses.indexOf(ChartClass) === -1) {\n                    composedClasses.push(ChartClass);\n                    addEvent(ChartClass, 'beforeRedraw', onChartBeforeRedraw);\n                    var chartProto = ChartClass.prototype;\n                    chartProto.getSelectedParentNodes = chartGetSelectedParentNodes;\n                }\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            PackedBubbleLayout.prototype.beforeStep = function () {\n                if (this.options.marker) {\n                    this.series.forEach(function (series) {\n                        if (series) {\n                            series.calculateParentRadius();\n                        }\n                    });\n                }\n            };\n            // #14439, new stable check.\n            PackedBubbleLayout.prototype.isStable = function () {\n                var tempDiff = Math.abs(this.prevSystemTemperature -\n                        this.systemTemperature);\n                var upScaledTemperature = 10 * this.systemTemperature /\n                        Math.sqrt(this.nodes.length);\n                return Math.abs(upScaledTemperature) < 1 &&\n                    tempDiff < 0.00001 ||\n                    this.temperature <= 0;\n            };\n            PackedBubbleLayout.prototype.setCircularPositions = function () {\n                var layout = this,\n                    box = layout.box,\n                    nodes = layout.nodes,\n                    nodesLength = nodes.length + 1,\n                    angle = 2 * Math.PI / nodesLength,\n                    radius = layout.options.initialPositionRadius;\n                var centerX,\n                    centerY,\n                    index = 0;\n                for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n                    var node = nodes_1[_i];\n                    if (layout.options.splitSeries &&\n                        !node.isParentNode) {\n                        centerX = node.series.parentNode.plotX;\n                        centerY = node.series.parentNode.plotY;\n                    }\n                    else {\n                        centerX = box.width / 2;\n                        centerY = box.height / 2;\n                    }\n                    node.plotX = node.prevX = pick(node.plotX, centerX +\n                        radius * Math.cos(node.index || index * angle));\n                    node.plotY = node.prevY = pick(node.plotY, centerY +\n                        radius * Math.sin(node.index || index * angle));\n                    node.dispX = 0;\n                    node.dispY = 0;\n                    index++;\n                }\n            };\n            PackedBubbleLayout.prototype.repulsiveForces = function () {\n                var layout = this,\n                    bubblePadding = layout.options.bubblePadding;\n                var force,\n                    distanceR,\n                    distanceXY;\n                layout.nodes.forEach(function (node) {\n                    node.degree = node.mass;\n                    node.neighbours = 0;\n                    layout.nodes.forEach(function (repNode) {\n                        force = 0;\n                        if (\n                        // Node cannot repulse itself:\n                        node !== repNode &&\n                            // Only close nodes affect each other:\n                            // Not dragged:\n                            !node.fixedPosition &&\n                            (layout.options.seriesInteraction ||\n                                node.series === repNode.series)) {\n                            distanceXY = layout.getDistXY(node, repNode);\n                            distanceR = (layout.vectorLength(distanceXY) -\n                                (node.marker.radius +\n                                    repNode.marker.radius +\n                                    bubblePadding));\n                            // TODO padding configurable\n                            if (distanceR < 0) {\n                                node.degree += 0.01;\n                                node.neighbours++;\n                                force = layout.repulsiveForce(-distanceR / Math.sqrt(node.neighbours), layout.k, node, repNode);\n                            }\n                            layout.force('repulsive', node, force * repNode.mass, distanceXY, repNode, distanceR);\n                        }\n                    });\n                });\n            };\n            PackedBubbleLayout.prototype.applyLimitBox = function (node, box) {\n                var layout = this,\n                    factor = 0.01;\n                var distanceXY,\n                    distanceR;\n                // parentNodeLimit should be used together\n                // with seriesInteraction: false\n                if (layout.options.splitSeries &&\n                    !node.isParentNode &&\n                    layout.options.parentNodeLimit) {\n                    distanceXY = layout.getDistXY(node, node.series.parentNode);\n                    distanceR = (node.series.parentNodeRadius -\n                        node.marker.radius -\n                        layout.vectorLength(distanceXY));\n                    if (distanceR < 0 &&\n                        distanceR > -2 * node.marker.radius) {\n                        node.plotX -= distanceXY.x * factor;\n                        node.plotY -= distanceXY.y * factor;\n                    }\n                }\n                _super.prototype.applyLimitBox.call(this, node, box);\n            };\n            return PackedBubbleLayout;\n        }(ReingoldFruchtermanLayout));\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        GraphLayout.layouts.packedbubble = PackedBubbleLayout;\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return PackedBubbleLayout;\n    });\n    _registerModule(_modules, 'Series/PackedBubble/PackedBubbleSeries.js', [_modules['Core/Color/Color.js'], _modules['Series/DragNodesComposition.js'], _modules['Series/GraphLayoutComposition.js'], _modules['Core/Globals.js'], _modules['Series/PackedBubble/PackedBubblePoint.js'], _modules['Series/PackedBubble/PackedBubbleSeriesDefaults.js'], _modules['Series/PackedBubble/PackedBubbleLayout.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (Color, DragNodesComposition, GraphLayout, H, PackedBubblePoint, PackedBubbleSeriesDefaults, PackedBubbleLayout, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Grzegorz Blachlinski, Sebastian Bochan\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var color = Color.parse;\n        var noop = H.noop;\n        var seriesProto = SeriesRegistry.series.prototype,\n            BubbleSeries = SeriesRegistry.seriesTypes.bubble;\n        var addEvent = U.addEvent,\n            clamp = U.clamp,\n            defined = U.defined,\n            extend = U.extend,\n            fireEvent = U.fireEvent,\n            isArray = U.isArray,\n            isNumber = U.isNumber,\n            merge = U.merge,\n            pick = U.pick;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.packedbubble\n         *\n         * @extends Highcharts.Series\n         */\n        var PackedBubbleSeries = /** @class */ (function (_super) {\n                __extends(PackedBubbleSeries, _super);\n            function PackedBubbleSeries() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                _this.chart = void 0;\n                _this.data = void 0;\n                _this.layout = void 0;\n                _this.options = void 0;\n                _this.parentNodeMass = 0;\n                _this.points = void 0;\n                _this.xData = void 0;\n                return _this;\n                /* eslint-enable valid-jsdoc */\n            }\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            PackedBubbleSeries.compose = function (AxisClass, ChartClass, LegendClass, SeriesClass) {\n                BubbleSeries.compose(AxisClass, ChartClass, LegendClass, SeriesClass);\n                DragNodesComposition.compose(ChartClass);\n                PackedBubbleLayout.compose(ChartClass);\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * Create a single array of all points from all series\n             * @private\n             */\n            PackedBubbleSeries.prototype.accumulateAllPoints = function () {\n                var chart = this.chart,\n                    allDataPoints = [];\n                var yData;\n                for (var _i = 0, _a = chart.series; _i < _a.length; _i++) {\n                    var series = _a[_i];\n                    if (series.is('packedbubble') && // #13574\n                        series.visible ||\n                        !chart.options.chart.ignoreHiddenSeries) {\n                        yData = series.yData || [];\n                        // add data to array only if series is visible\n                        for (var j = 0; j < yData.length; j++) {\n                            allDataPoints.push([\n                                null, null,\n                                yData[j],\n                                series.index,\n                                j,\n                                {\n                                    id: j,\n                                    marker: {\n                                        radius: 0\n                                    }\n                                }\n                            ]);\n                        }\n                    }\n                }\n                return allDataPoints;\n            };\n            /**\n             * Adding the basic layout to series points.\n             * @private\n             */\n            PackedBubbleSeries.prototype.addLayout = function () {\n                var layoutOptions = this.options.layoutAlgorithm =\n                        this.options.layoutAlgorithm || {},\n                    layoutType = layoutOptions.type || 'packedbubble',\n                    chartOptions = this.chart.options.chart;\n                var graphLayoutsStorage = this.chart.graphLayoutsStorage,\n                    graphLayoutsLookup = this.chart.graphLayoutsLookup,\n                    layout;\n                if (!graphLayoutsStorage) {\n                    this.chart.graphLayoutsStorage = graphLayoutsStorage = {};\n                    this.chart.graphLayoutsLookup = graphLayoutsLookup = [];\n                }\n                layout = graphLayoutsStorage[layoutType];\n                if (!layout) {\n                    layoutOptions.enableSimulation =\n                        !defined(chartOptions.forExport) ?\n                            layoutOptions.enableSimulation :\n                            !chartOptions.forExport;\n                    graphLayoutsStorage[layoutType] = layout =\n                        new GraphLayout.layouts[layoutType]();\n                    layout.init(layoutOptions);\n                    graphLayoutsLookup.splice(layout.index, 0, layout);\n                }\n                this.layout = layout;\n                this.points.forEach(function (node) {\n                    node.mass = 2;\n                    node.degree = 1;\n                    node.collisionNmb = 1;\n                });\n                layout.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);\n                layout.addElementsToCollection([this], layout.series);\n                layout.addElementsToCollection(this.points, layout.nodes);\n            };\n            /**\n             * Function responsible for adding series layout, used for parent nodes.\n             * @private\n             */\n            PackedBubbleSeries.prototype.addSeriesLayout = function () {\n                var layoutOptions = this.options.layoutAlgorithm =\n                        this.options.layoutAlgorithm || {},\n                    layoutType = (layoutOptions.type || 'packedbubble'),\n                    graphLayoutsStorage = this.chart.graphLayoutsStorage,\n                    graphLayoutsLookup = this.chart.graphLayoutsLookup,\n                    parentNodeOptions = merge(layoutOptions,\n                    layoutOptions.parentNodeOptions, {\n                        enableSimulation: this.layout.options.enableSimulation\n                    });\n                var seriesLayout = graphLayoutsStorage[layoutType + '-series'];\n                if (!seriesLayout) {\n                    graphLayoutsStorage[layoutType + '-series'] = seriesLayout =\n                        new GraphLayout.layouts[layoutType]();\n                    seriesLayout.init(parentNodeOptions);\n                    graphLayoutsLookup.splice(seriesLayout.index, 0, seriesLayout);\n                }\n                this.parentNodeLayout = seriesLayout;\n                this.createParentNodes();\n            };\n            /**\n             * The function responsible for calculating the parent node radius\n             * based on the total surface of iniside-bubbles and the group BBox\n             * @private\n             */\n            PackedBubbleSeries.prototype.calculateParentRadius = function () {\n                var bBox = this.seriesBox(),\n                    parentPadding = 20,\n                    minParentRadius = 20;\n                this.parentNodeRadius = clamp(Math.sqrt(2 * this.parentNodeMass / Math.PI) + parentPadding, minParentRadius, bBox ?\n                    Math.max(Math.sqrt(Math.pow(bBox.width, 2) +\n                        Math.pow(bBox.height, 2)) / 2 + parentPadding, minParentRadius) :\n                    Math.sqrt(2 * this.parentNodeMass / Math.PI) + parentPadding);\n                if (this.parentNode) {\n                    this.parentNode.marker.radius =\n                        this.parentNode.radius = this.parentNodeRadius;\n                }\n            };\n            /**\n             * Calculate min and max bubble value for radius calculation.\n             * @private\n             */\n            PackedBubbleSeries.prototype.calculateZExtremes = function () {\n                var chart = this.chart,\n                    allSeries = chart.series;\n                var zMin = this.options.zMin,\n                    zMax = this.options.zMax,\n                    valMin = Infinity,\n                    valMax = -Infinity;\n                if (zMin && zMax) {\n                    return [zMin, zMax];\n                }\n                // it is needed to deal with null\n                // and undefined values\n                allSeries.forEach(function (series) {\n                    series.yData.forEach(function (y) {\n                        if (defined(y)) {\n                            if (y > valMax) {\n                                valMax = y;\n                            }\n                            if (y < valMin) {\n                                valMin = y;\n                            }\n                        }\n                    });\n                });\n                zMin = pick(zMin, valMin);\n                zMax = pick(zMax, valMax);\n                return [zMin, zMax];\n            };\n            /**\n             * Check if two bubbles overlaps.\n             * @private\n             */\n            PackedBubbleSeries.prototype.checkOverlap = function (bubble1, bubble2) {\n                var diffX = bubble1[0] - bubble2[0], // diff of X center values\n                    diffY = bubble1[1] - bubble2[1], // diff of Y center values\n                    sumRad = bubble1[2] + bubble2[2]; // sum of bubble radius\n                    return (Math.sqrt(diffX * diffX + diffY * diffY) -\n                        Math.abs(sumRad)) < -0.001;\n            };\n            /**\n             * Creating parent nodes for split series, in which all the bubbles\n             * are rendered.\n             * @private\n             */\n            PackedBubbleSeries.prototype.createParentNodes = function () {\n                var _this = this;\n                var PackedBubblePoint = this.pointClass,\n                    chart = this.chart,\n                    parentNodeLayout = this.parentNodeLayout,\n                    layoutOptions = this.layout.options;\n                var nodeAdded,\n                    parentNode = this.parentNode,\n                    parentMarkerOptions = {\n                        radius: this.parentNodeRadius,\n                        lineColor: this.color,\n                        fillColor: color(this.color).brighten(0.4).get()\n                    };\n                if (layoutOptions.parentNodeOptions) {\n                    parentMarkerOptions = merge(layoutOptions.parentNodeOptions.marker || {}, parentMarkerOptions);\n                }\n                this.parentNodeMass = 0;\n                this.points.forEach(function (p) {\n                    _this.parentNodeMass +=\n                        Math.PI * Math.pow(p.marker.radius, 2);\n                });\n                this.calculateParentRadius();\n                parentNodeLayout.nodes.forEach(function (node) {\n                    if (node.seriesIndex === _this.index) {\n                        nodeAdded = true;\n                    }\n                });\n                parentNodeLayout.setArea(0, 0, chart.plotWidth, chart.plotHeight);\n                if (!nodeAdded) {\n                    if (!parentNode) {\n                        parentNode = (new PackedBubblePoint()).init(this, {\n                            mass: this.parentNodeRadius / 2,\n                            marker: parentMarkerOptions,\n                            dataLabels: {\n                                inside: false\n                            },\n                            states: {\n                                normal: {\n                                    marker: parentMarkerOptions\n                                },\n                                hover: {\n                                    marker: parentMarkerOptions\n                                }\n                            },\n                            dataLabelOnNull: true,\n                            degree: this.parentNodeRadius,\n                            isParentNode: true,\n                            seriesIndex: this.index\n                        });\n                    }\n                    if (this.parentNode) {\n                        parentNode.plotX = this.parentNode.plotX;\n                        parentNode.plotY = this.parentNode.plotY;\n                    }\n                    this.parentNode = parentNode;\n                    parentNodeLayout.addElementsToCollection([this], parentNodeLayout.series);\n                    parentNodeLayout.addElementsToCollection([parentNode], parentNodeLayout.nodes);\n                }\n            };\n            /**\n             * Function responsible for adding all the layouts to the chart.\n             * @private\n             */\n            PackedBubbleSeries.prototype.deferLayout = function () {\n                // TODO split layouts to independent methods\n                var layoutOptions = this.options.layoutAlgorithm;\n                if (!this.visible) {\n                    return;\n                }\n                // layout is using nodes for position calculation\n                this.addLayout();\n                if (layoutOptions.splitSeries) {\n                    this.addSeriesLayout();\n                }\n            };\n            PackedBubbleSeries.prototype.destroy = function () {\n                var _this = this;\n                // Remove the series from all layouts series collections #11469\n                if (this.chart.graphLayoutsLookup) {\n                    this.chart.graphLayoutsLookup.forEach(function (layout) {\n                        layout.removeElementFromCollection(_this, layout.series);\n                    }, this);\n                }\n                if (this.parentNode &&\n                    this.parentNodeLayout) {\n                    this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes);\n                    if (this.parentNode.dataLabel) {\n                        this.parentNode.dataLabel =\n                            this.parentNode.dataLabel.destroy();\n                    }\n                }\n                seriesProto.destroy.apply(this, arguments);\n            };\n            /**\n             * Packedbubble has two separate collecions of nodes if split, render\n             * dataLabels for both sets:\n             * @private\n             */\n            PackedBubbleSeries.prototype.drawDataLabels = function () {\n                seriesProto.drawDataLabels.call(this, this.points);\n                // Render parentNode labels:\n                if (this.parentNode) {\n                    this.parentNode.formatPrefix = 'parentNode';\n                    seriesProto.drawDataLabels.call(this, [this.parentNode]);\n                }\n            };\n            /**\n             * Create Background/Parent Nodes for split series.\n             * @private\n             */\n            PackedBubbleSeries.prototype.drawGraph = function () {\n                // if the series is not using layout, don't add parent nodes\n                if (!this.layout || !this.layout.options.splitSeries) {\n                    return;\n                }\n                var chart = this.chart,\n                    nodeMarker = this.layout.options.parentNodeOptions.marker,\n                    parentOptions = {\n                        fill: (nodeMarker.fillColor ||\n                            color(this.color).brighten(0.4).get()),\n                        opacity: nodeMarker.fillOpacity,\n                        stroke: nodeMarker.lineColor || this.color,\n                        'stroke-width': pick(nodeMarker.lineWidth,\n                    this.options.lineWidth)\n                    };\n                var parentAttribs = {};\n                // create the group for parent Nodes if doesn't exist\n                if (!this.parentNodesGroup) {\n                    this.parentNodesGroup = this.plotGroup('parentNodesGroup', 'parentNode', this.visible ? 'inherit' : 'hidden', 0.1, chart.seriesGroup);\n                    this.group.attr({\n                        zIndex: 2\n                    });\n                }\n                this.calculateParentRadius();\n                parentAttribs = merge({\n                    x: this.parentNode.plotX -\n                        this.parentNodeRadius,\n                    y: this.parentNode.plotY -\n                        this.parentNodeRadius,\n                    width: this.parentNodeRadius * 2,\n                    height: this.parentNodeRadius * 2\n                }, parentOptions);\n                if (!this.parentNode.graphic) {\n                    this.graph = this.parentNode.graphic =\n                        chart.renderer.symbol(parentOptions.symbol)\n                            .add(this.parentNodesGroup);\n                }\n                this.parentNode.graphic.attr(parentAttribs);\n            };\n            PackedBubbleSeries.prototype.drawTracker = function () {\n                var parentNode = this.parentNode;\n                // chart = series.chart,\n                // pointer = chart.pointer,\n                // onMouseOver = function (e: PointerEvent): void {\n                //     const point = pointer.getPointFromEvent(e);\n                //     // undefined on graph in scatterchart\n                //     if (typeof point !== 'undefined') {\n                //         pointer.isDirectTouch = true;\n                //         point.onMouseOver(e);\n                //     }\n                // };\n                var dataLabels;\n                _super.prototype.drawTracker.call(this);\n                // Add reference to the point\n                if (parentNode) {\n                    dataLabels = (isArray(parentNode.dataLabels) ?\n                        parentNode.dataLabels :\n                        (parentNode.dataLabel ? [parentNode.dataLabel] : []));\n                    if (parentNode.graphic) {\n                        parentNode.graphic.element.point = parentNode;\n                    }\n                    dataLabels.forEach(function (dataLabel) {\n                        if (dataLabel.div) {\n                            dataLabel.div.point = parentNode;\n                        }\n                        else {\n                            dataLabel.element.point = parentNode;\n                        }\n                    });\n                }\n            };\n            /**\n             * Calculate radius of bubbles in series.\n             * @private\n             */\n            PackedBubbleSeries.prototype.getPointRadius = function () {\n                var _this = this;\n                var chart = this.chart,\n                    plotWidth = chart.plotWidth,\n                    plotHeight = chart.plotHeight,\n                    seriesOptions = this.options,\n                    useSimulation = seriesOptions.useSimulation,\n                    smallestSize = Math.min(plotWidth,\n                    plotHeight),\n                    extremes = {},\n                    radii = [],\n                    allDataPoints = chart.allDataPoints || [],\n                    allDataPointsLength = allDataPoints.length;\n                var minSize,\n                    maxSize,\n                    value,\n                    radius;\n                ['minSize', 'maxSize'].forEach(function (prop) {\n                    var length = parseInt(seriesOptions[prop], 10),\n                        isPercent = /%$/.test(seriesOptions[prop]);\n                    extremes[prop] = isPercent ?\n                        smallestSize * length / 100 :\n                        length * Math.sqrt(allDataPointsLength);\n                });\n                chart.minRadius = minSize = extremes.minSize /\n                    Math.sqrt(allDataPointsLength);\n                chart.maxRadius = maxSize = extremes.maxSize /\n                    Math.sqrt(allDataPointsLength);\n                var zExtremes = useSimulation ?\n                        this.calculateZExtremes() :\n                        [minSize,\n                    maxSize];\n                allDataPoints.forEach(function (point, i) {\n                    value = useSimulation ?\n                        clamp(point[2], zExtremes[0], zExtremes[1]) :\n                        point[2];\n                    radius = _this.getRadius(zExtremes[0], zExtremes[1], minSize, maxSize, value);\n                    if (radius === 0) {\n                        radius = null;\n                    }\n                    allDataPoints[i][2] = radius;\n                    radii.push(radius);\n                });\n                this.radii = radii;\n            };\n            PackedBubbleSeries.prototype.init = function () {\n                seriesProto.init.apply(this, arguments);\n                /* eslint-disable no-invalid-this */\n                // When one series is modified, the others need to be recomputed\n                this.eventsToUnbind.push(addEvent(this, 'updatedData', function () {\n                    var _this = this;\n                    this.chart.series.forEach(function (s) {\n                        if (s.type === _this.type) {\n                            s.isDirty = true;\n                        }\n                    }, this);\n                }));\n                /* eslint-enable no-invalid-this */\n                return this;\n            };\n            /**\n             * Mouse up action, finalizing drag&drop.\n             * @private\n             * @param {Highcharts.Point} point The point that event occured.\n             */\n            PackedBubbleSeries.prototype.onMouseUp = function (dnPoint) {\n                var point = dnPoint;\n                if (point.fixedPosition && !point.removed) {\n                    var layout_1 = this.layout,\n                        parentNodeLayout = this.parentNodeLayout;\n                    var distanceXY_1,\n                        distanceR_1;\n                    if (parentNodeLayout && layout_1.options.dragBetweenSeries) {\n                        parentNodeLayout.nodes.forEach(function (node) {\n                            if (point && point.marker &&\n                                node !== point.series.parentNode) {\n                                distanceXY_1 = layout_1.getDistXY(point, node);\n                                distanceR_1 = (layout_1.vectorLength(distanceXY_1) -\n                                    node.marker.radius -\n                                    point.marker.radius);\n                                if (distanceR_1 < 0) {\n                                    node.series.addPoint(merge(point.options, {\n                                        plotX: point.plotX,\n                                        plotY: point.plotY\n                                    }), false);\n                                    layout_1.removeElementFromCollection(point, layout_1.nodes);\n                                    point.remove();\n                                }\n                            }\n                        });\n                    }\n                    DragNodesComposition.onMouseUp.apply(this, arguments);\n                }\n            };\n            /**\n             * This is the main function responsible\n             * for positioning all of the bubbles\n             * allDataPoints - bubble array, in format [pixel x value,\n             * pixel y value, radius,\n             * related series index, related point index]\n             * @private\n             * @param {Array<Highcharts.PackedBubbleData>} allDataPoints All points from all series\n             * @return {Array<Highcharts.PackedBubbleData>} Positions of all bubbles\n             */\n            PackedBubbleSeries.prototype.placeBubbles = function (allDataPoints) {\n                var checkOverlap = this.checkOverlap,\n                    positionBubble = this.positionBubble,\n                    bubblePos = [];\n                var stage = 1,\n                    j = 0,\n                    k = 0,\n                    calculatedBubble,\n                    arr = [],\n                    i;\n                // sort all points\n                var sortedArr = allDataPoints.sort(function (a,\n                    b) {\n                        return b[2] - a[2];\n                });\n                if (sortedArr.length) {\n                    // create first bubble in the middle of the chart\n                    bubblePos.push([\n                        [\n                            0,\n                            0,\n                            sortedArr[0][2],\n                            sortedArr[0][3],\n                            sortedArr[0][4]\n                        ] // point index\n                    ]); // 0 level bubble\n                    if (sortedArr.length > 1) {\n                        bubblePos.push([\n                            [\n                                0,\n                                (0 - sortedArr[1][2] -\n                                    sortedArr[0][2]),\n                                // move bubble above first one\n                                sortedArr[1][2],\n                                sortedArr[1][3],\n                                sortedArr[1][4]\n                            ]\n                        ]); // 1 level 1st bubble\n                        // first two already positioned so starting from 2\n                        for (i = 2; i < sortedArr.length; i++) {\n                            sortedArr[i][2] = sortedArr[i][2] || 1;\n                            // in case if radius is calculated as 0.\n                            calculatedBubble = positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]); // calculate initial bubble position\n                            if (checkOverlap(calculatedBubble, bubblePos[stage][0])) {\n                                /* if new bubble is overlapping with first bubble\n                                    * in current level (stage)\n                                    */\n                                bubblePos.push([]);\n                                k = 0;\n                                /* reset index of bubble, used for\n                                    * positioning the bubbles around it,\n                                    * we are starting from first bubble in next\n                                    * stage because we are changing level to higher\n                                    */\n                                bubblePos[stage + 1].push(positionBubble(bubblePos[stage][j], bubblePos[stage][0], sortedArr[i]));\n                                // (last bubble, 1. from curr stage, new bubble)\n                                stage++; // the new level is created, above current\n                                j = 0; // set the index of bubble in curr level to 0\n                            }\n                            else if (stage > 1 &&\n                                bubblePos[stage - 1][k + 1] &&\n                                checkOverlap(calculatedBubble, bubblePos[stage - 1][k + 1])) {\n                                /* if new bubble is overlapping with one of the prev\n                                    * stage bubbles, it means that - bubble, used for\n                                    * positioning the bubbles around it has changed\n                                    * so we need to recalculate it\n                                    */\n                                k++;\n                                bubblePos[stage].push(positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]));\n                                // (last bubble, prev stage bubble, new bubble)\n                                j++;\n                            }\n                            else { // simply add calculated bubble\n                                j++;\n                                bubblePos[stage].push(calculatedBubble);\n                            }\n                        }\n                    }\n                    this.chart.stages = bubblePos;\n                    // it may not be necessary but adding it just in case -\n                    // it is containing all of the bubble levels\n                    this.chart.rawPositions =\n                        []\n                            .concat.apply([], bubblePos);\n                    // bubble positions merged into one array\n                    this.resizeRadius();\n                    arr = this.chart.rawPositions;\n                }\n                return arr;\n            };\n            /**\n             * Function that checks for a parentMarker and sets the correct opacity.\n             * @private\n             * @param {Highcharts.Pack} point\n             * Candidate point for opacity correction.\n             * @param {string} [state]\n             * The point state, can be either `hover`, `select` or 'normal'. If\n             * undefined, normal state is assumed.\n             *\n             * @return {Highcharts.SVGAttributes}\n             * The presentational attributes to be set on the point.\n             */\n            PackedBubbleSeries.prototype.pointAttribs = function (point, state) {\n                var options = this.options,\n                    hasParentMarker = point && point.isParentNode;\n                var markerOptions = options.marker;\n                if (hasParentMarker &&\n                    options.layoutAlgorithm &&\n                    options.layoutAlgorithm.parentNodeOptions) {\n                    markerOptions = options.layoutAlgorithm.parentNodeOptions.marker;\n                }\n                var fillOpacity = markerOptions.fillOpacity,\n                    attr = seriesProto.pointAttribs.call(this,\n                    point,\n                    state);\n                if (fillOpacity !== 1) {\n                    attr['fill-opacity'] = fillOpacity;\n                }\n                return attr;\n            };\n            /**\n             * Function that is adding one bubble based on positions and sizes of\n             * two other bubbles, lastBubble is the last added bubble, newOrigin is\n             * the bubble for positioning new bubbles. nextBubble is the curently\n             * added bubble for which we are calculating positions\n             * @private\n             * @param {Array<number>} lastBubble The closest last bubble\n             * @param {Array<number>} newOrigin New bubble\n             * @param {Array<number>} nextBubble The closest next bubble\n             * @return {Array<number>} Bubble with correct positions\n             */\n            PackedBubbleSeries.prototype.positionBubble = function (lastBubble, newOrigin, nextBubble) {\n                var sqrt = Math.sqrt,\n                    asin = Math.asin,\n                    acos = Math.acos,\n                    pow = Math.pow,\n                    abs = Math.abs,\n                    distance = sqrt(// dist between lastBubble and newOrigin\n                    pow((lastBubble[0] - newOrigin[0]), 2) +\n                        pow((lastBubble[1] - newOrigin[1]), 2)),\n                    alfa = acos(\n                    // from cosinus theorem: alfa is an angle used for\n                    // calculating correct position\n                    (pow(distance, 2) +\n                        pow(nextBubble[2] + newOrigin[2], 2) -\n                        pow(nextBubble[2] + lastBubble[2], 2)) / (2 * (nextBubble[2] + newOrigin[2]) * distance)),\n                    beta = asin(// from sinus theorem.\n                    abs(lastBubble[0] - newOrigin[0]) /\n                        distance), \n                    // providing helping variables, related to angle between\n                    // lastBubble and newOrigin\n                    gamma = (lastBubble[1] - newOrigin[1]) < 0 ? 0 : Math.PI, \n                    // if new origin y is smaller than last bubble y value\n                    // (2 and 3 quarter),\n                    // add Math.PI to final angle\n                    delta = (lastBubble[0] - newOrigin[0]) *\n                        (lastBubble[1] - newOrigin[1]) < 0 ?\n                        1 : -1, // (1st and 3rd quarter)\n                    finalAngle = gamma + alfa + beta * delta,\n                    cosA = Math.cos(finalAngle),\n                    sinA = Math.sin(finalAngle),\n                    posX = newOrigin[0] + (newOrigin[2] + nextBubble[2]) * sinA, \n                    // center of new origin + (radius1 + radius2) * sinus A\n                    posY = newOrigin[1] - (newOrigin[2] + nextBubble[2]) * cosA;\n                return [\n                    posX,\n                    posY,\n                    nextBubble[2],\n                    nextBubble[3],\n                    nextBubble[4]\n                ]; // the same as described before\n            };\n            PackedBubbleSeries.prototype.render = function () {\n                var dataLabels = [];\n                seriesProto.render.apply(this, arguments);\n                // #10823 - dataLabels should stay visible\n                // when enabled allowOverlap.\n                if (!this.options.dataLabels.allowOverlap) {\n                    this.data.forEach(function (point) {\n                        if (isArray(point.dataLabels)) {\n                            point.dataLabels.forEach(function (dataLabel) {\n                                dataLabels.push(dataLabel);\n                            });\n                        }\n                    });\n                    // Only hide overlapping dataLabels for layouts that\n                    // use simulation. Spiral packedbubble don't need\n                    // additional dataLabel hiding on every simulation step\n                    if (this.options.useSimulation) {\n                        this.chart.hideOverlappingLabels(dataLabels);\n                    }\n                }\n            };\n            /**\n             * The function responsible for resizing the bubble radius.\n             * In shortcut: it is taking the initially\n             * calculated positions of bubbles. Then it is calculating the min max\n             * of both dimensions, creating something in shape of bBox.\n             * The comparison of bBox and the size of plotArea\n             * (later it may be also the size set by customer) is giving the\n             * value how to recalculate the radius so it will match the size\n             * @private\n             */\n            PackedBubbleSeries.prototype.resizeRadius = function () {\n                var chart = this.chart,\n                    positions = chart.rawPositions,\n                    min = Math.min,\n                    max = Math.max,\n                    plotLeft = chart.plotLeft,\n                    plotTop = chart.plotTop,\n                    chartHeight = chart.plotHeight,\n                    chartWidth = chart.plotWidth;\n                var minX,\n                    maxX,\n                    minY,\n                    maxY,\n                    radius;\n                minX = minY = Number.POSITIVE_INFINITY; // set initial values\n                maxX = maxY = Number.NEGATIVE_INFINITY;\n                for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\n                    var position = positions_1[_i];\n                    radius = position[2];\n                    minX = min(minX, position[0] - radius);\n                    // (x center-radius) is the min x value used by specific bubble\n                    maxX = max(maxX, position[0] + radius);\n                    minY = min(minY, position[1] - radius);\n                    maxY = max(maxY, position[1] + radius);\n                }\n                var bBox = [maxX - minX,\n                    maxY - minY],\n                    spaceRatio = [\n                        (chartWidth - plotLeft) / bBox[0],\n                        (chartHeight - plotTop) / bBox[1]\n                    ],\n                    smallerDimension = min.apply([],\n                    spaceRatio);\n                if (Math.abs(smallerDimension - 1) > 1e-10) {\n                    // if bBox is considered not the same width as possible size\n                    for (var _a = 0, positions_2 = positions; _a < positions_2.length; _a++) {\n                        var position = positions_2[_a];\n                        position[2] *= smallerDimension;\n                    }\n                    this.placeBubbles(positions);\n                }\n                else {\n                    /** if no radius recalculation is needed, we need to position\n                     * the whole bubbles in center of chart plotarea\n                     * for this, we are adding two parameters,\n                     * diffY and diffX, that are related to differences\n                     * between the initial center and the bounding box\n                     */\n                    chart.diffY = chartHeight / 2 +\n                        plotTop - minY - (maxY - minY) / 2;\n                    chart.diffX = chartWidth / 2 +\n                        plotLeft - minX - (maxX - minX) / 2;\n                }\n            };\n            /**\n             * The function responsible for calculating series bubble' s bBox.\n             * Needed because of exporting failure when useSimulation\n             * is set to false\n             * @private\n             */\n            PackedBubbleSeries.prototype.seriesBox = function () {\n                var chart = this.chart,\n                    data = this.data,\n                    max = Math.max,\n                    min = Math.min, \n                    // bBox = [xMin, xMax, yMin, yMax]\n                    bBox = [\n                        chart.plotLeft,\n                        chart.plotLeft + chart.plotWidth,\n                        chart.plotTop,\n                        chart.plotTop + chart.plotHeight\n                    ];\n                var radius;\n                data.forEach(function (p) {\n                    if (defined(p.plotX) &&\n                        defined(p.plotY) &&\n                        p.marker.radius) {\n                        radius = p.marker.radius;\n                        bBox[0] = min(bBox[0], p.plotX - radius);\n                        bBox[1] = max(bBox[1], p.plotX + radius);\n                        bBox[2] = min(bBox[2], p.plotY - radius);\n                        bBox[3] = max(bBox[3], p.plotY + radius);\n                    }\n                });\n                return isNumber(bBox.width / bBox.height) ?\n                    bBox :\n                    null;\n            };\n            /**\n             * Needed because of z-indexing issue if point is added in series.group\n             * @private\n             */\n            PackedBubbleSeries.prototype.setVisible = function () {\n                var series = this;\n                seriesProto.setVisible.apply(series, arguments);\n                if (series.parentNodeLayout && series.graph) {\n                    if (series.visible) {\n                        series.graph.show();\n                        if (series.parentNode.dataLabel) {\n                            series.parentNode.dataLabel.show();\n                        }\n                    }\n                    else {\n                        series.graph.hide();\n                        series.parentNodeLayout\n                            .removeElementFromCollection(series.parentNode, series.parentNodeLayout.nodes);\n                        if (series.parentNode.dataLabel) {\n                            series.parentNode.dataLabel.hide();\n                        }\n                    }\n                }\n                else if (series.layout) {\n                    if (series.visible) {\n                        series.layout.addElementsToCollection(series.points, series.layout.nodes);\n                    }\n                    else {\n                        series.points.forEach(function (node) {\n                            series.layout.removeElementFromCollection(node, series.layout.nodes);\n                        });\n                    }\n                }\n            };\n            /**\n             * Extend the base translate method to handle bubble size,\n             * and correct positioning them.\n             * @private\n             */\n            PackedBubbleSeries.prototype.translate = function () {\n                var chart = this.chart,\n                    data = this.data,\n                    index = this.index,\n                    useSimulation = this.options.useSimulation;\n                var point,\n                    radius,\n                    positions;\n                this.processedXData = this.xData;\n                this.generatePoints();\n                // merged data is an array with all of the data from all series\n                if (!defined(chart.allDataPoints)) {\n                    chart.allDataPoints = this.accumulateAllPoints();\n                    // calculate radius for all added data\n                    this.getPointRadius();\n                }\n                // after getting initial radius, calculate bubble positions\n                if (useSimulation) {\n                    positions = chart.allDataPoints;\n                }\n                else {\n                    positions = this.placeBubbles(chart.allDataPoints);\n                    this.options.draggable = false;\n                }\n                // Set the shape and arguments to be picked up in drawPoints\n                for (var _i = 0, positions_3 = positions; _i < positions_3.length; _i++) {\n                    var position = positions_3[_i];\n                    if (position[3] === index) {\n                        // update the series points with the val from positions\n                        // array\n                        point = data[position[4]];\n                        radius = pick(position[2], void 0);\n                        if (!useSimulation) {\n                            point.plotX = (position[0] - chart.plotLeft +\n                                chart.diffX);\n                            point.plotY = (position[1] - chart.plotTop +\n                                chart.diffY);\n                        }\n                        if (isNumber(radius)) {\n                            point.marker = extend(point.marker, {\n                                radius: radius,\n                                width: 2 * radius,\n                                height: 2 * radius\n                            });\n                            point.radius = radius;\n                        }\n                    }\n                }\n                if (useSimulation) {\n                    this.deferLayout();\n                }\n                fireEvent(this, 'afterTranslate');\n            };\n            PackedBubbleSeries.defaultOptions = merge(BubbleSeries.defaultOptions, PackedBubbleSeriesDefaults);\n            return PackedBubbleSeries;\n        }(BubbleSeries));\n        extend(PackedBubbleSeries.prototype, {\n            pointClass: PackedBubblePoint,\n            axisTypes: [],\n            directTouch: true,\n            forces: ['barycenter', 'repulsive'],\n            hasDraggableNodes: true,\n            isCartesian: false,\n            noSharedTooltip: true,\n            pointArrayMap: ['value'],\n            pointValKey: 'value',\n            requireSorting: false,\n            trackerGroups: ['group', 'dataLabelsGroup', 'parentNodesGroup'],\n            alignDataLabel: seriesProto.alignDataLabel,\n            indexateNodes: noop,\n            onMouseDown: DragNodesComposition.onMouseDown,\n            onMouseMove: DragNodesComposition.onMouseMove,\n            redrawHalo: DragNodesComposition.redrawHalo,\n            searchPoint: noop // solving #12287\n        });\n        SeriesRegistry.registerSeriesType('packedbubble', PackedBubbleSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * Formatter callback function.\n         *\n         * @callback Highcharts.SeriesPackedBubbleDataLabelsFormatterCallbackFunction\n         *\n         * @param {Highcharts.SeriesPackedBubbleDataLabelsFormatterContextObject} this\n         *        Data label context to format\n         *\n         * @return {string}\n         *         Formatted data label text\n         */\n        /**\n         * Context for the formatter function.\n         *\n         * @interface Highcharts.SeriesPackedBubbleDataLabelsFormatterContextObject\n         * @extends Highcharts.PointLabelObject\n         * @since 7.0.0\n         */ /**\n        * The color of the node.\n        * @name Highcharts.SeriesPackedBubbleDataLabelsFormatterContextObject#color\n        * @type {Highcharts.ColorString}\n        * @since 7.0.0\n        */ /**\n        * The point (node) object. The node name, if defined, is available through\n        * `this.point.name`. Arrays: `this.point.linksFrom` and `this.point.linksTo`\n        * contains all nodes connected to this point.\n        * @name Highcharts.SeriesPackedBubbleDataLabelsFormatterContextObject#point\n        * @type {Highcharts.Point}\n        * @since 7.0.0\n        */ /**\n        * The ID of the node.\n        * @name Highcharts.SeriesPackedBubbleDataLabelsFormatterContextObject#key\n        * @type {string}\n        * @since 7.0.0\n        */\n        ''; // detach doclets above\n\n        return PackedBubbleSeries;\n    });\n    _registerModule(_modules, 'Series/Polygon/PolygonSeries.js', [_modules['Core/Globals.js'], _modules['Core/Legend/LegendSymbol.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js']], function (H, LegendSymbol, SeriesRegistry, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var noop = H.noop;\n        var Series = SeriesRegistry.series,\n            _a = SeriesRegistry.seriesTypes,\n            AreaSeries = _a.area,\n            LineSeries = _a.line,\n            ScatterSeries = _a.scatter;\n        var extend = U.extend,\n            merge = U.merge;\n        /* *\n         *\n         * Class\n         *\n         * */\n        var PolygonSeries = /** @class */ (function (_super) {\n                __extends(PolygonSeries, _super);\n            function PolygonSeries() {\n                /* *\n                 *\n                 * Static properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                return _this;\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            PolygonSeries.prototype.getGraphPath = function () {\n                var graphPath = LineSeries.prototype.getGraphPath.call(this),\n                    i = graphPath.length + 1;\n                // Close all segments\n                while (i--) {\n                    if ((i === graphPath.length || graphPath[i][0] === 'M') && i > 0) {\n                        graphPath.splice(i, 0, ['Z']);\n                    }\n                }\n                this.areaPath = graphPath;\n                return graphPath;\n            };\n            PolygonSeries.prototype.drawGraph = function () {\n                // Hack into the fill logic in area.drawGraph\n                this.options.fillColor = this.color;\n                AreaSeries.prototype.drawGraph.call(this);\n            };\n            /**\n             * A polygon series can be used to draw any freeform shape in the cartesian\n             * coordinate system. A fill is applied with the `color` option, and\n             * stroke is applied through `lineWidth` and `lineColor` options.\n             *\n             * @sample {highcharts} highcharts/demo/polygon/\n             *         Polygon\n             * @sample {highstock} highcharts/demo/polygon/\n             *         Polygon\n             *\n             * @extends      plotOptions.scatter\n             * @since        4.1.0\n             * @excluding    jitter, softThreshold, threshold, cluster, boostThreshold,\n             *               boostBlending\n             * @product      highcharts highstock\n             * @requires     highcharts-more\n             * @optionparent plotOptions.polygon\n             */\n            PolygonSeries.defaultOptions = merge(ScatterSeries.defaultOptions, {\n                marker: {\n                    enabled: false,\n                    states: {\n                        hover: {\n                            enabled: false\n                        }\n                    }\n                },\n                stickyTracking: false,\n                tooltip: {\n                    followPointer: true,\n                    pointFormat: ''\n                },\n                trackByArea: true\n            });\n            return PolygonSeries;\n        }(ScatterSeries));\n        extend(PolygonSeries.prototype, {\n            type: 'polygon',\n            drawLegendSymbol: LegendSymbol.drawRectangle,\n            drawTracker: Series.prototype.drawTracker,\n            setStackedPoints: noop // No stacking points on polygons (#5310)\n        });\n        SeriesRegistry.registerSeriesType('polygon', PolygonSeries);\n        /* *\n         *\n         * Export\n         *\n         * */\n        /* *\n         *\n         * API Options\n         *\n         * */\n        /**\n         * A `polygon` series. If the [type](#series.polygon.type) option is\n         * not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.polygon\n         * @excluding dataParser, dataURL, stack, boostThreshold, boostBlending\n         * @product   highcharts highstock\n         * @requires  highcharts-more\n         * @apioption series.polygon\n         */\n        /**\n         * An array of data points for the series. For the `polygon` series\n         * type, points can be given in the following ways:\n         *\n         * 1. An array of numerical values. In this case, the numerical values will be\n         *    interpreted as `y` options. The `x` values will be automatically\n         *    calculated, either starting at 0 and incremented by 1, or from\n         *    `pointStart` and `pointInterval` given in the series options. If the axis\n         *    has categories, these will be used. Example:\n         *    ```js\n         *    data: [0, 5, 3, 5]\n         *    ```\n         *\n         * 2. An array of arrays with 2 values. In this case, the values correspond to\n         *    `x,y`. If the first value is a string, it is applied as the name of the\n         *    point, and the `x` value is inferred.\n         *    ```js\n         *    data: [\n         *        [0, 10],\n         *        [1, 3],\n         *        [2, 1]\n         *    ]\n         *    ```\n         *\n         * 3. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.polygon.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        y: 1,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        y: 8,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         Numerical values\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n         * @extends   series.line.data\n         * @product   highcharts highstock\n         * @apioption series.polygon.data\n         */\n        ''; // adds doclets above to transpiled file\n\n        return PolygonSeries;\n    });\n    _registerModule(_modules, 'Core/Axis/WaterfallAxis.js', [_modules['Core/Axis/Stacking/StackItem.js'], _modules['Core/Utilities.js']], function (StackItem, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var addEvent = U.addEvent,\n            objectEach = U.objectEach;\n        /**\n         * @private\n         */\n        var WaterfallAxis;\n        (function (WaterfallAxis) {\n            /* *\n             *\n             *  Interfaces\n             *\n             * */\n            /* *\n             *\n             *  Classes\n             *\n             * */\n            /**\n             * @private\n             */\n            var Composition = /** @class */ (function () {\n                    /* eslint-disable no-invalid-this, valid-jsdoc */\n                    /* *\n                     *\n                     *  Constructors\n                     *\n                     * */\n                    /**\n                     * @private\n                     */\n                    function Composition(axis) {\n                        this.axis = axis;\n                    this.stacks = {\n                        changed: false\n                    };\n                }\n                /* *\n                 *\n                 *  Functions\n                 *\n                 * */\n                /**\n                 * Calls StackItem.prototype.render function that creates and renders\n                 * stack total label for each waterfall stack item.\n                 *\n                 * @private\n                 * @function Highcharts.Axis#renderWaterfallStackTotals\n                 */\n                Composition.prototype.renderStackTotals = function () {\n                    var yAxis = this.axis,\n                        waterfallStacks = yAxis.waterfall.stacks,\n                        stackTotalGroup = (yAxis.stacking && yAxis.stacking.stackTotalGroup),\n                        dummyStackItem = new StackItem(yAxis,\n                        yAxis.options.stackLabels || {},\n                        false, 0,\n                        void 0);\n                    this.dummyStackItem = dummyStackItem;\n                    // Render each waterfall stack total\n                    if (stackTotalGroup) {\n                        objectEach(waterfallStacks, function (type) {\n                            objectEach(type, function (stackItem, key) {\n                                dummyStackItem.total = stackItem.stackTotal;\n                                dummyStackItem.x = +key;\n                                if (stackItem.label) {\n                                    dummyStackItem.label = stackItem.label;\n                                }\n                                StackItem.prototype.render.call(dummyStackItem, stackTotalGroup);\n                                stackItem.label = dummyStackItem.label;\n                                delete dummyStackItem.label;\n                            });\n                        });\n                    }\n                    dummyStackItem.total = null;\n                };\n                return Composition;\n            }());\n            WaterfallAxis.Composition = Composition;\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable no-invalid-this, valid-jsdoc */\n            /**\n             * @private\n             */\n            function compose(AxisClass, ChartClass) {\n                addEvent(AxisClass, 'init', onInit);\n                addEvent(AxisClass, 'afterBuildStacks', onAfterBuildStacks);\n                addEvent(AxisClass, 'afterRender', onAfterRender);\n                addEvent(ChartClass, 'beforeRedraw', onBeforeRedraw);\n            }\n            WaterfallAxis.compose = compose;\n            /**\n             * @private\n             */\n            function onAfterBuildStacks() {\n                var axis = this;\n                var stacks = axis.waterfall.stacks;\n                if (stacks) {\n                    stacks.changed = false;\n                    delete stacks.alreadyChanged;\n                }\n            }\n            /**\n             * @private\n             */\n            function onAfterRender() {\n                var axis = this;\n                var stackLabelOptions = axis.options.stackLabels;\n                if (stackLabelOptions && stackLabelOptions.enabled &&\n                    axis.waterfall.stacks) {\n                    axis.waterfall.renderStackTotals();\n                }\n            }\n            /**\n             * @private\n             */\n            function onBeforeRedraw() {\n                var axes = this.axes,\n                    series = this.series,\n                    i = series.length;\n                while (i--) {\n                    if (series[i].options.stacking) {\n                        axes.forEach(function (axis) {\n                            if (!axis.isXAxis) {\n                                axis.waterfall.stacks.changed = true;\n                            }\n                        });\n                        i = 0;\n                    }\n                }\n            }\n            /**\n             * @private\n             */\n            function onInit() {\n                var axis = this;\n                if (!axis.waterfall) {\n                    axis.waterfall = new Composition(axis);\n                }\n            }\n        })(WaterfallAxis || (WaterfallAxis = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WaterfallAxis;\n    });\n    _registerModule(_modules, 'Series/Waterfall/WaterfallPoint.js', [_modules['Series/Column/ColumnSeries.js'], _modules['Core/Series/Point.js'], _modules['Core/Utilities.js']], function (ColumnSeries, Point, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var isNumber = U.isNumber;\n        /* *\n         *\n         * Class\n         *\n         * */\n        var WaterfallPoint = /** @class */ (function (_super) {\n                __extends(WaterfallPoint, _super);\n            function WaterfallPoint() {\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                _this.options = void 0;\n                _this.series = void 0;\n                return _this;\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            WaterfallPoint.prototype.getClassName = function () {\n                var className = Point.prototype.getClassName.call(this);\n                if (this.isSum) {\n                    className += ' highcharts-sum';\n                }\n                else if (this.isIntermediateSum) {\n                    className += ' highcharts-intermediate-sum';\n                }\n                return className;\n            };\n            // Pass the null test in ColumnSeries.translate.\n            WaterfallPoint.prototype.isValid = function () {\n                return (isNumber(this.y) ||\n                    this.isSum ||\n                    Boolean(this.isIntermediateSum));\n            };\n            return WaterfallPoint;\n        }(ColumnSeries.prototype.pointClass));\n        /* *\n         *\n         * Export\n         *\n         * */\n\n        return WaterfallPoint;\n    });\n    _registerModule(_modules, 'Series/Waterfall/WaterfallSeries.js', [_modules['Core/Axis/Axis.js'], _modules['Core/Chart/Chart.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Core/Axis/WaterfallAxis.js'], _modules['Series/Waterfall/WaterfallPoint.js']], function (Axis, Chart, SeriesRegistry, U, WaterfallAxis, WaterfallPoint) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d,\n            b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d,\n            b) { d.__proto__ = b; }) ||\n                        function (d,\n            b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n                return extendStatics(d, b);\n            };\n            return function (d, b) {\n                extendStatics(d, b);\n                function __() { this.constructor = d; }\n                d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n            };\n        })();\n        var _a = SeriesRegistry.seriesTypes,\n            ColumnSeries = _a.column,\n            LineSeries = _a.line;\n        var arrayMax = U.arrayMax,\n            arrayMin = U.arrayMin,\n            correctFloat = U.correctFloat,\n            extend = U.extend,\n            isNumber = U.isNumber,\n            merge = U.merge,\n            objectEach = U.objectEach,\n            pick = U.pick;\n        /**\n         * Returns true if the key is a direct property of the object.\n         * @private\n         * @param {*} obj\n         * Object with property to test\n         * @param {string} key\n         * Property key to test\n         * @return {boolean}\n         * Whether it is a direct property\n         */\n        function ownProp(obj, key) {\n            return Object.hasOwnProperty.call(obj, key);\n        }\n        /* eslint-disable no-invalid-this, valid-jsdoc */\n        // eslint-disable-next-line valid-jsdoc\n        /**\n         * Waterfall series type.\n         *\n         * @private\n         */\n        var WaterfallSeries = /** @class */ (function (_super) {\n                __extends(WaterfallSeries, _super);\n            function WaterfallSeries() {\n                /* *\n                 *\n                 * Static properties\n                 *\n                 * */\n                var _this = _super !== null && _super.apply(this,\n                    arguments) || this;\n                /* *\n                 *\n                 * Properties\n                 *\n                 * */\n                _this.chart = void 0;\n                _this.data = void 0;\n                _this.options = void 0;\n                _this.points = void 0;\n                _this.stackedYNeg = void 0;\n                _this.stackedYPos = void 0;\n                _this.stackKey = void 0;\n                _this.xData = void 0;\n                _this.yAxis = void 0;\n                _this.yData = void 0;\n                return _this;\n            }\n            /* *\n             *\n             * Functions\n             *\n             * */\n            // After generating points, set y-values for all sums.\n            WaterfallSeries.prototype.generatePoints = function () {\n                // Parent call:\n                ColumnSeries.prototype.generatePoints.apply(this);\n                for (var i = 0, len = this.points.length; i < len; i++) {\n                    var point = this.points[i],\n                        y = this.processedYData[i];\n                    // Override point value for sums. #3710 Update point does not\n                    // propagate to sum\n                    if (isNumber(y) && (point.isIntermediateSum || point.isSum)) {\n                        point.y = correctFloat(y);\n                    }\n                }\n            };\n            // Translate data points from raw values\n            WaterfallSeries.prototype.translate = function () {\n                var series = this,\n                    options = series.options,\n                    yAxis = series.yAxis,\n                    minPointLength = pick(options.minPointLength, 5),\n                    halfMinPointLength = minPointLength / 2,\n                    threshold = options.threshold || 0,\n                    stacking = options.stacking,\n                    actualStack = yAxis.waterfall.stacks[series.stackKey];\n                var previousIntermediate = threshold,\n                    previousY = threshold,\n                    y,\n                    total,\n                    yPos,\n                    hPos;\n                // run column series translate\n                ColumnSeries.prototype.translate.apply(series);\n                var points = series.points;\n                for (var i = 0; i < points.length; i++) {\n                    var point = points[i],\n                        yValue = series.processedYData[i],\n                        shapeArgs = point.shapeArgs;\n                    if (!shapeArgs || !isNumber(yValue)) {\n                        continue;\n                    }\n                    var range = [0,\n                        yValue],\n                        pointY = point.y;\n                    // code responsible for correct positions of stacked points\n                    // starts here\n                    if (stacking) {\n                        if (actualStack) {\n                            var actualStackX = actualStack[i];\n                            if (stacking === 'overlap') {\n                                total =\n                                    actualStackX.stackState[actualStackX.stateIndex--];\n                                y = pointY >= 0 ? total : total - pointY;\n                                if (ownProp(actualStackX, 'absolutePos')) {\n                                    delete actualStackX.absolutePos;\n                                }\n                                if (ownProp(actualStackX, 'absoluteNeg')) {\n                                    delete actualStackX.absoluteNeg;\n                                }\n                            }\n                            else {\n                                if (pointY >= 0) {\n                                    total = actualStackX.threshold +\n                                        actualStackX.posTotal;\n                                    actualStackX.posTotal -= pointY;\n                                    y = total;\n                                }\n                                else {\n                                    total = actualStackX.threshold +\n                                        actualStackX.negTotal;\n                                    actualStackX.negTotal -= pointY;\n                                    y = total - pointY;\n                                }\n                                if (!actualStackX.posTotal) {\n                                    if (isNumber(actualStackX.absolutePos) &&\n                                        ownProp(actualStackX, 'absolutePos')) {\n                                        actualStackX.posTotal =\n                                            actualStackX.absolutePos;\n                                        delete actualStackX.absolutePos;\n                                    }\n                                }\n                                if (!actualStackX.negTotal) {\n                                    if (isNumber(actualStackX.absoluteNeg) &&\n                                        ownProp(actualStackX, 'absoluteNeg')) {\n                                        actualStackX.negTotal =\n                                            actualStackX.absoluteNeg;\n                                        delete actualStackX.absoluteNeg;\n                                    }\n                                }\n                            }\n                            if (!point.isSum) {\n                                // the connectorThreshold property is later used in\n                                // getCrispPath function to draw a connector line in a\n                                // correct place\n                                actualStackX.connectorThreshold =\n                                    actualStackX.threshold + actualStackX.stackTotal;\n                            }\n                            if (yAxis.reversed) {\n                                yPos = (pointY >= 0) ? (y - pointY) : (y + pointY);\n                                hPos = y;\n                            }\n                            else {\n                                yPos = y;\n                                hPos = y - pointY;\n                            }\n                            point.below = yPos <= threshold;\n                            shapeArgs.y = yAxis.translate(yPos, false, true, false, true);\n                            shapeArgs.height = Math.abs(shapeArgs.y -\n                                yAxis.translate(hPos, false, true, false, true));\n                            var dummyStackItem = yAxis.waterfall.dummyStackItem;\n                            if (dummyStackItem) {\n                                dummyStackItem.x = i;\n                                dummyStackItem.label = actualStack[i].label;\n                                dummyStackItem.setOffset(series.pointXOffset || 0, series.barW || 0, series.stackedYNeg[i], series.stackedYPos[i], void 0, this.xAxis);\n                            }\n                        }\n                    }\n                    else {\n                        // up points\n                        y = Math.max(previousY, previousY + pointY) + range[0];\n                        shapeArgs.y = yAxis.translate(y, false, true, false, true);\n                        // sum points\n                        if (point.isSum) {\n                            shapeArgs.y = yAxis.translate(range[1], false, true, false, true);\n                            shapeArgs.height = Math.min(yAxis.translate(range[0], false, true, false, true), yAxis.len) - shapeArgs.y; // #4256\n                            point.below = range[1] <= threshold;\n                        }\n                        else if (point.isIntermediateSum) {\n                            if (pointY >= 0) {\n                                yPos = range[1] + previousIntermediate;\n                                hPos = previousIntermediate;\n                            }\n                            else {\n                                yPos = previousIntermediate;\n                                hPos = range[1] + previousIntermediate;\n                            }\n                            if (yAxis.reversed) {\n                                // swapping values\n                                yPos ^= hPos;\n                                hPos ^= yPos;\n                                yPos ^= hPos;\n                            }\n                            shapeArgs.y = yAxis.translate(yPos, false, true, false, true);\n                            shapeArgs.height = Math.abs(shapeArgs.y -\n                                Math.min(yAxis.translate(hPos, false, true, false, true), yAxis.len));\n                            previousIntermediate += range[1];\n                            point.below = yPos <= threshold;\n                            // If it's not the sum point, update previous stack end position\n                            // and get shape height (#3886)\n                        }\n                        else {\n                            shapeArgs.height = yValue > 0 ?\n                                yAxis.translate(previousY, false, true, false, true) - shapeArgs.y :\n                                yAxis.translate(previousY, false, true, false, true) - yAxis.translate(previousY - yValue, false, true, false, true);\n                            previousY += yValue;\n                            point.below = previousY < threshold;\n                        }\n                        // #3952 Negative sum or intermediate sum not rendered correctly\n                        if (shapeArgs.height < 0) {\n                            shapeArgs.y += shapeArgs.height;\n                            shapeArgs.height *= -1;\n                        }\n                    }\n                    point.plotY = shapeArgs.y =\n                        Math.round(shapeArgs.y || 0) - (series.borderWidth % 2) / 2;\n                    // #3151\n                    shapeArgs.height =\n                        Math.max(Math.round(shapeArgs.height || 0), 0.001);\n                    point.yBottom = shapeArgs.y + shapeArgs.height;\n                    if (shapeArgs.height <= minPointLength && !point.isNull) {\n                        shapeArgs.height = minPointLength;\n                        shapeArgs.y -= halfMinPointLength;\n                        point.plotY = shapeArgs.y;\n                        if (point.y < 0) {\n                            point.minPointLengthOffset = -halfMinPointLength;\n                        }\n                        else {\n                            point.minPointLengthOffset = halfMinPointLength;\n                        }\n                    }\n                    else {\n                        if (point.isNull) {\n                            shapeArgs.width = 0;\n                        }\n                        point.minPointLengthOffset = 0;\n                    }\n                    // Correct tooltip placement (#3014)\n                    var tooltipY = point.plotY + (point.negative ? shapeArgs.height : 0);\n                    if (point.below) { // #15334\n                        point.plotY += shapeArgs.height;\n                    }\n                    if (point.tooltipPos) {\n                        if (series.chart.inverted) {\n                            point.tooltipPos[0] = yAxis.len - tooltipY;\n                        }\n                        else {\n                            point.tooltipPos[1] = tooltipY;\n                        }\n                    }\n                    // Check point position after recalculation (#16788)\n                    point.isInside = this.isPointInside(point);\n                }\n            };\n            // Call default processData then override yData to reflect waterfall's\n            // extremes on yAxis\n            WaterfallSeries.prototype.processData = function (force) {\n                var series = this,\n                    options = series.options,\n                    yData = series.yData, \n                    // #3710 Update point does not propagate to sum\n                    points = options.data,\n                    point,\n                    dataLength = yData.length,\n                    threshold = options.threshold || 0,\n                    subSum,\n                    sum,\n                    dataMin,\n                    dataMax,\n                    y,\n                    i;\n                sum = subSum = dataMin = dataMax = 0;\n                for (i = 0; i < dataLength; i++) {\n                    y = yData[i];\n                    point = points && points[i] ? points[i] : {};\n                    if (y === 'sum' || point.isSum) {\n                        yData[i] = correctFloat(sum);\n                    }\n                    else if (y === 'intermediateSum' ||\n                        point.isIntermediateSum) {\n                        yData[i] = correctFloat(subSum);\n                        subSum = 0;\n                    }\n                    else {\n                        sum += y;\n                        subSum += y;\n                    }\n                    dataMin = Math.min(sum, dataMin);\n                    dataMax = Math.max(sum, dataMax);\n                }\n                _super.prototype.processData.call(this, force);\n                // Record extremes only if stacking was not set:\n                if (!options.stacking) {\n                    series.dataMin = dataMin + threshold;\n                    series.dataMax = dataMax;\n                }\n                return;\n            };\n            // Return y value or string if point is sum\n            WaterfallSeries.prototype.toYData = function (pt) {\n                if (pt.isSum) {\n                    return 'sum';\n                }\n                if (pt.isIntermediateSum) {\n                    return 'intermediateSum';\n                }\n                return pt.y;\n            };\n            WaterfallSeries.prototype.updateParallelArrays = function (point, i) {\n                _super.prototype.updateParallelArrays.call(this, point, i);\n                // Prevent initial sums from triggering an error (#3245, #7559)\n                if (this.yData[0] === 'sum' || this.yData[0] === 'intermediateSum') {\n                    this.yData[0] = null;\n                }\n            };\n            // Postprocess mapping between options and SVG attributes\n            WaterfallSeries.prototype.pointAttribs = function (point, state) {\n                var upColor = this.options.upColor;\n                // Set or reset up color (#3710, update to negative)\n                if (upColor && !point.options.color) {\n                    point.color = point.y > 0 ? upColor : void 0;\n                }\n                var attr = ColumnSeries.prototype.pointAttribs.call(this,\n                    point,\n                    state);\n                // The dashStyle option in waterfall applies to the graph, not\n                // the points\n                delete attr.dashstyle;\n                return attr;\n            };\n            // Return an empty path initially, because we need to know the stroke-width\n            // in order to set the final path.\n            WaterfallSeries.prototype.getGraphPath = function () {\n                return [['M', 0, 0]];\n            };\n            // Draw columns' connector lines\n            WaterfallSeries.prototype.getCrispPath = function () {\n                var data = this.data,\n                    yAxis = this.yAxis,\n                    length = data.length,\n                    graphNormalizer = Math.round(this.graph.strokeWidth()) % 2 / 2,\n                    borderNormalizer = Math.round(this.borderWidth) % 2 / 2,\n                    reversedXAxis = this.xAxis.reversed,\n                    reversedYAxis = this.yAxis.reversed,\n                    stacking = this.options.stacking,\n                    path = [],\n                    connectorThreshold,\n                    prevStack,\n                    prevStackX,\n                    prevPoint,\n                    yPos,\n                    isPos,\n                    prevArgs,\n                    pointArgs,\n                    i;\n                for (i = 1; i < length; i++) {\n                    pointArgs = data[i].shapeArgs;\n                    prevPoint = data[i - 1];\n                    prevArgs = data[i - 1].shapeArgs;\n                    prevStack = yAxis.waterfall.stacks[this.stackKey];\n                    isPos = prevPoint.y > 0 ? -prevArgs.height : 0;\n                    if (prevStack && prevArgs && pointArgs) {\n                        prevStackX = prevStack[i - 1];\n                        // y position of the connector is different when series are\n                        // stacked, yAxis is reversed and it also depends on point's\n                        // value\n                        if (stacking) {\n                            connectorThreshold = prevStackX.connectorThreshold;\n                            yPos = Math.round((yAxis.translate(connectorThreshold, false, true, false, true) +\n                                (reversedYAxis ? isPos : 0))) - graphNormalizer;\n                        }\n                        else {\n                            yPos =\n                                prevArgs.y + prevPoint.minPointLengthOffset +\n                                    borderNormalizer - graphNormalizer;\n                        }\n                        path.push([\n                            'M',\n                            (prevArgs.x || 0) + (reversedXAxis ?\n                                0 :\n                                (prevArgs.width || 0)),\n                            yPos\n                        ], [\n                            'L',\n                            (pointArgs.x || 0) + (reversedXAxis ?\n                                (pointArgs.width || 0) :\n                                0),\n                            yPos\n                        ]);\n                    }\n                    if (prevArgs &&\n                        path.length &&\n                        ((!stacking && prevPoint.y < 0 && !reversedYAxis) ||\n                            (prevPoint.y > 0 && reversedYAxis))) {\n                        var nextLast = path[path.length - 2];\n                        if (nextLast && typeof nextLast[2] === 'number') {\n                            nextLast[2] += prevArgs.height || 0;\n                        }\n                        var last = path[path.length - 1];\n                        if (last && typeof last[2] === 'number') {\n                            last[2] += prevArgs.height || 0;\n                        }\n                    }\n                }\n                return path;\n            };\n            // The graph is initially drawn with an empty definition, then updated with\n            // crisp rendering.\n            WaterfallSeries.prototype.drawGraph = function () {\n                LineSeries.prototype.drawGraph.call(this);\n                if (this.graph) {\n                    this.graph.attr({\n                        d: this.getCrispPath()\n                    });\n                }\n            };\n            // Waterfall has stacking along the x-values too.\n            WaterfallSeries.prototype.setStackedPoints = function () {\n                var series = this,\n                    options = series.options,\n                    waterfallStacks = series.yAxis.waterfall.stacks,\n                    seriesThreshold = options.threshold || 0,\n                    stackThreshold = seriesThreshold,\n                    interSum = stackThreshold,\n                    stackKey = series.stackKey,\n                    xData = series.xData,\n                    xLength = xData.length,\n                    actualStackX,\n                    totalYVal,\n                    actualSum,\n                    prevSum,\n                    statesLen,\n                    posTotal,\n                    negTotal,\n                    xPoint,\n                    yVal,\n                    x,\n                    alreadyChanged,\n                    changed;\n                // Function responsible for calculating correct values for stackState\n                // array of each stack item. The arguments are: firstS - the value for\n                // the first state, nextS - the difference between the previous and the\n                // newest state, sInx - counter used in the for that updates each state\n                // when necessary, sOff - offset that must be added to each state when\n                // they need to be updated (if point isn't a total sum)\n                // eslint-disable-next-line require-jsdoc\n                function calculateStackState(firstS, nextS, sInx, sOff) {\n                    if (actualStackX) {\n                        if (!statesLen) {\n                            actualStackX.stackState[0] = firstS;\n                            statesLen = actualStackX.stackState.length;\n                        }\n                        else {\n                            for (sInx; sInx < statesLen; sInx++) {\n                                actualStackX.stackState[sInx] += sOff;\n                            }\n                        }\n                        actualStackX.stackState.push(actualStackX.stackState[statesLen - 1] + nextS);\n                    }\n                }\n                series.yAxis.stacking.usePercentage = false;\n                totalYVal = actualSum = prevSum = stackThreshold;\n                // code responsible for creating stacks for waterfall series\n                if (series.visible ||\n                    !series.chart.options.chart.ignoreHiddenSeries) {\n                    changed = waterfallStacks.changed;\n                    alreadyChanged = waterfallStacks.alreadyChanged;\n                    // In case of a redraw, stack for each x value must be emptied (only\n                    // for the first series in a specific stack) and recalculated once\n                    // more\n                    if (alreadyChanged &&\n                        alreadyChanged.indexOf(stackKey) < 0) {\n                        changed = true;\n                    }\n                    if (!waterfallStacks[stackKey]) {\n                        waterfallStacks[stackKey] = {};\n                    }\n                    var actualStack = waterfallStacks[stackKey];\n                    if (actualStack) {\n                        for (var i = 0; i < xLength; i++) {\n                            x = xData[i];\n                            if (!actualStack[x] || changed) {\n                                actualStack[x] = {\n                                    negTotal: 0,\n                                    posTotal: 0,\n                                    stackTotal: 0,\n                                    threshold: 0,\n                                    stateIndex: 0,\n                                    stackState: [],\n                                    label: ((changed &&\n                                        actualStack[x]) ?\n                                        actualStack[x].label :\n                                        void 0)\n                                };\n                            }\n                            actualStackX = actualStack[x];\n                            yVal = series.yData[i];\n                            if (yVal >= 0) {\n                                actualStackX.posTotal += yVal;\n                            }\n                            else {\n                                actualStackX.negTotal += yVal;\n                            }\n                            // points do not exist yet, so raw data is used\n                            xPoint = options.data[i];\n                            posTotal = actualStackX.absolutePos = actualStackX.posTotal;\n                            negTotal = actualStackX.absoluteNeg = actualStackX.negTotal;\n                            actualStackX.stackTotal = posTotal + negTotal;\n                            statesLen = actualStackX.stackState.length;\n                            if (xPoint && xPoint.isIntermediateSum) {\n                                calculateStackState(prevSum, actualSum, 0, prevSum);\n                                prevSum = actualSum;\n                                actualSum = seriesThreshold;\n                                // swapping values\n                                stackThreshold ^= interSum;\n                                interSum ^= stackThreshold;\n                                stackThreshold ^= interSum;\n                            }\n                            else if (xPoint && xPoint.isSum) {\n                                calculateStackState(seriesThreshold, totalYVal, statesLen, 0);\n                                stackThreshold = seriesThreshold;\n                            }\n                            else {\n                                calculateStackState(stackThreshold, yVal, 0, totalYVal);\n                                if (xPoint) {\n                                    totalYVal += yVal;\n                                    actualSum += yVal;\n                                }\n                            }\n                            actualStackX.stateIndex++;\n                            actualStackX.threshold = stackThreshold;\n                            stackThreshold += actualStackX.stackTotal;\n                        }\n                    }\n                    waterfallStacks.changed = false;\n                    if (!waterfallStacks.alreadyChanged) {\n                        waterfallStacks.alreadyChanged = [];\n                    }\n                    waterfallStacks.alreadyChanged.push(stackKey);\n                }\n            };\n            // Extremes for a non-stacked series are recorded in processData.\n            // In case of stacking, use Series.stackedYData to calculate extremes.\n            WaterfallSeries.prototype.getExtremes = function () {\n                var stacking = this.options.stacking,\n                    yAxis,\n                    waterfallStacks,\n                    stackedYNeg,\n                    stackedYPos;\n                if (stacking) {\n                    yAxis = this.yAxis;\n                    waterfallStacks = yAxis.waterfall.stacks;\n                    stackedYNeg = this.stackedYNeg = [];\n                    stackedYPos = this.stackedYPos = [];\n                    // the visible y range can be different when stacking is set to\n                    // overlap and different when it's set to normal\n                    if (stacking === 'overlap') {\n                        objectEach(waterfallStacks[this.stackKey], function (stackX) {\n                            stackedYNeg.push(arrayMin(stackX.stackState));\n                            stackedYPos.push(arrayMax(stackX.stackState));\n                        });\n                    }\n                    else {\n                        objectEach(waterfallStacks[this.stackKey], function (stackX) {\n                            stackedYNeg.push(stackX.negTotal + stackX.threshold);\n                            stackedYPos.push(stackX.posTotal + stackX.threshold);\n                        });\n                    }\n                    return {\n                        dataMin: arrayMin(stackedYNeg),\n                        dataMax: arrayMax(stackedYPos)\n                    };\n                }\n                // When not stacking, data extremes have already been computed in the\n                // processData function.\n                return {\n                    dataMin: this.dataMin,\n                    dataMax: this.dataMax\n                };\n            };\n            /**\n             * A waterfall chart displays sequentially introduced positive or negative\n             * values in cumulative columns.\n             *\n             * @sample highcharts/demo/waterfall/\n             *         Waterfall chart\n             * @sample highcharts/plotoptions/waterfall-inverted/\n             *         Horizontal (inverted) waterfall\n             * @sample highcharts/plotoptions/waterfall-stacked/\n             *         Stacked waterfall chart\n             *\n             * @extends      plotOptions.column\n             * @excluding    boostThreshold, boostBlending\n             * @product      highcharts\n             * @requires     highcharts-more\n             * @optionparent plotOptions.waterfall\n             */\n            WaterfallSeries.defaultOptions = merge(ColumnSeries.defaultOptions, {\n                /**\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @apioption plotOptions.waterfall.color\n                 */\n                /**\n                 * The color used specifically for positive point columns. When not\n                 * specified, the general series color is used.\n                 *\n                 * In styled mode, the waterfall colors can be set with the\n                 * `.highcharts-point-negative`, `.highcharts-sum` and\n                 * `.highcharts-intermediate-sum` classes.\n                 *\n                 * @sample {highcharts} highcharts/demo/waterfall/\n                 *         Waterfall\n                 *\n                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @product   highcharts\n                 * @apioption plotOptions.waterfall.upColor\n                 */\n                dataLabels: {\n                    inside: true\n                },\n                /**\n                 * The width of the line connecting waterfall columns.\n                 *\n                 * @product highcharts\n                 */\n                lineWidth: 1,\n                /**\n                 * The color of the line that connects columns in a waterfall series.\n                 *\n                 * In styled mode, the stroke can be set with the `.highcharts-graph`\n                 * class.\n                 *\n                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                lineColor: \"#333333\" /* Palette.neutralColor80 */,\n                /**\n                 * A name for the dash style to use for the line connecting the columns\n                 * of the waterfall series. Possible values: Dash, DashDot, Dot,\n                 * LongDash, LongDashDot, LongDashDotDot, ShortDash, ShortDashDot,\n                 * ShortDashDotDot, ShortDot, Solid\n                 *\n                 * In styled mode, the stroke dash-array can be set with the\n                 * `.highcharts-graph` class.\n                 *\n                 * @type    {Highcharts.DashStyleValue}\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                dashStyle: 'Dot',\n                /**\n                 * The color of the border of each waterfall column.\n                 *\n                 * In styled mode, the border stroke can be set with the\n                 * `.highcharts-point` class.\n                 *\n                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}\n                 * @since   3.0\n                 * @product highcharts\n                 */\n                borderColor: \"#333333\" /* Palette.neutralColor80 */,\n                states: {\n                    hover: {\n                        lineWidthPlus: 0 // #3126\n                    }\n                }\n            });\n            return WaterfallSeries;\n        }(ColumnSeries));\n        extend(WaterfallSeries.prototype, {\n            getZonesGraphs: LineSeries.prototype.getZonesGraphs,\n            pointValKey: 'y',\n            // Property needed to prevent lines between the columns from disappearing\n            // when negativeColor is used.\n            showLine: true,\n            pointClass: WaterfallPoint\n        });\n        SeriesRegistry.registerSeriesType('waterfall', WaterfallSeries);\n        WaterfallAxis.compose(Axis, Chart);\n        /* *\n         *\n         * Export\n         *\n         * */\n        /**\n         *\n         * API Options\n         *\n         */\n        /**\n         * A `waterfall` series. If the [type](#series.waterfall.type) option\n         * is not specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.waterfall\n         * @excluding dataParser, dataURL, boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  highcharts-more\n         * @apioption series.waterfall\n         */\n        /**\n         * An array of data points for the series. For the `waterfall` series\n         * type, points can be given in the following ways:\n         *\n         * 1. An array of numerical values. In this case, the numerical values will be\n         *    interpreted as `y` options. The `x` values will be automatically\n         *    calculated, either starting at 0 and incremented by 1, or from\n         *    `pointStart` and `pointInterval` given in the series options. If the axis\n         *    has categories, these will be used. Example:\n         *    ```js\n         *    data: [0, 5, 3, 5]\n         *    ```\n         *\n         * 2. An array of arrays with 2 values. In this case, the values correspond to\n         *    `x,y`. If the first value is a string, it is applied as the name of the\n         *    point, and the `x` value is inferred.\n         *    ```js\n         *    data: [\n         *        [0, 7],\n         *        [1, 8],\n         *        [2, 3]\n         *    ]\n         *    ```\n         *\n         * 3. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.waterfall.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        x: 1,\n         *        y: 8,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        x: 1,\n         *        y: 8,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/chart/reflow-true/\n         *         Numerical values\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<number|Array<(number|string),(number|null)>|null|*>}\n         * @extends   series.line.data\n         * @excluding marker\n         * @product   highcharts\n         * @apioption series.waterfall.data\n         */\n        /**\n         * When this property is true, the points acts as a summary column for\n         * the values added or substracted since the last intermediate sum,\n         * or since the start of the series. The `y` value is ignored.\n         *\n         * @sample {highcharts} highcharts/demo/waterfall/\n         *         Waterfall\n         *\n         * @type      {boolean}\n         * @default   false\n         * @product   highcharts\n         * @apioption series.waterfall.data.isIntermediateSum\n         */\n        /**\n         * When this property is true, the point display the total sum across\n         * the entire series. The `y` value is ignored.\n         *\n         * @sample {highcharts} highcharts/demo/waterfall/\n         *         Waterfall\n         *\n         * @type      {boolean}\n         * @default   false\n         * @product   highcharts\n         * @apioption series.waterfall.data.isSum\n         */\n        ''; // adds doclets above to transpiled file\n\n        return WaterfallSeries;\n    });\n    _registerModule(_modules, 'Core/Axis/RadialAxis.js', [_modules['Core/Axis/AxisDefaults.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (AxisDefaults, D, H, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var defaultOptions = D.defaultOptions;\n        var noop = H.noop;\n        var addEvent = U.addEvent,\n            correctFloat = U.correctFloat,\n            defined = U.defined,\n            extend = U.extend,\n            fireEvent = U.fireEvent,\n            merge = U.merge,\n            pick = U.pick,\n            relativeLength = U.relativeLength,\n            wrap = U.wrap;\n        /* *\n         *\n         *  Composition\n         *\n         * */\n        var RadialAxis;\n        (function (RadialAxis) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            var composedClasses = [];\n            /**\n             * Circular axis around the perimeter of a polar chart.\n             * @private\n             */\n            var defaultCircularOptions = {\n                    gridLineWidth: 1,\n                    labels: {\n                        align: void 0,\n                        distance: 15,\n                        x: 0,\n                        y: void 0,\n                        style: {\n                            textOverflow: 'none' // wrap lines by default (#7248)\n                        }\n                    },\n                    maxPadding: 0,\n                    minPadding: 0,\n                    showLastLabel: false,\n                    tickLength: 0\n                };\n            /**\n             * The default options extend defaultYAxisOptions.\n             * @private\n             */\n            var defaultRadialGaugeOptions = {\n                    labels: {\n                        align: 'center',\n                        x: 0,\n                        y: void 0 // auto\n                    },\n                    minorGridLineWidth: 0,\n                    minorTickInterval: 'auto',\n                    minorTickLength: 10,\n                    minorTickPosition: 'inside',\n                    minorTickWidth: 1,\n                    tickLength: 10,\n                    tickPosition: 'inside',\n                    tickWidth: 2,\n                    title: {\n                        rotation: 0\n                    },\n                    zIndex: 2 // behind dials, points in the series group\n                };\n            /**\n             * Radial axis, like a spoke in a polar chart.\n             * @private\n             */\n            var defaultRadialOptions = {\n                    /**\n                     * In a polar chart, this is the angle of the Y axis in degrees, where\n                     * 0 is up and 90 is right. The angle determines the position of the\n                     * axis line and the labels, though the coordinate system is unaffected.\n                     * Since v8.0.0 this option is also applicable for X axis (inverted\n                     * polar).\n                     *\n                     * @sample {highcharts} highcharts/xaxis/angle/\n                     *         Custom X axis' angle on inverted polar chart\n                     * @sample {highcharts} highcharts/yaxis/angle/\n                     *         Dual axis polar chart\n                     *\n                     * @type      {number}\n                     * @default   0\n                     * @since     4.2.7\n                     * @product   highcharts\n                     * @apioption xAxis.angle\n                     */\n                    /**\n                     * Polar charts only. Whether the grid lines should draw as a polygon\n                     * with straight lines between categories, or as circles. Can be either\n                     * `circle` or `polygon`. Since v8.0.0 this option is also applicable\n                     * for X axis (inverted polar).\n                     *\n                     * @sample {highcharts} highcharts/demo/polar-spider/\n                     *         Polygon grid lines\n                     * @sample {highcharts} highcharts/xaxis/gridlineinterpolation/\n                     *         Circle and polygon on inverted polar\n                     * @sample {highcharts} highcharts/yaxis/gridlineinterpolation/\n                     *         Circle and polygon\n                     *\n                     * @type       {string}\n                     * @product    highcharts\n                     * @validvalue [\"circle\", \"polygon\"]\n                     * @apioption  xAxis.gridLineInterpolation\n                     */\n                    gridLineInterpolation: 'circle',\n                    gridLineWidth: 1,\n                    labels: {\n                        align: 'right',\n                        x: -3,\n                        y: -2\n                    },\n                    showLastLabel: false,\n                    title: {\n                        x: 4,\n                        text: null,\n                        rotation: 90\n                    }\n                };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /* eslint-disable valid-jsdoc */\n            /**\n             * In case of auto connect, add one closestPointRange to the max value\n             * right before tickPositions are computed, so that ticks will extend\n             * passed the real max.\n             * @private\n             */\n            function beforeSetTickPositions() {\n                // If autoConnect is true, polygonal grid lines are connected, and\n                // one closestPointRange is added to the X axis to prevent the last\n                // point from overlapping the first.\n                this.autoConnect = (this.isCircular &&\n                    typeof pick(this.userMax, this.options.max) === 'undefined' &&\n                    correctFloat(this.endAngleRad - this.startAngleRad) ===\n                        correctFloat(2 * Math.PI));\n                // This will lead to add an extra tick to xAxis in order to display\n                // a correct range on inverted polar\n                if (!this.isCircular && this.chart.inverted) {\n                    this.max++;\n                }\n                if (this.autoConnect) {\n                    this.max += ((this.categories && 1) ||\n                        this.pointRange ||\n                        this.closestPointRange ||\n                        0); // #1197, #2260\n                }\n            }\n            /**\n             * Augments methods for the value axis.\n             *\n             * @private\n             *\n             * @param {Highcharts.Axis} AxisClass\n             * Axis class to extend.\n             *\n             * @param {Highcharts.Tick} TickClass\n             * Tick class to use.\n             *\n             * @return {Highcharts.Axis}\n             * Axis composition.\n             */\n            function compose(AxisClass, TickClass) {\n                if (composedClasses.indexOf(AxisClass) === -1) {\n                    composedClasses.push(AxisClass);\n                    addEvent(AxisClass, 'afterInit', onAxisAfterInit);\n                    addEvent(AxisClass, 'autoLabelAlign', onAxisAutoLabelAlign);\n                    addEvent(AxisClass, 'destroy', onAxisDestroy);\n                    addEvent(AxisClass, 'init', onAxisInit);\n                    addEvent(AxisClass, 'initialAxisTranslation', onAxisInitialAxisTranslation);\n                }\n                if (composedClasses.indexOf(TickClass) === -1) {\n                    composedClasses.push(TickClass);\n                    addEvent(TickClass, 'afterGetLabelPosition', onTickAfterGetLabelPosition);\n                    addEvent(TickClass, 'afterGetPosition', onTickAfterGetPosition);\n                    wrap(TickClass.prototype, 'getMarkPath', wrapTickGetMarkPath);\n                }\n                return AxisClass;\n            }\n            RadialAxis.compose = compose;\n            /**\n             * Attach and return collecting function for labels in radial axis for\n             * anti-collision.\n             *\n             * @private\n             */\n            function createLabelCollector() {\n                var _this = this;\n                return function () {\n                    if (_this.isRadial &&\n                        _this.tickPositions &&\n                        // undocumented option for now, but working\n                        _this.options.labels &&\n                        _this.options.labels.allowOverlap !== true) {\n                        return _this.tickPositions\n                            .map(function (pos) {\n                            return _this.ticks[pos] && _this.ticks[pos].label;\n                        })\n                            .filter(function (label) {\n                            return Boolean(label);\n                        });\n                    }\n                };\n            }\n            /**\n             * Creates an empty collector function.\n             * @private\n             */\n            function createLabelCollectorHidden() {\n                return noop;\n            }\n            /**\n             * Find the correct end values of crosshair in polar.\n             * @private\n             */\n            function getCrosshairPosition(options, x1, y1) {\n                var center = this.pane.center;\n                var value = options.value,\n                    shapeArgs,\n                    end,\n                    x2,\n                    y2;\n                if (this.isCircular) {\n                    if (!defined(value)) {\n                        // When the snap is set to false\n                        x2 = options.chartX || 0;\n                        y2 = options.chartY || 0;\n                        value = this.translate(Math.atan2(y2 - y1, x2 - x1) - this.startAngleRad, true);\n                    }\n                    else if (options.point) {\n                        // When the snap is set to true\n                        shapeArgs = options.point.shapeArgs || {};\n                        if (shapeArgs.start) {\n                            // Find a true value of the point based on the\n                            // angle\n                            value = this.chart.inverted ?\n                                this.translate(options.point.rectPlotY, true) :\n                                options.point.x;\n                        }\n                    }\n                    end = this.getPosition(value);\n                    x2 = end.x;\n                    y2 = end.y;\n                }\n                else {\n                    if (!defined(value)) {\n                        x2 = options.chartX;\n                        y2 = options.chartY;\n                    }\n                    if (defined(x2) && defined(y2)) {\n                        // Calculate radius of non-circular axis' crosshair\n                        y1 = center[1] + this.chart.plotTop;\n                        value = this.translate(Math.min(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), center[2] / 2) - center[3] / 2, true);\n                    }\n                }\n                return [value, x2 || 0, y2 || 0];\n            }\n            /**\n             * Get the path for the axis line. This method is also referenced in the\n             * getPlotLinePath method.\n             *\n             * @private\n             * @param {number} _lineWidth\n             * Line width is not used.\n             * @param {number} [radius]\n             * Radius of radial path.\n             * @param {number} [innerRadius]\n             * Inner radius of radial path.\n             */\n            function getLinePath(_lineWidth, radius, innerRadius) {\n                var center = this.pane.center,\n                    chart = this.chart,\n                    left = this.left || 0,\n                    top = this.top || 0;\n                var end,\n                    r = pick(radius,\n                    center[2] / 2 - this.offset),\n                    path;\n                if (typeof innerRadius === 'undefined') {\n                    innerRadius = this.horiz ? 0 : this.center && -this.center[3] / 2;\n                }\n                // In case when innerSize of pane is set, it must be included\n                if (innerRadius) {\n                    r += innerRadius;\n                }\n                if (this.isCircular || typeof radius !== 'undefined') {\n                    path = this.chart.renderer.symbols.arc(left + center[0], top + center[1], r, r, {\n                        start: this.startAngleRad,\n                        end: this.endAngleRad,\n                        open: true,\n                        innerR: 0\n                    });\n                    // Bounds used to position the plotLine label next to the line\n                    // (#7117)\n                    path.xBounds = [left + center[0]];\n                    path.yBounds = [top + center[1] - r];\n                }\n                else {\n                    end = this.postTranslate(this.angleRad, r);\n                    path = [\n                        [\n                            'M',\n                            this.center[0] + chart.plotLeft,\n                            this.center[1] + chart.plotTop\n                        ],\n                        ['L', end.x, end.y]\n                    ];\n                }\n                return path;\n            }\n            /**\n             * Wrap the getOffset method to return zero offset for title or labels\n             * in a radial axis.\n             */\n            function getOffset() {\n                var axisProto = this.constructor.prototype;\n                // Call the Axis prototype method (the method we're in now is on the\n                // instance)\n                axisProto.getOffset.call(this);\n                // Title or label offsets are not counted\n                this.chart.axisOffset[this.side] = 0;\n            }\n            /**\n             * Find the path for plot bands along the radial axis.\n             *\n             * @private\n             */\n            function getPlotBandPath(from, to, options) {\n                var chart = this.chart,\n                    radiusToPixels = function (radius) {\n                        if (typeof radius === 'string') {\n                            var r = parseInt(radius, 10);\n                        if (percentRegex.test(radius)) {\n                            r = (r * fullRadius) / 100;\n                        }\n                        return r;\n                    }\n                    return radius;\n                }, center = this.center, startAngleRad = this.startAngleRad, fullRadius = center[2] / 2, offset = Math.min(this.offset, 0), left = this.left || 0, top = this.top || 0, percentRegex = /%$/, isCircular = this.isCircular; // X axis in a polar chart\n                var start,\n                    end,\n                    angle,\n                    xOnPerimeter,\n                    open,\n                    path,\n                    outerRadius = pick(radiusToPixels(options.outerRadius),\n                    fullRadius),\n                    innerRadius = radiusToPixels(options.innerRadius),\n                    thickness = pick(radiusToPixels(options.thickness), 10);\n                // Polygonal plot bands\n                if (this.options.gridLineInterpolation === 'polygon') {\n                    path = this.getPlotLinePath({ value: from }).concat(this.getPlotLinePath({ value: to, reverse: true }));\n                    // Circular grid bands\n                }\n                else {\n                    // Keep within bounds\n                    from = Math.max(from, this.min);\n                    to = Math.min(to, this.max);\n                    var transFrom = this.translate(from),\n                        transTo = this.translate(to);\n                    // Plot bands on Y axis (radial axis) - inner and outer\n                    // radius depend on to and from\n                    if (!isCircular) {\n                        outerRadius = transFrom || 0;\n                        innerRadius = transTo || 0;\n                    }\n                    // Handle full circle\n                    if (options.shape === 'circle' || !isCircular) {\n                        start = -Math.PI / 2;\n                        end = Math.PI * 1.5;\n                        open = true;\n                    }\n                    else {\n                        start = startAngleRad + (transFrom || 0);\n                        end = startAngleRad + (transTo || 0);\n                    }\n                    outerRadius -= offset; // #5283\n                    thickness -= offset; // #5283\n                    path = chart.renderer.symbols.arc(left + center[0], top + center[1], outerRadius, outerRadius, {\n                        // Math is for reversed yAxis (#3606)\n                        start: Math.min(start, end),\n                        end: Math.max(start, end),\n                        innerR: pick(innerRadius, outerRadius - thickness),\n                        open: open\n                    });\n                    // Provide positioning boxes for the label (#6406)\n                    if (isCircular) {\n                        angle = (end + start) / 2;\n                        xOnPerimeter = (left +\n                            center[0] +\n                            (center[2] / 2) * Math.cos(angle));\n                        path.xBounds = angle > -Math.PI / 2 && angle < Math.PI / 2 ?\n                            // Right hemisphere\n                            [xOnPerimeter, chart.plotWidth] :\n                            // Left hemisphere\n                            [0, xOnPerimeter];\n                        path.yBounds = [\n                            top + center[1] + (center[2] / 2) * Math.sin(angle)\n                        ];\n                        // Shift up or down to get the label clear of the perimeter\n                        path.yBounds[0] += ((angle > -Math.PI && angle < 0) ||\n                            (angle > Math.PI)) ? -10 : 10;\n                    }\n                }\n                return path;\n            }\n            /**\n             * Find the path for plot lines perpendicular to the radial axis.\n             */\n            function getPlotLinePath(options) {\n                var _this = this;\n                var center = this.pane.center, chart = this.chart, inverted = chart.inverted, reverse = options.reverse, background = this.pane.options.background ?\n                        (this.pane.options.background[0] ||\n                            this.pane.options.background) :\n                        {}, innerRadius = background.innerRadius || '0%', outerRadius = background.outerRadius || '100%', x1 = center[0] + chart.plotLeft, y1 = center[1] + chart.plotTop, height = this.height, isCrosshair = options.isCrosshair, paneInnerR = center[3] / 2;\n                var value = options.value,\n                    innerRatio,\n                    distance,\n                    a,\n                    b,\n                    otherAxis,\n                    xy,\n                    tickPositions,\n                    crossPos,\n                    path;\n                var end = this.getPosition(value);\n                var x2 = end.x,\n                    y2 = end.y;\n                // Crosshair logic\n                if (isCrosshair) {\n                    // Find crosshair's position and perform destructuring\n                    // assignment\n                    crossPos = this.getCrosshairPosition(options, x1, y1);\n                    value = crossPos[0];\n                    x2 = crossPos[1];\n                    y2 = crossPos[2];\n                }\n                // Spokes\n                if (this.isCircular) {\n                    distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n                    a = (typeof innerRadius === 'string') ?\n                        relativeLength(innerRadius, 1) :\n                        (innerRadius / distance);\n                    b = (typeof outerRadius === 'string') ?\n                        relativeLength(outerRadius, 1) :\n                        (outerRadius / distance);\n                    // To ensure that gridlines won't be displayed in area\n                    // defined by innerSize in case of custom radiuses of pane's\n                    // background\n                    if (center && paneInnerR) {\n                        innerRatio = paneInnerR / distance;\n                        if (a < innerRatio) {\n                            a = innerRatio;\n                        }\n                        if (b < innerRatio) {\n                            b = innerRatio;\n                        }\n                    }\n                    path = [\n                        ['M', x1 + a * (x2 - x1), y1 - a * (y1 - y2)],\n                        ['L', x2 - (1 - b) * (x2 - x1), y2 + (1 - b) * (y1 - y2)]\n                    ];\n                    // Concentric circles\n                }\n                else {\n                    // Pick the right values depending if it is grid line or\n                    // crosshair\n                    value = this.translate(value);\n                    // This is required in case when xAxis is non-circular to\n                    // prevent grid lines (or crosshairs, if enabled) from\n                    // rendering above the center after they supposed to be\n                    // displayed below the center point\n                    if (value) {\n                        if (value < 0 || value > height) {\n                            value = 0;\n                        }\n                    }\n                    if (this.options.gridLineInterpolation === 'circle') {\n                        // A value of 0 is in the center, so it won't be\n                        // visible, but draw it anyway for update and animation\n                        // (#2366)\n                        path = this.getLinePath(0, value, paneInnerR);\n                        // Concentric polygons\n                    }\n                    else {\n                        path = [];\n                        // Find the other axis (a circular one) in the same pane\n                        chart[inverted ? 'yAxis' : 'xAxis'].forEach(function (a) {\n                            if (a.pane === _this.pane) {\n                                otherAxis = a;\n                            }\n                        });\n                        if (otherAxis) {\n                            tickPositions = otherAxis.tickPositions;\n                            if (otherAxis.autoConnect) {\n                                tickPositions =\n                                    tickPositions.concat([tickPositions[0]]);\n                            }\n                            // Reverse the positions for concatenation of polygonal\n                            // plot bands\n                            if (reverse) {\n                                tickPositions = tickPositions.slice().reverse();\n                            }\n                            if (value) {\n                                value += paneInnerR;\n                            }\n                            for (var i = 0; i < tickPositions.length; i++) {\n                                xy = otherAxis.getPosition(tickPositions[i], value);\n                                path.push(i ? ['L', xy.x, xy.y] : ['M', xy.x, xy.y]);\n                            }\n                        }\n                    }\n                }\n                return path;\n            }\n            /**\n             * Returns the x, y coordinate of a point given by a value and a pixel\n             * distance from center.\n             *\n             * @private\n             * @param {number} value\n             * Point value.\n             * @param {number} [length]\n             * Distance from center.\n             */\n            function getPosition(value, length) {\n                var translatedVal = this.translate(value);\n                return this.postTranslate(this.isCircular ? translatedVal : this.angleRad, // #2848\n                // In case when translatedVal is negative, the 0 value must be\n                // used instead, in order to deal with lines and labels that\n                // fall out of the visible range near the center of a pane\n                pick(this.isCircular ?\n                    length :\n                    (translatedVal < 0 ? 0 : translatedVal), this.center[2] / 2) - this.offset);\n            }\n            /**\n             * Find the position for the axis title, by default inside the gauge.\n             */\n            function getTitlePosition() {\n                var center = this.center,\n                    chart = this.chart,\n                    titleOptions = this.options.title;\n                return {\n                    x: chart.plotLeft + center[0] + (titleOptions.x || 0),\n                    y: (chart.plotTop +\n                        center[1] -\n                        ({\n                            high: 0.5,\n                            middle: 0.25,\n                            low: 0\n                        }[titleOptions.align] *\n                            center[2]) +\n                        (titleOptions.y || 0))\n                };\n            }\n            /**\n             * Modify radial axis.\n             * @private\n             *\n             * @param {Highcharts.Axis} radialAxis\n             * Radial axis to modify.\n             */\n            function modify(axis) {\n                axis.beforeSetTickPositions = beforeSetTickPositions;\n                axis.createLabelCollector = createLabelCollector;\n                axis.getCrosshairPosition = getCrosshairPosition;\n                axis.getLinePath = getLinePath;\n                axis.getOffset = getOffset;\n                axis.getPlotBandPath = getPlotBandPath;\n                axis.getPlotLinePath = getPlotLinePath;\n                axis.getPosition = getPosition;\n                axis.getTitlePosition = getTitlePosition;\n                axis.postTranslate = postTranslate;\n                axis.setAxisSize = setAxisSize;\n                axis.setAxisTranslation = setAxisTranslation;\n                axis.setOptions = setOptions;\n            }\n            /**\n             * Modify radial axis as hidden.\n             * @private\n             *\n             * @param {Highcharts.Axis} radialAxis\n             * Radial axis to modify.\n             */\n            function modifyAsHidden(radialAxis) {\n                radialAxis.isHidden = true;\n                radialAxis.createLabelCollector = createLabelCollectorHidden;\n                radialAxis.getOffset = noop;\n                radialAxis.redraw = renderHidden;\n                radialAxis.render = renderHidden;\n                radialAxis.setScale = noop;\n                radialAxis.setCategories = noop;\n                radialAxis.setTitle = noop;\n            }\n            /**\n             * Finalize modification of axis instance with radial logic.\n             */\n            function onAxisAfterInit() {\n                var chart = this.chart,\n                    options = this.options,\n                    isHidden = chart.angular && this.isXAxis,\n                    pane = this.pane,\n                    paneOptions = pane && pane.options;\n                if (!isHidden && pane && (chart.angular || chart.polar)) {\n                    var fullCircle = Math.PI * 2, \n                        // Start and end angle options are given in degrees relative to\n                        // top, while internal computations are in radians relative to\n                        // right (like SVG).\n                        start = (pick(paneOptions.startAngle, 0) - 90) * Math.PI / 180,\n                        end = (pick(paneOptions.endAngle,\n                        pick(paneOptions.startAngle, 0) + 360) - 90) * Math.PI / 180;\n                    // Y axis in polar charts\n                    this.angleRad = (options.angle || 0) * Math.PI / 180;\n                    // Gauges\n                    this.startAngleRad = start;\n                    this.endAngleRad = end;\n                    this.offset = options.offset || 0;\n                    // Normalize Start and End to <0, 2*PI> range\n                    // (in degrees: <0,360>)\n                    var normalizedStart = (start % fullCircle + fullCircle) %\n                            fullCircle,\n                        normalizedEnd = (end % fullCircle + fullCircle) % fullCircle;\n                    // Move normalized angles to <-PI, PI> range (<-180, 180>)\n                    // to match values returned by Math.atan2()\n                    if (normalizedStart > Math.PI) {\n                        normalizedStart -= fullCircle;\n                    }\n                    if (normalizedEnd > Math.PI) {\n                        normalizedEnd -= fullCircle;\n                    }\n                    this.normalizedStartAngleRad = normalizedStart;\n                    this.normalizedEndAngleRad = normalizedEnd;\n                }\n            }\n            /**\n             * Wrap auto label align to avoid setting axis-wide rotation on radial axes.\n             * (#4920)\n             */\n            function onAxisAutoLabelAlign(e) {\n                if (this.isRadial) {\n                    e.align = void 0;\n                    e.preventDefault();\n                }\n            }\n            /**\n             * Remove label collector function on axis remove/update.\n             */\n            function onAxisDestroy() {\n                if (this.chart &&\n                    this.chart.labelCollectors) {\n                    var index = (this.labelCollector ?\n                            this.chart.labelCollectors.indexOf(this.labelCollector) :\n                            -1);\n                    if (index >= 0) {\n                        this.chart.labelCollectors.splice(index, 1);\n                    }\n                }\n            }\n            /**\n             * Modify axis instance with radial logic before common axis init.\n             */\n            function onAxisInit(e) {\n                var chart = this.chart,\n                    inverted = chart.inverted,\n                    angular = chart.angular,\n                    polar = chart.polar,\n                    isX = this.isXAxis,\n                    coll = this.coll,\n                    isHidden = angular && isX,\n                    chartOptions = chart.options,\n                    paneIndex = e.userOptions.pane || 0,\n                    pane = this.pane = chart.pane && chart.pane[paneIndex];\n                var isCircular;\n                // Prevent changes for colorAxis\n                if (coll === 'colorAxis') {\n                    this.isRadial = false;\n                    return;\n                }\n                // Before prototype.init\n                if (angular) {\n                    if (isHidden) {\n                        modifyAsHidden(this);\n                    }\n                    else {\n                        modify(this);\n                    }\n                    isCircular = !isX;\n                    if (isCircular) {\n                        this.defaultPolarOptions = defaultRadialGaugeOptions;\n                    }\n                }\n                else if (polar) {\n                    modify(this);\n                    // Check which axis is circular\n                    isCircular = this.horiz;\n                    this.defaultPolarOptions = isCircular ?\n                        defaultCircularOptions :\n                        merge(coll === 'xAxis' ?\n                            AxisDefaults.defaultXAxisOptions :\n                            AxisDefaults.defaultYAxisOptions, defaultRadialOptions);\n                    // Apply the stack labels for yAxis in case of inverted chart\n                    if (inverted && coll === 'yAxis') {\n                        this.defaultPolarOptions.stackLabels = AxisDefaults\n                            .defaultYAxisOptions.stackLabels;\n                        this.defaultPolarOptions.reversedStacks = true;\n                    }\n                }\n                // Disable certain features on angular and polar axes\n                if (angular || polar) {\n                    this.isRadial = true;\n                    if (!this.labelCollector) {\n                        this.labelCollector = this.createLabelCollector();\n                    }\n                    if (this.labelCollector) {\n                        // Prevent overlapping axis labels (#9761)\n                        chart.labelCollectors.push(this.labelCollector);\n                    }\n                }\n                else {\n                    this.isRadial = false;\n                }\n                // A pointer back to this axis to borrow geometry\n                if (pane && isCircular) {\n                    pane.axis = this;\n                }\n                this.isCircular = isCircular;\n            }\n            /**\n             * Prepare axis translation.\n             */\n            function onAxisInitialAxisTranslation() {\n                if (this.isRadial) {\n                    this.beforeSetTickPositions();\n                }\n            }\n            /**\n             * Find the center position of the label based on the distance option.\n             */\n            function onTickAfterGetLabelPosition(e) {\n                var label = this.label;\n                if (!label) {\n                    return;\n                }\n                var axis = this.axis,\n                    labelBBox = label.getBBox(),\n                    labelOptions = axis.options.labels,\n                    angle = ((axis.translate(this.pos) + axis.startAngleRad +\n                        Math.PI / 2) / Math.PI * 180) % 360,\n                    correctAngle = Math.round(angle),\n                    labelYPosCorrection = !defined(labelOptions.y) ? -labelBBox.height * 0.3 : 0;\n                var optionsY = labelOptions.y, ret, centerSlot = 20, // 20 degrees to each side at the top and bottom\n                    align = labelOptions.align, labelDir = 'end', // Direction of the label 'start' or 'end'\n                    reducedAngle1 = correctAngle < 0 ?\n                        correctAngle + 360 : correctAngle, reducedAngle2 = reducedAngle1, translateY = 0, translateX = 0;\n                if (axis.isRadial) { // Both X and Y axes in a polar chart\n                    ret = axis.getPosition(this.pos, (axis.center[2] / 2) +\n                        relativeLength(pick(labelOptions.distance, -25), axis.center[2] / 2, -axis.center[2] / 2));\n                    // Automatically rotated\n                    if (labelOptions.rotation === 'auto') {\n                        label.attr({\n                            rotation: angle\n                        });\n                        // Vertically centered\n                    }\n                    else if (!defined(optionsY)) {\n                        optionsY = (axis.chart.renderer\n                            .fontMetrics(label.styles && label.styles.fontSize).b -\n                            labelBBox.height / 2);\n                    }\n                    // Automatic alignment\n                    if (!defined(align)) {\n                        if (axis.isCircular) { // Y axis\n                            if (labelBBox.width >\n                                axis.len * axis.tickInterval / (axis.max - axis.min)) { // #3506\n                                centerSlot = 0;\n                            }\n                            if (angle > centerSlot && angle < 180 - centerSlot) {\n                                align = 'left'; // right hemisphere\n                            }\n                            else if (angle > 180 + centerSlot &&\n                                angle < 360 - centerSlot) {\n                                align = 'right'; // left hemisphere\n                            }\n                            else {\n                                align = 'center'; // top or bottom\n                            }\n                        }\n                        else {\n                            align = 'center';\n                        }\n                        label.attr({\n                            align: align\n                        });\n                    }\n                    // Auto alignment for solid-gauges with two labels (#10635)\n                    if (align === 'auto' &&\n                        axis.tickPositions.length === 2 &&\n                        axis.isCircular) {\n                        // Angles reduced to 0 - 90 or 180 - 270\n                        if (reducedAngle1 > 90 && reducedAngle1 < 180) {\n                            reducedAngle1 = 180 - reducedAngle1;\n                        }\n                        else if (reducedAngle1 > 270 && reducedAngle1 <= 360) {\n                            reducedAngle1 = 540 - reducedAngle1;\n                        }\n                        // Angles reduced to 0 - 180\n                        if (reducedAngle2 > 180 && reducedAngle2 <= 360) {\n                            reducedAngle2 = 360 - reducedAngle2;\n                        }\n                        if ((axis.pane.options.startAngle === correctAngle) ||\n                            (axis.pane.options.startAngle === correctAngle + 360) ||\n                            (axis.pane.options.startAngle === correctAngle - 360)) {\n                            labelDir = 'start';\n                        }\n                        if ((correctAngle >= -90 && correctAngle <= 90) ||\n                            (correctAngle >= -360 && correctAngle <= -270) ||\n                            (correctAngle >= 270 && correctAngle <= 360)) {\n                            align = (labelDir === 'start') ? 'right' : 'left';\n                        }\n                        else {\n                            align = (labelDir === 'start') ? 'left' : 'right';\n                        }\n                        // For angles beetwen (90 + n * 180) +- 20\n                        if (reducedAngle2 > 70 && reducedAngle2 < 110) {\n                            align = 'center';\n                        }\n                        // auto Y translation\n                        if (reducedAngle1 < 15 ||\n                            (reducedAngle1 >= 180 && reducedAngle1 < 195)) {\n                            translateY = labelBBox.height * 0.3;\n                        }\n                        else if (reducedAngle1 >= 15 && reducedAngle1 <= 35) {\n                            translateY = labelDir === 'start' ?\n                                0 : labelBBox.height * 0.75;\n                        }\n                        else if (reducedAngle1 >= 195 && reducedAngle1 <= 215) {\n                            translateY = labelDir === 'start' ?\n                                labelBBox.height * 0.75 : 0;\n                        }\n                        else if (reducedAngle1 > 35 && reducedAngle1 <= 90) {\n                            translateY = labelDir === 'start' ?\n                                -labelBBox.height * 0.25 : labelBBox.height;\n                        }\n                        else if (reducedAngle1 > 215 && reducedAngle1 <= 270) {\n                            translateY = labelDir === 'start' ?\n                                labelBBox.height : -labelBBox.height * 0.25;\n                        }\n                        // auto X translation\n                        if (reducedAngle2 < 15) {\n                            translateX = labelDir === 'start' ?\n                                -labelBBox.height * 0.15 : labelBBox.height * 0.15;\n                        }\n                        else if (reducedAngle2 > 165 && reducedAngle2 <= 180) {\n                            translateX = labelDir === 'start' ?\n                                labelBBox.height * 0.15 : -labelBBox.height * 0.15;\n                        }\n                        label.attr({ align: align });\n                        label.translate(translateX, translateY + labelYPosCorrection);\n                    }\n                    e.pos.x = ret.x + (labelOptions.x || 0);\n                    e.pos.y = ret.y + (optionsY || 0);\n                }\n            }\n            /**\n             * Add special cases within the Tick class' methods for radial axes.\n             */\n            function onTickAfterGetPosition(e) {\n                if (this.axis.getPosition) {\n                    extend(e.pos, this.axis.getPosition(this.pos));\n                }\n            }\n            /**\n             * Translate from intermediate plotX (angle), plotY (axis.len - radius)\n             * to final chart coordinates.\n             *\n             * @private\n             * @param {number} angle\n             * Translation angle.\n             * @param {number} radius\n             * Translation radius.\n             */\n            function postTranslate(angle, radius) {\n                var chart = this.chart,\n                    center = this.center;\n                angle = this.startAngleRad + angle;\n                return {\n                    x: chart.plotLeft + center[0] + Math.cos(angle) * radius,\n                    y: chart.plotTop + center[1] + Math.sin(angle) * radius\n                };\n            }\n            /**\n             * Prevent setting Y axis dirty.\n             */\n            function renderHidden() {\n                this.isDirty = false;\n            }\n            /**\n             * Override the setAxisSize method to use the arc's circumference as\n             * length. This allows tickPixelInterval to apply to pixel lengths along\n             * the perimeter.\n             * @private\n             */\n            function setAxisSize() {\n                var axisProto = this.constructor.prototype;\n                var center,\n                    start;\n                axisProto.setAxisSize.call(this);\n                if (this.isRadial) {\n                    // Set the center array\n                    this.pane.updateCenter(this);\n                    // In case when the innerSize is set in a polar chart, the axis'\n                    // center cannot be a reference to pane's center\n                    center = this.center = this.pane.center.slice();\n                    // The sector is used in Axis.translate to compute the\n                    // translation of reversed axis points (#2570)\n                    if (this.isCircular) {\n                        this.sector = this.endAngleRad - this.startAngleRad;\n                    }\n                    else {\n                        // When the pane's startAngle or the axis' angle is set then\n                        // new x and y values for vertical axis' center must be\n                        // calulated\n                        start = this.postTranslate(this.angleRad, center[3] / 2);\n                        center[0] = start.x - this.chart.plotLeft;\n                        center[1] = start.y - this.chart.plotTop;\n                    }\n                    // Axis len is used to lay out the ticks\n                    this.len = this.width = this.height =\n                        (center[2] - center[3]) * pick(this.sector, 1) / 2;\n                }\n            }\n            /**\n             * Override setAxisTranslation by setting the translation to the\n             * difference in rotation. This allows the translate method to return\n             * angle for any given value.\n             *\n             * @private\n             */\n            function setAxisTranslation() {\n                var axisProto = this.constructor.prototype;\n                // Call uber method\n                axisProto.setAxisTranslation.call(this);\n                // Set transA and minPixelPadding\n                if (this.center) { // it's not defined the first time\n                    if (this.isCircular) {\n                        this.transA = (this.endAngleRad - this.startAngleRad) /\n                            ((this.max - this.min) || 1);\n                    }\n                    else {\n                        // The transA here is the length of the axis, so in case\n                        // of inner radius, the length must be decreased by it\n                        this.transA = ((this.center[2] - this.center[3]) / 2) /\n                            ((this.max - this.min) || 1);\n                    }\n                    if (this.isXAxis) {\n                        this.minPixelPadding = this.transA * this.minPointOffset;\n                    }\n                    else {\n                        // This is a workaround for regression #2593, but categories\n                        // still don't position correctly.\n                        this.minPixelPadding = 0;\n                    }\n                }\n            }\n            /**\n             * Merge and set options.\n             */\n            function setOptions(userOptions) {\n                var options = this.options = merge(this.constructor.defaultOptions,\n                    this.defaultPolarOptions,\n                    defaultOptions[this.coll], // #16112\n                    userOptions);\n                // Make sure the plotBands array is instanciated for each Axis\n                // (#2649)\n                if (!options.plotBands) {\n                    options.plotBands = [];\n                }\n                fireEvent(this, 'afterSetOptions');\n            }\n            /**\n             * Wrap the getMarkPath function to return the path of the radial marker.\n             */\n            function wrapTickGetMarkPath(proceed, x, y, tickLength, tickWidth, horiz, renderer) {\n                var axis = this.axis;\n                var endPoint,\n                    ret;\n                if (axis.isRadial) {\n                    endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);\n                    ret = [\n                        'M',\n                        x,\n                        y,\n                        'L',\n                        endPoint.x,\n                        endPoint.y\n                    ];\n                }\n                else {\n                    ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);\n                }\n                return ret;\n            }\n            /* eslint-enable valid-jsdoc */\n        })(RadialAxis || (RadialAxis = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return RadialAxis;\n    });\n    _registerModule(_modules, 'Series/PolarComposition.js', [_modules['Core/Animation/AnimationUtilities.js'], _modules['Core/Globals.js'], _modules['Extensions/Pane.js'], _modules['Core/Axis/RadialAxis.js'], _modules['Core/Utilities.js']], function (A, H, Pane, RadialAxis, U) {\n        /* *\n         *\n         *  (c) 2010-2021 Torstein Honsi\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        var __spreadArray = (this && this.__spreadArray) || function (to,\n            from,\n            pack) {\n                if (pack || arguments.length === 2) for (var i = 0,\n            l = from.length,\n            ar; i < l; i++) {\n                    if (ar || !(i in from)) {\n                        if (!ar) ar = Array.prototype.slice.call(from, 0,\n            i);\n                    ar[i] = from[i];\n                }\n            }\n            return to.concat(ar || Array.prototype.slice.call(from));\n        };\n        var animObject = A.animObject;\n        var addEvent = U.addEvent,\n            defined = U.defined,\n            find = U.find,\n            isNumber = U.isNumber,\n            pick = U.pick,\n            splat = U.splat,\n            uniqueKey = U.uniqueKey,\n            wrap = U.wrap;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        var composedClasses = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function clipCircle(renderer, x, y, r, innerR) {\n            var id = uniqueKey(),\n                clipPath = renderer.createElement('clipPath').attr({\n                    id: id\n                }).add(renderer.defs),\n                wrapper = innerR ?\n                    renderer.arc(x,\n                y,\n                r,\n                innerR, 0, 2 * Math.PI).add(clipPath) :\n                    renderer.circle(x,\n                y,\n                r).add(clipPath);\n            wrapper.id = id;\n            wrapper.clipPath = clipPath;\n            return wrapper;\n        }\n        /**\n         * Find correct align and vertical align based on an angle in polar chart\n         * @private\n         */\n        function findAlignments(angle, options) {\n            var align,\n                verticalAlign;\n            if (options.align === null) {\n                if (angle > 20 && angle < 160) {\n                    align = 'left'; // right hemisphere\n                }\n                else if (angle > 200 && angle < 340) {\n                    align = 'right'; // left hemisphere\n                }\n                else {\n                    align = 'center'; // top or bottom\n                }\n                options.align = align;\n            }\n            if (options.verticalAlign === null) {\n                if (angle < 45 || angle > 315) {\n                    verticalAlign = 'bottom'; // top part\n                }\n                else if (angle > 135 && angle < 225) {\n                    verticalAlign = 'top'; // bottom part\n                }\n                else {\n                    verticalAlign = 'middle'; // left or right\n                }\n                options.verticalAlign = verticalAlign;\n            }\n            return options;\n        }\n        /**\n         * #6212 Calculate connectors for spline series in polar chart.\n         * @private\n         * @param {boolean} calculateNeighbours\n         *        Check if connectors should be calculated for neighbour points as\n         *        well allows short recurence\n         */\n        function getConnectors(segment, index, calculateNeighbours, connectEnds) {\n            var smoothing = 1.5,\n                denom = smoothing + 1,\n                addedNumber = connectEnds ? 1 : 0;\n            var i,\n                leftContX,\n                leftContY,\n                rightContX,\n                rightContY,\n                jointAngle;\n            // Calculate final index of points depending on the initial index value.\n            // Because of calculating neighbours, index may be outisde segment\n            // array.\n            if (index >= 0 && index <= segment.length - 1) {\n                i = index;\n            }\n            else if (index < 0) {\n                i = segment.length - 1 + index;\n            }\n            else {\n                i = 0;\n            }\n            // 1 means control points midway between points, 2 means 1/3 from\n            // the point, 3 is 1/4 etc;\n            var prevPointInd = ((i - 1 < 0) ? segment.length - (1 + addedNumber) : i - 1),\n                nextPointInd = (i + 1 > segment.length - 1) ? addedNumber : i + 1,\n                previousPoint = segment[prevPointInd],\n                nextPoint = segment[nextPointInd],\n                previousX = previousPoint.plotX,\n                previousY = previousPoint.plotY,\n                nextX = nextPoint.plotX,\n                nextY = nextPoint.plotY,\n                plotX = segment[i].plotX, // actual point\n                plotY = segment[i].plotY;\n            leftContX = (smoothing * plotX + previousX) / denom;\n            leftContY = (smoothing * plotY + previousY) / denom;\n            rightContX = (smoothing * plotX + nextX) / denom;\n            rightContY = (smoothing * plotY + nextY) / denom;\n            // distance left control point\n            var dLControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2)),\n                dRControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2)),\n                leftContAngle = Math.atan2(leftContY - plotY,\n                leftContX - plotX),\n                rightContAngle = Math.atan2(rightContY - plotY,\n                rightContX - plotX);\n            jointAngle = (Math.PI / 2) + ((leftContAngle + rightContAngle) / 2);\n            // Ensure the right direction, jointAngle should be in the same quadrant\n            // as leftContAngle\n            if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {\n                jointAngle -= Math.PI;\n            }\n            // Find the corrected control points for a spline straight through the\n            // point\n            leftContX = plotX + Math.cos(jointAngle) * dLControlPoint;\n            leftContY = plotY + Math.sin(jointAngle) * dLControlPoint;\n            rightContX = plotX + Math.cos(Math.PI + jointAngle) * dRControlPoint;\n            rightContY = plotY + Math.sin(Math.PI + jointAngle) * dRControlPoint;\n            // push current point's connectors into returned object\n            var ret = {\n                    rightContX: rightContX,\n                    rightContY: rightContY,\n                    leftContX: leftContX,\n                    leftContY: leftContY,\n                    plotX: plotX,\n                    plotY: plotY\n                };\n            // calculate connectors for previous and next point and push them inside\n            // returned object\n            if (calculateNeighbours) {\n                ret.prevPointCont = getConnectors(segment, prevPointInd, false, connectEnds);\n            }\n            return ret;\n        }\n        function onChartAfterDrawChartBox() {\n            (this.pane || []).forEach(function (pane) {\n                pane.render();\n            });\n        }\n        /**\n         * If polar has polygonal grid lines, force start and endOnTick on radial axis\n         * @private\n         */\n        function onChartAfterInit(event) {\n            var xAxis = event.args[0].xAxis,\n                yAxis = event.args[0].yAxis,\n                chart = event.args[0].chart;\n            if (xAxis && yAxis) {\n                if (yAxis.gridLineInterpolation === 'polygon') {\n                    xAxis.startOnTick = true;\n                    xAxis.endOnTick = true;\n                }\n                else if (xAxis.gridLineInterpolation === 'polygon' &&\n                    chart.inverted) {\n                    yAxis.startOnTick = true;\n                    yAxis.endOnTick = true;\n                }\n            }\n        }\n        function onChartGetAxes() {\n            var _this = this;\n            if (!this.pane) {\n                this.pane = [];\n            }\n            this.options.pane = splat(this.options.pane);\n            this.options.pane.forEach(function (paneOptions) {\n                new Pane(// eslint-disable-line no-new\n                paneOptions, _this);\n            }, this);\n        }\n        /**\n         * Get selection dimensions\n         * @private\n         */\n        function onPointerGetSelectionBox(event) {\n            var marker = event.args.marker,\n                xAxis = this.chart.xAxis[0],\n                yAxis = this.chart.yAxis[0],\n                inverted = this.chart.inverted,\n                radialAxis = inverted ? yAxis : xAxis,\n                linearAxis = inverted ? xAxis : yAxis;\n            if (this.chart.polar) {\n                event.preventDefault();\n                var start = (marker.attr ? marker.attr('start') : marker.start) - radialAxis.startAngleRad;\n                var r = (marker.attr ? marker.attr('r') : marker.r);\n                var end = (marker.attr ? marker.attr('end') : marker.end) - radialAxis.startAngleRad;\n                var innerR = (marker.attr ? marker.attr('innerR') : marker.innerR);\n                event.result.x = start + radialAxis.pos;\n                event.result.width = end - start;\n                // innerR goes from pane's center but toValue computes values from top\n                event.result.y = linearAxis.len + linearAxis.pos - innerR;\n                event.result.height = innerR - r;\n            }\n        }\n        /**\n         * Get attrs for Polar selection marker\n         * @private\n         */\n        function onPointerGetSelectionMarkerAttrs(event) {\n            var chart = this.chart;\n            if (chart.polar && chart.hoverPane && chart.hoverPane.axis) {\n                event.preventDefault();\n                var center = chart.hoverPane.center,\n                    mouseDownX = (this.mouseDownX || 0),\n                    mouseDownY = (this.mouseDownY || 0),\n                    chartY = event.args.chartY,\n                    chartX = event.args.chartX,\n                    fullCircle = Math.PI * 2,\n                    startAngleRad = chart.hoverPane.axis.startAngleRad,\n                    endAngleRad = chart.hoverPane.axis.endAngleRad,\n                    linearAxis = chart.inverted ? chart.xAxis[0] : chart.yAxis[0],\n                    attrs = {};\n                var shapeType = 'arc';\n                attrs.x = center[0] + chart.plotLeft;\n                attrs.y = center[1] + chart.plotTop;\n                // Adjust the width of the selection marker\n                if (this.zoomHor) {\n                    var paneRadRange = startAngleRad > 0 ?\n                            endAngleRad - startAngleRad :\n                            Math.abs(startAngleRad) + Math.abs(endAngleRad);\n                    var startAngle = Math.atan2(mouseDownY - chart.plotTop - center[1],\n                        mouseDownX - chart.plotLeft - center[0]) - startAngleRad,\n                        endAngle = Math.atan2(chartY - chart.plotTop - center[1],\n                        chartX - chart.plotLeft - center[0]) - startAngleRad;\n                    attrs.r = center[2] / 2;\n                    attrs.innerR = center[3] / 2;\n                    if (startAngle <= 0) {\n                        startAngle += fullCircle;\n                    }\n                    if (endAngle <= 0) {\n                        endAngle += fullCircle;\n                    }\n                    if (endAngle < startAngle) {\n                        // Swapping angles\n                        endAngle = [startAngle, startAngle = endAngle][0];\n                    }\n                    // If pane is not a full circle we need to let users zoom to the min\n                    // We do this by swapping angles after pointer crosses\n                    // middle angle (swapAngle) of the missing slice of the pane\n                    if (paneRadRange < fullCircle) {\n                        var swapAngle = endAngleRad + (fullCircle - paneRadRange) / 2;\n                        if (startAngleRad + endAngle > swapAngle) {\n                            endAngle = startAngle;\n                            startAngle = startAngleRad <= 0 ? startAngleRad : 0;\n                        }\n                    }\n                    var start = attrs.start =\n                            Math.max(startAngle + startAngleRad,\n                        startAngleRad),\n                        end = attrs.end =\n                            Math.min(endAngle + startAngleRad,\n                        endAngleRad);\n                    // Adjust the selection shape for polygon grid lines\n                    if (linearAxis.options.gridLineInterpolation === 'polygon') {\n                        var radialAxis = chart.hoverPane.axis,\n                            tickInterval = radialAxis.tickInterval,\n                            min = start - radialAxis.startAngleRad + radialAxis.pos,\n                            max = end - start;\n                        var path = linearAxis.getPlotLinePath({\n                                value: linearAxis.max\n                            }),\n                            pathStart = radialAxis.toValue(min),\n                            pathEnd = radialAxis.toValue(min + max);\n                        if (pathStart < radialAxis.getExtremes().min) {\n                            var _a = radialAxis.getExtremes(),\n                                min_1 = _a.min,\n                                max_1 = _a.max;\n                            pathStart = max_1 - (min_1 - pathStart);\n                        }\n                        if (pathEnd < radialAxis.getExtremes().min) {\n                            var _b = radialAxis.getExtremes(),\n                                min_2 = _b.min,\n                                max_2 = _b.max;\n                            pathEnd = max_2 - (min_2 - pathEnd);\n                        }\n                        if (pathEnd < pathStart) {\n                            // Swapping angles\n                            pathEnd = [pathStart, pathStart = pathEnd][0];\n                        }\n                        // Get trimmed path\n                        path = trimPath(path, pathStart, pathEnd, radialAxis);\n                        // Add center to the path\n                        path.push([\n                            'L', center[0] + chart.plotLeft,\n                            chart.plotTop + center[1]\n                        ]);\n                        attrs.d = path;\n                        shapeType = 'path';\n                    }\n                }\n                // Adjust the height of the selection marker\n                if (this.zoomVert) {\n                    var linearAxis_1 = chart.inverted ? chart.xAxis[0] : chart.yAxis[0];\n                    var innerR = Math.sqrt(Math.pow(mouseDownX - chart.plotLeft - center[0], 2) +\n                            Math.pow(mouseDownY - chart.plotTop - center[1], 2)),\n                        r = Math.sqrt(Math.pow(chartX - chart.plotLeft - center[0], 2) +\n                            Math.pow(chartY - chart.plotTop - center[1], 2));\n                    if (r < innerR) {\n                        // Swapping angles\n                        innerR = [r, r = innerR][0];\n                    }\n                    if (r > center[2] / 2) {\n                        r = center[2] / 2;\n                    }\n                    if (innerR < center[3] / 2) {\n                        innerR = center[3] / 2;\n                    }\n                    if (!this.zoomHor) {\n                        attrs.start = startAngleRad;\n                        attrs.end = endAngleRad;\n                    }\n                    attrs.r = r;\n                    attrs.innerR = innerR;\n                    if (linearAxis_1.options.gridLineInterpolation === 'polygon') {\n                        var end = linearAxis_1.toValue(linearAxis_1.len + linearAxis_1.pos - innerR),\n                            start = linearAxis_1.toValue(linearAxis_1.len + linearAxis_1.pos - r),\n                            path = linearAxis_1.getPlotLinePath({\n                                value: start\n                            }).concat(linearAxis_1.getPlotLinePath({\n                                value: end,\n                                reverse: true\n                            }));\n                        attrs.d = path;\n                        shapeType = 'path';\n                    }\n                }\n                if (this.zoomHor &&\n                    this.zoomVert &&\n                    linearAxis.options.gridLineInterpolation === 'polygon') {\n                    var radialAxis = chart.hoverPane.axis,\n                        start = attrs.start || 0,\n                        end = attrs.end || 0,\n                        min = start - radialAxis.startAngleRad + radialAxis.pos,\n                        max = end - start,\n                        pathStart = radialAxis.toValue(min),\n                        pathEnd = radialAxis.toValue(min + max);\n                    // Trim path\n                    if (attrs.d instanceof Array) {\n                        var innerPath = attrs.d.slice(0,\n                            attrs.d.length / 2),\n                            outerPath = attrs.d.slice(attrs.d.length / 2,\n                            attrs.d.length);\n                        outerPath = __spreadArray([], outerPath, true).reverse();\n                        var radialAxis_1 = chart.hoverPane.axis;\n                        innerPath = trimPath(innerPath, pathStart, pathEnd, radialAxis_1);\n                        outerPath = trimPath(outerPath, pathStart, pathEnd, radialAxis_1);\n                        if (outerPath) {\n                            (outerPath[0][0]) = 'L';\n                        }\n                        outerPath = __spreadArray([], outerPath, true).reverse();\n                        attrs.d = innerPath.concat(outerPath);\n                        shapeType = 'path';\n                    }\n                }\n                event.attrs = attrs;\n                event.shapeType = shapeType;\n            }\n        }\n        /**\n         * @private\n         */\n        function onSeriesAfterInit() {\n            var chart = this.chart;\n            if (chart.polar) {\n                this.polar = new PolarAdditions(this);\n                // Add flags that identifies radial inverted series\n                if (chart.inverted) {\n                    this.isRadialSeries = true;\n                    if (this.is('column')) {\n                        this.isRadialBar = true;\n                    }\n                }\n            }\n        }\n        /**\n         * Extend translate. The plotX and plotY values are computed as if the polar\n         * chart were a cartesian plane, where plotX denotes the angle in radians\n         * and (yAxis.len - plotY) is the pixel distance from center.\n         * @private\n         */\n        function onSeriesAfterTranslate() {\n            if (this.chart.polar && this.xAxis) {\n                var series = this,\n                    chart_1 = series.chart;\n                // Prepare k-d-tree handling. It searches by angle (clientX) in\n                // case of shared tooltip, and by two dimensional distance in case\n                // of non-shared.\n                series.kdByAngle = chart_1.tooltip && chart_1.tooltip.shared;\n                if (series.kdByAngle) {\n                    series.searchPoint = searchPointByAngle;\n                }\n                else {\n                    series.options.findNearestPointBy = 'xy';\n                }\n                var points = series.points;\n                var i = points.length;\n                while (i--) {\n                    // Translate plotX, plotY from angle and radius to true plot\n                    // coordinates\n                    if (!series.preventPostTranslate) {\n                        series.polar.toXY(points[i]);\n                    }\n                    // Treat points below Y axis min as null (#10082)\n                    if (!chart_1.hasParallelCoordinates &&\n                        !series.yAxis.reversed) {\n                        if (pick(points[i].y, Number.MIN_VALUE) < series.yAxis.min ||\n                            points[i].x < series.xAxis.min ||\n                            points[i].x > series.xAxis.max) {\n                            // Destroy markers\n                            points[i].isNull = true;\n                            // Destroy column's graphic\n                            points[i].plotY = NaN;\n                        }\n                        else {\n                            // Restore isNull flag\n                            points[i].isNull =\n                                points[i].isValid && !points[i].isValid();\n                        }\n                    }\n                }\n                // Perform clip after render\n                if (!this.hasClipCircleSetter) {\n                    this.hasClipCircleSetter = !!series.eventsToUnbind.push(addEvent(series, 'afterRender', function () {\n                        var circ;\n                        if (chart_1.polar) {\n                            // For clipping purposes there is a need for\n                            // coordinates from the absolute center\n                            circ = this.yAxis.pane.center;\n                            if (!this.clipCircle) {\n                                this.clipCircle = clipCircle(chart_1.renderer, circ[0], circ[1], circ[2] / 2, circ[3] / 2);\n                            }\n                            else {\n                                this.clipCircle.animate({\n                                    x: circ[0],\n                                    y: circ[1],\n                                    r: circ[2] / 2,\n                                    innerR: circ[3] / 2\n                                });\n                            }\n                            this.group.clip(this.clipCircle);\n                            this.setClip = H.noop;\n                        }\n                    }));\n                }\n            }\n        }\n        /**\n         * Search a k-d tree by the point angle, used for shared tooltips in polar\n         * charts\n         * @private\n         */\n        function searchPointByAngle(e) {\n            var series = this,\n                chart = series.chart,\n                xAxis = series.xAxis,\n                center = xAxis.pane && xAxis.pane.center,\n                plotX = e.chartX - (center && center[0] || 0) - chart.plotLeft,\n                plotY = e.chartY - (center && center[1] || 0) - chart.plotTop;\n            return series.searchKDTree({\n                clientX: 180 + (Math.atan2(plotX, plotY) * (-180 / Math.PI))\n            });\n        }\n        /**\n         * Trim polygonal path\n         * @private\n         */\n        function trimPath(path, start, end, radialAxis) {\n            var tickInterval = radialAxis.tickInterval,\n                ticks = radialAxis.tickPositions;\n            var lastTick = find(ticks,\n                function (tick) { return tick >= end; }),\n                firstTick = find(__spreadArray([],\n                ticks,\n                true).reverse(),\n                function (tick) { return tick <= start; });\n            if (!defined(lastTick)) {\n                lastTick = ticks[ticks.length - 1];\n            }\n            if (!defined(firstTick)) {\n                firstTick = ticks[0];\n                lastTick += tickInterval;\n                path[0][0] = 'L';\n                // To do: figure out why -3 or -2\n                path.unshift(path[path.length - 3]);\n            }\n            path = path.slice(ticks.indexOf(firstTick), ticks.indexOf(lastTick) + 1);\n            path[0][0] = 'M';\n            return path;\n        }\n        /**\n         * Extend chart.get to also search in panes. Used internally in\n         * responsiveness and chart.update.\n         * @private\n         */\n        function wrapChartGet(proceed, id) {\n            return find(this.pane || [], function (pane) {\n                // @todo remove id or define id type:\n                return pane.options.id === id;\n            }) || proceed.call(this, id);\n        }\n        /**\n         * Align column data labels outside the columns. #1199.\n         * @private\n         */\n        function wrapColumnSeriesAlignDataLabel(proceed, point, dataLabel, options, alignTo, isNew) {\n            var chart = this.chart,\n                inside = pick(options.inside, !!this.options.stacking);\n            var angle,\n                shapeArgs,\n                labelPos;\n            if (chart.polar) {\n                angle = point.rectPlotX / Math.PI * 180;\n                if (!chart.inverted) {\n                    // Align nicely outside the perimeter of the columns\n                    options = findAlignments(angle, options);\n                }\n                else { // Required corrections for data labels of inverted bars\n                    // The plotX and plotY are correctly set therefore they\n                    // don't need to be swapped (inverted argument is false)\n                    this.forceDL = chart.isInsidePlot(point.plotX, point.plotY);\n                    // Checks if labels should be positioned inside\n                    if (inside && point.shapeArgs) {\n                        shapeArgs = point.shapeArgs;\n                        // Calculates pixel positions for a data label to be\n                        // inside\n                        labelPos =\n                            this.yAxis.postTranslate(\n                            // angle\n                            ((shapeArgs.start || 0) + (shapeArgs.end || 0)) / 2 -\n                                this\n                                    .xAxis.startAngleRad, \n                            // radius\n                            point.barX +\n                                point.pointWidth / 2);\n                        alignTo = {\n                            x: labelPos.x - chart.plotLeft,\n                            y: labelPos.y - chart.plotTop\n                        };\n                    }\n                    else if (point.tooltipPos) {\n                        alignTo = {\n                            x: point.tooltipPos[0],\n                            y: point.tooltipPos[1]\n                        };\n                    }\n                    options.align = pick(options.align, 'center');\n                    options.verticalAlign =\n                        pick(options.verticalAlign, 'middle');\n                }\n                Object\n                    .getPrototypeOf(Object.getPrototypeOf(this))\n                    .alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);\n                // Hide label of a point (only inverted) that is outside the\n                // visible y range\n                if (this.isRadialBar && point.shapeArgs &&\n                    point.shapeArgs.start === point.shapeArgs.end) {\n                    dataLabel.hide();\n                }\n                else {\n                    dataLabel.show();\n                }\n            }\n            else {\n                proceed.call(this, point, dataLabel, options, alignTo, isNew);\n            }\n        }\n        /**\n         * Extend the column prototype's translate method\n         * @private\n         */\n        function wrapColumnSeriesTranslate(proceed) {\n            var series = this,\n                options = series.options,\n                stacking = options.stacking,\n                chart = series.chart,\n                xAxis = series.xAxis,\n                yAxis = series.yAxis,\n                reversed = yAxis.reversed,\n                center = yAxis.center,\n                startAngleRad = xAxis.startAngleRad,\n                endAngleRad = xAxis.endAngleRad,\n                visibleRange = endAngleRad - startAngleRad;\n            var threshold = options.threshold,\n                thresholdAngleRad = 0,\n                points,\n                point,\n                i,\n                yMin,\n                yMax,\n                start = 0,\n                end = 0,\n                tooltipPos,\n                pointX,\n                pointY,\n                stackValues,\n                stack,\n                barX,\n                innerR,\n                r;\n            series.preventPostTranslate = true;\n            // Run uber method\n            proceed.call(series);\n            // Postprocess plot coordinates\n            if (xAxis.isRadial) {\n                points = series.points;\n                i = points.length;\n                yMin = yAxis.translate(yAxis.min);\n                yMax = yAxis.translate(yAxis.max);\n                threshold = options.threshold || 0;\n                if (chart.inverted) {\n                    // Finding a correct threshold\n                    if (isNumber(threshold)) {\n                        thresholdAngleRad = yAxis.translate(threshold);\n                        // Checks if threshold is outside the visible range\n                        if (defined(thresholdAngleRad)) {\n                            if (thresholdAngleRad < 0) {\n                                thresholdAngleRad = 0;\n                            }\n                            else if (thresholdAngleRad > visibleRange) {\n                                thresholdAngleRad = visibleRange;\n                            }\n                            // Adding start angle offset\n                            series.translatedThreshold =\n                                thresholdAngleRad + startAngleRad;\n                        }\n                    }\n                }\n                while (i--) {\n                    point = points[i];\n                    barX = point.barX;\n                    pointX = point.x;\n                    pointY = point.y;\n                    point.shapeType = 'arc';\n                    if (chart.inverted) {\n                        point.plotY = yAxis.translate(pointY);\n                        if (stacking && yAxis.stacking) {\n                            stack = yAxis.stacking.stacks[(pointY < 0 ? '-' : '') +\n                                series.stackKey];\n                            if (series.visible && stack && stack[pointX]) {\n                                if (!point.isNull) {\n                                    stackValues = stack[pointX].points[series.getStackIndicator(void 0, pointX, series.index).key];\n                                    // Translating to radial values\n                                    start = yAxis.translate(stackValues[0]);\n                                    end = yAxis.translate(stackValues[1]);\n                                    // If starting point is beyond the\n                                    // range, set it to 0\n                                    if (defined(start)) {\n                                        start = U.clamp(start, 0, visibleRange);\n                                    }\n                                }\n                            }\n                        }\n                        else {\n                            // Initial start and end angles for radial bar\n                            start = thresholdAngleRad;\n                            end = point.plotY;\n                        }\n                        if (start > end) {\n                            // Swapping start and end\n                            end = [start, start = end][0];\n                        }\n                        // Prevent from rendering point outside the\n                        // acceptable circular range\n                        if (!reversed) {\n                            if (start < yMin) {\n                                start = yMin;\n                            }\n                            else if (end > yMax) {\n                                end = yMax;\n                            }\n                            else if (end < yMin || start > yMax) {\n                                start = end = 0;\n                            }\n                        }\n                        else {\n                            if (end > yMin) {\n                                end = yMin;\n                            }\n                            else if (start < yMax) {\n                                start = yMax;\n                            }\n                            else if (start > yMin || end < yMax) {\n                                start = end = visibleRange;\n                            }\n                        }\n                        if (yAxis.min > yAxis.max) {\n                            start = end = reversed ? visibleRange : 0;\n                        }\n                        start += startAngleRad;\n                        end += startAngleRad;\n                        if (center) {\n                            point.barX = barX += center[3] / 2;\n                        }\n                        // In case when radius, inner radius or both are\n                        // negative, a point is rendered but partially or as\n                        // a center point\n                        innerR = Math.max(barX, 0);\n                        r = Math.max(barX + point.pointWidth, 0);\n                        point.shapeArgs = {\n                            x: center && center[0],\n                            y: center && center[1],\n                            r: r,\n                            innerR: innerR,\n                            start: start,\n                            end: end\n                        };\n                        // Fade out the points if not inside the polar \"plot area\"\n                        point.opacity = start === end ? 0 : void 0;\n                        // A correct value for stacked or not fully visible\n                        // point\n                        point.plotY = (defined(series.translatedThreshold) &&\n                            (start < series.translatedThreshold ? start : end)) -\n                            startAngleRad;\n                    }\n                    else {\n                        start = barX + startAngleRad;\n                        // Changed the way polar columns are drawn in order to make\n                        // it more consistent with the drawing of inverted columns\n                        // (they are using the same function now). Also, it was\n                        // essential to make the animation work correctly (the\n                        // scaling of the group) is replaced by animating each\n                        // element separately.\n                        point.shapeArgs = series.polar.arc(point.yBottom, point.plotY, start, start + point.pointWidth);\n                    }\n                    // Provided a correct coordinates for the tooltip\n                    series.polar.toXY(point);\n                    if (chart.inverted) {\n                        tooltipPos = yAxis.postTranslate(point.rectPlotY, barX + point.pointWidth / 2);\n                        point.tooltipPos = [\n                            tooltipPos.x - chart.plotLeft,\n                            tooltipPos.y - chart.plotTop\n                        ];\n                    }\n                    else {\n                        point.tooltipPos = [point.plotX, point.plotY];\n                    }\n                    if (center) {\n                        point.ttBelow = point.plotY > center[1];\n                    }\n                }\n            }\n        }\n        /**\n         * Extend getSegmentPath to allow connecting ends across 0 to provide a\n         * closed circle in line-like series.\n         * @private\n         */\n        function wrapLineSeriesGetGraphPath(proceed, points) {\n            var series = this;\n            var firstValid,\n                popLastPoint;\n            // Connect the path\n            if (this.chart.polar) {\n                points = points || this.points;\n                // Append first valid point in order to connect the ends\n                for (var i = 0; i < points.length; i++) {\n                    if (!points[i].isNull) {\n                        firstValid = i;\n                        break;\n                    }\n                }\n                /**\n                 * Polar charts only. Whether to connect the ends of a line series\n                 * plot across the extremes.\n                 *\n                 * @sample {highcharts} highcharts/plotoptions/line-connectends-false/\n                 *         Do not connect\n                 *\n                 * @type      {boolean}\n                 * @since     2.3.0\n                 * @product   highcharts\n                 * @apioption plotOptions.series.connectEnds\n                 */\n                if (this.options.connectEnds !== false &&\n                    typeof firstValid !== 'undefined') {\n                    this.connectEnds = true; // re-used in splines\n                    points.splice(points.length, 0, points[firstValid]);\n                    popLastPoint = true;\n                }\n                // For area charts, pseudo points are added to the graph, now we\n                // need to translate these\n                points.forEach(function (point) {\n                    if (typeof point.polarPlotY === 'undefined') {\n                        series.polar.toXY(point);\n                    }\n                });\n            }\n            // Run uber method\n            var ret = proceed.apply(this,\n                [].slice.call(arguments, 1));\n            // #6212 points.splice method is adding points to an array. In case of\n            // areaspline getGraphPath method is used two times and in both times\n            // points are added to an array. That is why points.pop is used, to get\n            // unmodified points.\n            if (popLastPoint) {\n                points.pop();\n            }\n            return ret;\n        }\n        /**\n         * Extend getCoordinates to prepare for polar axis values\n         * @private\n         */\n        function wrapPointerGetCoordinates(proceed, e) {\n            var chart = this.chart;\n            var ret = {\n                    xAxis: [],\n                    yAxis: []\n                };\n            if (chart.polar) {\n                chart.axes.forEach(function (axis) {\n                    // Skip colorAxis\n                    if (axis.coll === 'colorAxis') {\n                        return;\n                    }\n                    var isXAxis = axis.isXAxis,\n                        center = axis.center,\n                        x = e.chartX - center[0] - chart.plotLeft,\n                        y = e.chartY - center[1] - chart.plotTop;\n                    ret[isXAxis ? 'xAxis' : 'yAxis'].push({\n                        axis: axis,\n                        value: axis.translate(isXAxis ?\n                            Math.PI - Math.atan2(x, y) : // angle\n                            // distance from center\n                            Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)), true)\n                    });\n                });\n            }\n            else {\n                ret = proceed.call(this, e);\n            }\n            return ret;\n        }\n        /**\n         * Prevent zooming on mobile devices\n         * @private\n         */\n        function wrapPointerPinch(proceed, e) {\n            if (this.chart.polar) {\n                return;\n            }\n            proceed.call(this, e);\n        }\n        /**\n         * Define the animate method for regular series\n         * @private\n         */\n        function wrapSeriesAnimate(proceed, init) {\n            var series = this,\n                chart = this.chart,\n                group = this.group,\n                markerGroup = this.markerGroup,\n                center = this.xAxis && this.xAxis.center,\n                plotLeft = chart.plotLeft,\n                plotTop = chart.plotTop;\n            var animation = this.options.animation,\n                attribs,\n                paneInnerR,\n                graphic,\n                shapeArgs,\n                r,\n                innerR;\n            // Specific animation for polar charts\n            if (chart.polar) {\n                if (series.isRadialBar) {\n                    if (!init) {\n                        // Run the pie animation for radial bars\n                        series.startAngleRad = pick(series.translatedThreshold, series.xAxis.startAngleRad);\n                        H.seriesTypes.pie.prototype.animate.call(series, init);\n                    }\n                }\n                else {\n                    // Enable animation on polar charts only in SVG. In VML, the scaling\n                    // is different, plus animation would be so slow it would't matter.\n                    if (chart.renderer.isSVG) {\n                        animation = animObject(animation);\n                        // A different animation needed for column like series\n                        if (series.is('column')) {\n                            if (!init) {\n                                paneInnerR = center[3] / 2;\n                                series.points.forEach(function (point) {\n                                    graphic = point.graphic;\n                                    shapeArgs = point.shapeArgs;\n                                    r = shapeArgs && shapeArgs.r;\n                                    innerR = shapeArgs && shapeArgs.innerR;\n                                    if (graphic && shapeArgs) {\n                                        // start values\n                                        graphic.attr({\n                                            r: paneInnerR,\n                                            innerR: paneInnerR\n                                        });\n                                        // animate\n                                        graphic.animate({\n                                            r: r,\n                                            innerR: innerR\n                                        }, series.options.animation);\n                                    }\n                                });\n                            }\n                        }\n                        else {\n                            // Initialize the animation\n                            if (init) {\n                                // Scale down the group and place it in the center\n                                attribs = {\n                                    translateX: center[0] + plotLeft,\n                                    translateY: center[1] + plotTop,\n                                    scaleX: 0.001,\n                                    scaleY: 0.001\n                                };\n                                group.attr(attribs);\n                                if (markerGroup) {\n                                    markerGroup.attr(attribs);\n                                }\n                                // Run the animation\n                            }\n                            else {\n                                attribs = {\n                                    translateX: plotLeft,\n                                    translateY: plotTop,\n                                    scaleX: 1,\n                                    scaleY: 1\n                                };\n                                group.animate(attribs, animation);\n                                if (markerGroup) {\n                                    markerGroup.animate(attribs, animation);\n                                }\n                            }\n                        }\n                    }\n                }\n                // For non-polar charts, revert to the basic animation\n            }\n            else {\n                proceed.call(this, init);\n            }\n        }\n        /**\n         * Overridden method for calculating a spline from one point to the next\n         * @private\n         */\n        function wrapSplineSeriesGetPointSpline(proceed, segment, point, i) {\n            var ret,\n                connectors;\n            if (this.chart.polar) {\n                // moveTo or lineTo\n                if (!i) {\n                    ret = ['M', point.plotX, point.plotY];\n                }\n                else { // curve from last point to this\n                    connectors = getConnectors(segment, i, true, this.connectEnds);\n                    var rightContX = connectors.prevPointCont &&\n                            connectors.prevPointCont.rightContX;\n                    var rightContY = connectors.prevPointCont &&\n                            connectors.prevPointCont.rightContY;\n                    ret = [\n                        'C',\n                        isNumber(rightContX) ? rightContX : connectors.plotX,\n                        isNumber(rightContY) ? rightContY : connectors.plotY,\n                        isNumber(connectors.leftContX) ?\n                            connectors.leftContX :\n                            connectors.plotX,\n                        isNumber(connectors.leftContY) ?\n                            connectors.leftContY :\n                            connectors.plotY,\n                        connectors.plotX,\n                        connectors.plotY\n                    ];\n                }\n            }\n            else {\n                ret = proceed.call(this, segment, point, i);\n            }\n            return ret;\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Extensions for polar charts. Additionally, much of the geometry required\n         * for polar charts is gathered in RadialAxes.js.\n         * @private\n         */\n        var PolarAdditions = /** @class */ (function () {\n                /* *\n                 *\n                 *  Constructor\n                 *\n                 * */\n                function PolarAdditions(series) {\n                    this.series = series;\n            }\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            PolarAdditions.compose = function (AxisClass, ChartClass, PointerClass, SeriesClass, TickClass, AreaSplineRangeSeriesClass, ColumnSeriesClass, LineSeriesClass, SplineSeriesClass) {\n                RadialAxis.compose(AxisClass, TickClass);\n                if (composedClasses.indexOf(ChartClass) === -1) {\n                    composedClasses.push(ChartClass);\n                    addEvent(ChartClass, 'afterDrawChartBox', onChartAfterDrawChartBox);\n                    addEvent(ChartClass, 'getAxes', onChartGetAxes);\n                    addEvent(ChartClass, 'init', onChartAfterInit);\n                    var chartProto = ChartClass.prototype;\n                    wrap(chartProto, 'get', wrapChartGet);\n                }\n                if (composedClasses.indexOf(PointerClass) === -1) {\n                    composedClasses.push(PointerClass);\n                    var pointerProto = PointerClass.prototype;\n                    wrap(pointerProto, 'getCoordinates', wrapPointerGetCoordinates);\n                    wrap(pointerProto, 'pinch', wrapPointerPinch);\n                    addEvent(PointerClass, 'getSelectionMarkerAttrs', onPointerGetSelectionMarkerAttrs);\n                    addEvent(PointerClass, 'getSelectionBox', onPointerGetSelectionBox);\n                }\n                if (composedClasses.indexOf(SeriesClass) === -1) {\n                    composedClasses.push(SeriesClass);\n                    addEvent(SeriesClass, 'afterInit', onSeriesAfterInit);\n                    addEvent(SeriesClass, 'afterTranslate', onSeriesAfterTranslate, { order: 2 } // Run after translation of ||-coords\n                    );\n                    var seriesProto = SeriesClass.prototype;\n                    wrap(seriesProto, 'animate', wrapSeriesAnimate);\n                }\n                if (ColumnSeriesClass &&\n                    composedClasses.indexOf(ColumnSeriesClass) === -1) {\n                    composedClasses.push(ColumnSeriesClass);\n                    var columnProto = ColumnSeriesClass.prototype;\n                    wrap(columnProto, 'alignDataLabel', wrapColumnSeriesAlignDataLabel);\n                    wrap(columnProto, 'animate', wrapSeriesAnimate);\n                    wrap(columnProto, 'translate', wrapColumnSeriesTranslate);\n                }\n                if (LineSeriesClass &&\n                    composedClasses.indexOf(LineSeriesClass) === -1) {\n                    composedClasses.push(LineSeriesClass);\n                    var lineProto = LineSeriesClass.prototype;\n                    wrap(lineProto, 'getGraphPath', wrapLineSeriesGetGraphPath);\n                }\n                if (SplineSeriesClass &&\n                    composedClasses.indexOf(SplineSeriesClass) === -1) {\n                    composedClasses.push(SplineSeriesClass);\n                    var splineProto = SplineSeriesClass.prototype;\n                    wrap(splineProto, 'getPointSpline', wrapSplineSeriesGetPointSpline);\n                    if (AreaSplineRangeSeriesClass &&\n                        composedClasses.indexOf(AreaSplineRangeSeriesClass) === -1) {\n                        composedClasses.push(AreaSplineRangeSeriesClass);\n                        var areaSplineRangeProto = AreaSplineRangeSeriesClass.prototype;\n                        // #6430 Areasplinerange series use unwrapped getPointSpline\n                        // method, so we need to set this method again.\n                        areaSplineRangeProto.getPointSpline =\n                            splineProto.getPointSpline;\n                    }\n                }\n            };\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            PolarAdditions.prototype.arc = function (low, high, start, end) {\n                var series = this.series,\n                    center = series.xAxis.center,\n                    len = series.yAxis.len,\n                    paneInnerR = center[3] / 2;\n                var r = len - high + paneInnerR,\n                    innerR = len - pick(low,\n                    len) + paneInnerR;\n                // Prevent columns from shooting through the pane's center\n                if (series.yAxis.reversed) {\n                    if (r < 0) {\n                        r = paneInnerR;\n                    }\n                    if (innerR < 0) {\n                        innerR = paneInnerR;\n                    }\n                }\n                // Return a new shapeArgs\n                return {\n                    x: center[0],\n                    y: center[1],\n                    r: r,\n                    innerR: innerR,\n                    start: start,\n                    end: end\n                };\n            };\n            /**\n             * Translate a point's plotX and plotY from the internal angle and radius\n             * measures to true plotX, plotY coordinates\n             * @private\n             */\n            PolarAdditions.prototype.toXY = function (point) {\n                var series = this.series,\n                    chart = series.chart,\n                    xAxis = series.xAxis,\n                    yAxis = series.yAxis,\n                    plotX = point.plotX,\n                    inverted = chart.inverted,\n                    pointY = point.y;\n                var plotY = point.plotY,\n                    radius = inverted ? plotX : yAxis.len - plotY,\n                    clientX;\n                // Corrected y position of inverted series other than column\n                if (inverted && series && !series.isRadialBar) {\n                    point.plotY = plotY =\n                        isNumber(pointY) ? yAxis.translate(pointY) : 0;\n                }\n                // Save rectangular plotX, plotY for later computation\n                point.rectPlotX = plotX;\n                point.rectPlotY = plotY;\n                if (yAxis.center) {\n                    radius += yAxis.center[3] / 2;\n                }\n                // Find the polar plotX and plotY. Avoid setting plotX and plotY to NaN\n                // when plotY is undefined (#15438)\n                if (isNumber(plotY)) {\n                    var xy = inverted ? yAxis.postTranslate(plotY,\n                        radius) :\n                            xAxis.postTranslate(plotX,\n                        radius);\n                    point.plotX = point.polarPlotX = xy.x - chart.plotLeft;\n                    point.plotY = point.polarPlotY = xy.y - chart.plotTop;\n                }\n                // If shared tooltip, record the angle in degrees in order to align X\n                // points. Otherwise, use a standard k-d tree to get the nearest point\n                // in two dimensions.\n                if (series.kdByAngle) {\n                    clientX = ((plotX / Math.PI * 180) + xAxis.pane.options.startAngle) % 360;\n                    if (clientX < 0) { // #2665\n                        clientX += 360;\n                    }\n                    point.clientX = clientX;\n                }\n                else {\n                    point.clientX = point.plotX;\n                }\n            };\n            return PolarAdditions;\n        }());\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return PolarAdditions;\n    });\n    _registerModule(_modules, 'masters/highcharts-more.src.js', [_modules['Core/Globals.js'], _modules['Core/Series/SeriesRegistry.js'], _modules['Series/Bubble/BubbleSeries.js'], _modules['Series/PackedBubble/PackedBubbleSeries.js'], _modules['Series/PolarComposition.js']], function (Highcharts, SeriesRegistry, BubbleSeries, PackedBubbleSeries, PolarAdditions) {\n\n        var G = Highcharts;\n        BubbleSeries.compose(G.Axis, G.Chart, G.Legend, G.Series);\n        PackedBubbleSeries.compose(G.Axis, G.Chart, G.Legend, G.Series);\n        PolarAdditions.compose(G.Axis, G.Chart, G.Pointer, G.Series, G.Tick, SeriesRegistry.seriesTypes.areasplinerange, SeriesRegistry.seriesTypes.column, SeriesRegistry.seriesTypes.line, SeriesRegistry.seriesTypes.spline);\n\n    });\n}));"],
  "mappings": "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",
  "names": ["factory", "module", "exports", "define", "amd", "Highcharts", "undefined", "_registerModule", "obj", "path", "args", "fn", "hasOwnProperty", "apply", "CustomEvent", "window", "dispatchEvent", "detail", "_modules", "Chart", "CU", "H", "Pointer", "U", "isInsidePane", "x", "y", "center", "startAngle", "endAngle", "insideSlice", "cx", "cy", "distance", "Math", "sqrt", "pow", "defined", "angle", "atan2", "correctFloat", "PI", "ceil", "addEvent", "extend", "merge", "pick", "splat", "prototype", "collectionsWithUpdate", "push", "Pane", "options", "chart", "background", "coll", "defaultOptions", "size", "innerSize", "defaultBackgroundOptions", "shape", "borderWidth", "borderColor", "backgroundColor", "linearGradient", "x1", "y1", "x2", "y2", "stops", "from", "Number", "MAX_VALUE", "innerRadius", "to", "outerRadius", "init", "Pane.prototype.init", "pane", "setOptions", "Pane.prototype.setOptions", "angular", "render", "Pane.prototype.render", "backgroundOption", "renderer", "group", "g", "attr", "zIndex", "add", "updateCenter", "len", "max", "length", "i", "axis", "renderBackground", "destroy", "splice", "Pane.prototype.renderBackground", "backgroundOptions", "method", "attribs", "className", "styledMode", "getPlotBandPath", "Pane.prototype.updateCenter", "getCenter", "call", "update", "Pane.prototype.update", "redraw", "axes", "forEach", "getHoverPane", "Chart.prototype.getHoverPane", "eventArgs", "hoverPane", "chartX", "plotLeft", "chartY", "plotTop", "e", "polar", "inverted", "_a", "isInsidePlot", "some", "normalizedStartAngleRad", "normalizedEndAngleRad", "filter", "eventArgs.filter", "s", "visible", "shared", "directTouch", "enableMouseTracking", "xAxis", "hoverPoint", "plotX", "plotY", "SeriesRegistry", "__extends", "extendStatics", "d", "b", "Object", "setPrototypeOf", "__proto__", "Array", "p", "__", "constructor", "create", "seriesTypes", "area", "areaProto", "pointClass", "isNumber", "_super", "AreaRangePoint", "_this", "arguments", "high", "low", "series", "setState", "AreaRangePoint.prototype.setState", "prevState", "state", "isPolar", "plotHigh", "yAxis", "toPixels", "plotLow", "stateMarkerGraphic", "lowerStateMarkerGraphic", "upperStateMarkerGraphic", "graphic", "graphics", "plotHighX", "plotLowX", "haloPath", "AreaRangePoint.prototype.haloPath", "isInside", "isTopInside", "concat", "isValid", "AreaRangePoint.prototype.isValid", "noop", "AreaSeries", "columnProto", "column", "isArray", "areaRangeSeriesOptions", "lineWidth", "threshold", "tooltip", "pointFormat", "trackByArea", "dataLabels", "align", "verticalAlign", "xLow", "xHigh", "yLow", "yHigh", "AreaRangeSeries", "data", "points", "toYData", "AreaRangeSeries.prototype.toYData", "point", "highToXY", "AreaRangeSeries.prototype.highToXY", "xy", "postTranslate", "rectPlotX", "getGraphPath", "AreaRangeSeries.prototype.getGraphPath", "highPoints", "highAreaPoints", "connectEnds", "connectNulls", "step", "highAreaPoint", "yBottom", "doCurve", "isNull", "pointShim", "polarPlotY", "lowerPath", "left", "right", "higherPath", "higherAreaPath", "linePath", "graphPath", "areaPath", "isArea", "xMap", "drawDataLabels", "AreaRangeSeries.prototype.drawDataLabels", "originalDataLabels", "dataLabelOptions", "upperDataLabelOptions", "enabled", "lowerDataLabelOptions", "_hasPointLabels", "_b", "up", "inside", "_plotY", "dataLabel", "dataLabelUpper", "below", "_c", "_d", "label", "alignDataLabel", "AreaRangeSeries.prototype.alignDataLabel", "drawPoints", "AreaRangeSeries.prototype.drawPoints", "pointLength", "origProps", "negative", "zone", "zones", "getZone", "pointArrayMap", "join", "translate", "dataModify", "modifyValue", "order", "tooltipPos", "pos", "posHigh", "deferTranslatePolar", "pointValKey", "setStackedPoints", "registerSeriesType", "splineProto", "spline", "AreaSplineRangeSeries", "getPointSpline", "ColumnSeries", "BoxPlotSeries", "pointAttribs", "BoxPlotSeries.prototype.pointAttribs", "BoxPlotSeries.prototype.translate", "key", "highPlot", "BoxPlotSeries.prototype.drawPoints", "q1Plot", "q3Plot", "lowPlot", "medianPlot", "crispCorr", "crispX", "width", "halfWidth", "doQuartiles", "pointWiskerLength", "whiskerLength", "verb", "shapeArgs", "boxAttr", "stemAttr", "whiskersAttr", "medianAttr", "color", "round", "floor", "stem", "addClass", "whiskers", "box", "boxPath", "medianShape", "medianPath", "stroke", "stemColor", "stemWidth", "dashstyle", "stemDashStyle", "dashStyle", "whiskerColor", "whiskerWidth", "whiskerDashStyle", "fill", "fillColor", "lineColor", "boxDashStyle", "medianColor", "medianWidth", "medianDashStyle", "strokeWidth", "test", "parseFloat", "BoxPlotSeries.prototype.toYData", "q1", "median", "q3", "BubbleLegendDefaults", "connectorClassName", "connectorColor", "connectorDistance", "connectorWidth", "labels", "allowOverlap", "format", "formatter", "style", "fontSize", "maxSize", "minSize", "legendIndex", "ranges", "value", "sizeBy", "sizeByAbsoluteValue", "zThreshold", "Color", "F", "parse", "arrayMax", "arrayMin", "stableSort", "BubbleLegendItem", "legend", "symbols", "selected", "movementX", "maxLabel", "fontMetrics", "BubbleLegendItem.prototype.init", "addToLegend", "BubbleLegendItem.prototype.addToLegend", "items", "drawLegendSymbol", "BubbleLegendItem.prototype.drawLegendSymbol", "itemDistance", "legendItem", "a", "getMaxLabelSize", "radius", "connectorSpace", "labelWidth", "labelHeight", "h", "bubbleLegend", "autoRanges", "BubbleLegendItem.prototype.setOptions", "seriesIndex", "baseline", "bubbleAttribs", "connectorAttribs", "labelAttribs", "rtl", "fillOpacity", "marker", "range", "setOpacity", "get", "getRangeRadius", "BubbleLegendItem.prototype.getRangeRadius", "bubbleSeries", "getRadius", "BubbleLegendItem.prototype.render", "connectors", "bubbleItems", "symbol", "translateX", "_i", "translateY", "renderRange", "hideOverlappingLabels", "BubbleLegendItem.prototype.renderRange", "labelsOptions", "elementCenter", "absoluteRadius", "abs", "labelsAlign", "posX", "mainRange", "posY", "labelMovement", "f", "connectorLength", "labelY", "labelX", "circle", "colorIndex", "crispLine", "text", "formatLabel", "css", "placed", "alignAttr", "BubbleLegendItem.prototype.getMaxLabelSize", "labelSize", "getBBox", "BubbleLegendItem.prototype.formatLabel", "numberFormatter", "BubbleLegendItem.prototype.hideOverlappingLabels", "index", "newOpacity", "oldOpacity", "show", "hide", "getRanges", "BubbleLegendItem.prototype.getRanges", "rangesOptions", "zData", "minZ", "maxZ", "isBubble", "ignoreSeries", "zMin", "min", "displayNegative", "zMax", "reverse", "predictBubbleSizes", "BubbleLegendItem.prototype.predictBubbleSizes", "legendOptions", "floating", "lastLineHeight", "horizontal", "layout", "plotSizeX", "plotSizeY", "pxSizes", "getPxExtremes", "minPxSize", "maxPxSize", "plotSize", "calculatedSize", "updateRanges", "BubbleLegendItem.prototype.updateRanges", "bubbleLegendOptions", "correctSizes", "BubbleLegendItem.prototype.correctSizes", "D", "chartDrawChartBox", "proceed", "callback", "getVisibleBubbleSeriesIndex", "bubbleSizes", "allItems", "item", "getMargins", "setScale", "updateNames", "objectEach", "ticks", "tick", "isNew", "isNewLabel", "retranslateItems", "getLinesHeights", "lines", "j", "legendItem2", "itemHeight", "height", "lastLine", "onLegendAfterGetAllItems", "bubbleSeriesIndex", "destroyItem", "onSeriesLegendItemClick", "status", "orgTranslateX", "orgTranslateY", "actualLine", "wrap", "composedClasses", "BubbleLegendComposition", "compose", "ChartClass", "LegendClass", "SeriesClass", "indexOf", "Point", "BubblePoint", "BubblePoint.prototype.haloPath", "scatter", "ttBelow", "axisBeforePadding", "axisLength", "isXAxis", "dataKey", "pxMin", "pxMax", "transA", "hasActiveSeries", "bubblePadding", "ignoreHiddenSeries", "allowZoomOutside", "onPoint", "getRadii", "radii", "dataMin", "logarithmic", "keys", "Series", "ScatterSeries", "clamp", "BubbleSeries", "yData", "BubbleSeries.compose", "AxisClass", "beforePadding", "animate", "BubbleSeries.prototype.animate", "animationLimit", "hasRendered", "markerAttribs", "animation", "BubbleSeries.prototype.getRadii", "zExtremes", "bubbleZExtremes", "zMin_1", "zMax_1", "valid_1", "otherSeries", "zExtremes_1", "getZExtremes", "BubbleSeries.prototype.getRadius", "yValue", "sizeByArea", "zRange", "hasData", "BubbleSeries.prototype.hasData", "processedXData", "BubbleSeries.prototype.pointAttribs", "BubbleSeries.prototype.translate", "translateBubble", "BubbleSeries.prototype.translateBubble", "dlBox", "BubbleSeries.prototype.getPxExtremes", "smallestSize", "plotWidth", "plotHeight", "getPxSize", "isPercent", "parseInt", "BubbleSeries.prototype.getZExtremes", "z", "states", "hover", "radiusPlus", "softThreshold", "halo", "turboThreshold", "zoneAxis", "applyZones", "buildKDTree", "parallelArrays", "trackerGroups", "specialGroup", "target", "ColumnRangePoint", "ColumnRangePoint.prototype.isValid", "arearange", "columnRangeOptions", "pointRange", "ColumnRangeSeries", "ColumnRangeSeries.prototype.setOptions", "stacking", "ColumnRangeSeries.prototype.translate", "startAngleRad", "isRadial", "safeDistance", "chartWidth", "chartHeight", "heightDifference", "start", "minPointLength", "rectPlotY", "barX", "shapeType", "arc", "pointWidth", "ColumnRangeSeries.prototype.pointAttribs", "translate3dPoints", "ColumnRangeSeries.prototype.translate3dPoints", "translate3dShapes", "ColumnRangeSeries.prototype.translate3dShapes", "adjustForMissingColumns", "crispCol", "drawGraph", "getSymbol", "drawTracker", "getColumnMetrics", "colProto", "ColumnPyramidSeries", "ColumnPyramidSeries.prototype.translate", "dense", "closestPointRange", "translatedThreshold", "getThreshold", "metrics", "seriesBarW", "barW", "pointXOffset", "offset", "pointPadding", "barY", "barH", "stackHeight", "stackTotal", "total", "topPointY", "topXwidth", "bottomXwidth", "x3", "x4", "invBarPos", "ErrorBarSeriesDefaults", "grouping", "linkedTo", "ErrorBarSeries", "ErrorBarSeries.prototype.getColumnMetrics", "linkedParent", "columnMetrics", "ErrorBarSeries.prototype.drawDataLabels", "valKey", "ErrorBarSeries.prototype.toYData", "GaugePoint", "GaugePoint.prototype.setState", "pInt", "GaugeSeries", "GaugeSeries.prototype.translate", "generatePoints", "dialOptions", "dial", "baseLength", "rearLength", "baseWidth", "topWidth", "overshoot", "rotation", "endAngleRad", "GaugeSeries.prototype.drawPoints", "pivot", "pivotOptions", "GaugeSeries.prototype.animate", "GaugeSeries.prototype.render", "plotGroup", "seriesGroup", "clip", "clipRect", "setData", "GaugeSeries.prototype.setData", "processData", "GaugeSeries.prototype.hasData", "borderRadius", "crop", "defer", "headerFormat", "showInLegend", "fixedBox", "forceDL", "noSharedTooltip", "onChartLoad", "mousedownUnbinder", "mousemoveUnbinder", "mouseupUnbinder", "container", "event", "hasDraggableNodes", "draggable", "onMouseDown", "onMouseMove", "ownerDocument", "onMouseUp", "DragNodesComposition", "normalizedEvent", "pointer", "normalize", "fixedPosition", "inDragMode", "diffX", "diffY", "graphLayoutsLookup", "newPlotX", "newPlotY", "hasDragged", "redrawHalo", "restartSimulation", "_event", "enableSimulation", "fixedDraggable", "A", "onChartAfterPrint", "updateSimulation", "onChartBeforePrint", "onChartPredraw", "stop", "onChartRender", "afterRender", "layoutStep", "maxIterations", "isFinite", "temperature", "isStable", "beforeStep", "systemsStable", "setAnimation", "GraphLayoutComposition", "integrations", "layouts", "PackedBubblePoint", "degree", "NaN", "mass", "PackedBubblePoint.prototype.destroy", "removeElementFromCollection", "nodes", "firePointEvent", "PackedBubblePoint.prototype.firePointEvent", "seriesOptions", "isParentNode", "parentNode", "temp", "allowPointSelect", "select", "PackedBubblePoint.prototype.select", "getSelectedPoints", "getSelectedParentNodes", "bubble", "PackedBubbleSeriesDefaults", "crisp", "useSimulation", "parentNodeFormatter", "name", "parentNodeTextPath", "padding", "transition", "layoutAlgorithm", "initialPositions", "initialPositionRadius", "parentNodeLimit", "seriesInteraction", "dragBetweenSeries", "parentNodeOptions", "gravitationalConstant", "maxSpeed", "type", "integration", "splitSeries", "friction", "VerletIntegration", "attractive", "link", "force", "distanceXY", "massFactor", "getMass", "translatedX", "diffTemperature", "translatedY", "fromNode", "toNode", "attractiveForceFunction", "k", "barycenter", "xFactor", "yFactor", "top", "node", "getK", "integrate", "dispX", "prevX", "dispY", "prevY", "signX", "signY", "vectorLength", "repulsive", "factor", "repulsiveForceFunction", "PackedBubbleIntegration", "centerX", "centerY", "repNode", "EulerIntegration", "distanceR", "getDegree", "phi", "QuadTreeNode", "isInternal", "isEmpty", "body", "boxSize", "divideBox", "QuadTreeNode.prototype.divideBox", "halfHeight", "getBoxPosition", "QuadTreeNode.prototype.getBoxPosition", "insert", "QuadTreeNode.prototype.insert", "depth", "newQuadTreeNode", "updateMassAndCenter", "QuadTreeNode.prototype.updateMassAndCenter", "pointMass", "QuadTree", "maxDepth", "root", "isRoot", "calculateMassAndCenter", "QuadTree.prototype.calculateMassAndCenter", "visitNodeRecursive", "insertNodes", "QuadTree.prototype.insertNodes", "QuadTree.prototype.visitNodeRecursive", "beforeCallback", "afterCallback", "goFurther", "qtNode", "GraphLayout", "win", "isFunction", "ReingoldFruchtermanLayout", "attractiveForce", "currentStep", "initialRendering", "links", "repulsiveForce", "quadTree", "simulation", "ReingoldFruchtermanLayout.compose", "euler", "verlet", "ReingoldFruchtermanLayout.prototype.init", "setInitialRendering", "approximation", "ReingoldFruchtermanLayout.prototype.updateSimulation", "enable", "ReingoldFruchtermanLayout.prototype.start", "forces", "initPositions", "finishedAnimating", "setK", "resetSimulation", "ReingoldFruchtermanLayout.prototype.step", "allSeries", "createQuadTree", "anyLayout", "forceName", "applyLimits", "coolDown", "startTemperature", "prevSystemTemperature", "systemTemperature", "getSystemTemperature", "cancelAnimationFrame", "requestAnimationFrame", "ReingoldFruchtermanLayout.prototype.stop", "setArea", "ReingoldFruchtermanLayout.prototype.setArea", "w", "ReingoldFruchtermanLayout.prototype.setK", "linkLength", "addElementsToCollection", "ReingoldFruchtermanLayout.prototype.addElementsToCollection", "elements", "collection", "element", "ReingoldFruchtermanLayout.prototype.removeElementFromCollection", "clear", "ReingoldFruchtermanLayout.prototype.clear", "ReingoldFruchtermanLayout.prototype.resetSimulation", "forcedStop", "setMaxIterations", "setTemperature", "setDiffTemperature", "ReingoldFruchtermanLayout.prototype.restartSimulation", "ReingoldFruchtermanLayout.prototype.setMaxIterations", "ReingoldFruchtermanLayout.prototype.setTemperature", "ReingoldFruchtermanLayout.prototype.setDiffTemperature", "ReingoldFruchtermanLayout.prototype.setInitialRendering", "ReingoldFruchtermanLayout.prototype.createQuadTree", "ReingoldFruchtermanLayout.prototype.initPositions", "setCircularPositions", "setRandomPositions", "ReingoldFruchtermanLayout.prototype.setCircularPositions", "rootNodes", "linksTo", "visitedNodes", "addToNodes", "linksFrom", "id", "sortedNodes", "rootNode", "node_1", "iEnd", "cos", "sin", "ReingoldFruchtermanLayout.prototype.setRandomPositions", "nodesLength", "unrandom", "n", "rand", "ReingoldFruchtermanLayout.prototype.force", "barycenterForces", "ReingoldFruchtermanLayout.prototype.barycenterForces", "getBarycenter", "ReingoldFruchtermanLayout.prototype.getBarycenter", "systemMass", "barnesHutApproximation", "ReingoldFruchtermanLayout.prototype.barnesHutApproximation", "quadNode", "getDistXY", "theta", "goDeeper", "repulsiveForces", "ReingoldFruchtermanLayout.prototype.repulsiveForces", "_loop_1", "this_1", "_e", "attractiveForces", "ReingoldFruchtermanLayout.prototype.attractiveForces", "ReingoldFruchtermanLayout.prototype.applyLimits", "nodes_2", "applyLimitBox", "ReingoldFruchtermanLayout.prototype.applyLimitBox", "ReingoldFruchtermanLayout.prototype.coolDown", "temperatureStep", "ReingoldFruchtermanLayout.prototype.isStable", "ReingoldFruchtermanLayout.prototype.getSystemTemperature", "ReingoldFruchtermanLayout.prototype.vectorLength", "vector", "getDistR", "ReingoldFruchtermanLayout.prototype.getDistR", "nodeA", "nodeB", "ReingoldFruchtermanLayout.prototype.getDistXY", "xDist", "yDist", "absX", "absY", "chartGetSelectedParentNodes", "selectedParentsNodes", "onChartBeforeRedraw", "allDataPoints", "PackedBubbleLayout", "PackedBubbleLayout.compose", "packedbubble", "PackedBubbleLayout.prototype.beforeStep", "calculateParentRadius", "PackedBubbleLayout.prototype.isStable", "tempDiff", "PackedBubbleLayout.prototype.setCircularPositions", "PackedBubbleLayout.prototype.repulsiveForces", "neighbours", "PackedBubbleLayout.prototype.applyLimitBox", "parentNodeRadius", "seriesProto", "fireEvent", "PackedBubbleSeries", "parentNodeMass", "xData", "PackedBubbleSeries.compose", "accumulateAllPoints", "PackedBubbleSeries.prototype.accumulateAllPoints", "is", "addLayout", "PackedBubbleSeries.prototype.addLayout", "layoutOptions", "layoutType", "chartOptions", "graphLayoutsStorage", "forExport", "collisionNmb", "addSeriesLayout", "PackedBubbleSeries.prototype.addSeriesLayout", "seriesLayout", "parentNodeLayout", "createParentNodes", "PackedBubbleSeries.prototype.calculateParentRadius", "bBox", "seriesBox", "parentPadding", "minParentRadius", "calculateZExtremes", "PackedBubbleSeries.prototype.calculateZExtremes", "valMin", "Infinity", "valMax", "checkOverlap", "PackedBubbleSeries.prototype.checkOverlap", "bubble1", "bubble2", "PackedBubbleSeries.prototype.createParentNodes", "nodeAdded", "parentMarkerOptions", "brighten", "normal", "dataLabelOnNull", "deferLayout", "PackedBubbleSeries.prototype.deferLayout", "PackedBubbleSeries.prototype.destroy", "PackedBubbleSeries.prototype.drawDataLabels", "formatPrefix", "PackedBubbleSeries.prototype.drawGraph", "nodeMarker", "parentOptions", "opacity", "parentNodesGroup", "parentAttribs", "graph", "PackedBubbleSeries.prototype.drawTracker", "div", "getPointRadius", "PackedBubbleSeries.prototype.getPointRadius", "extremes", "allDataPointsLength", "prop", "minRadius", "maxRadius", "PackedBubbleSeries.prototype.init", "eventsToUnbind", "isDirty", "PackedBubbleSeries.prototype.onMouseUp", "dnPoint", "removed", "layout_1", "distanceXY_1", "distanceR_1", "addPoint", "remove", "placeBubbles", "PackedBubbleSeries.prototype.placeBubbles", "positionBubble", "bubblePos", "stage", "arr", "sortedArr", "sort", "calculatedBubble", "stages", "rawPositions", "resizeRadius", "PackedBubbleSeries.prototype.pointAttribs", "markerOptions", "PackedBubbleSeries.prototype.positionBubble", "lastBubble", "newOrigin", "nextBubble", "asin", "acos", "alfa", "beta", "finalAngle", "sinA", "cosA", "PackedBubbleSeries.prototype.render", "PackedBubbleSeries.prototype.resizeRadius", "positions", "minY", "maxY", "minX", "POSITIVE_INFINITY", "maxX", "NEGATIVE_INFINITY", "position", "smallerDimension", "spaceRatio", "PackedBubbleSeries.prototype.seriesBox", "setVisible", "PackedBubbleSeries.prototype.setVisible", "PackedBubbleSeries.prototype.translate", "positions_3", "axisTypes", "isCartesian", "requireSorting", "indexateNodes", "searchPoint", "LegendSymbol", "LineSeries", "line", "PolygonSeries", "PolygonSeries.prototype.getGraphPath", "PolygonSeries.prototype.drawGraph", "stickyTracking", "followPointer", "drawRectangle", "StackItem", "WaterfallAxis", "onAfterBuildStacks", "stacks", "waterfall", "changed", "alreadyChanged", "onAfterRender", "stackLabelOptions", "stackLabels", "renderStackTotals", "onBeforeRedraw", "onInit", "Composition", "Composition.prototype.renderStackTotals", "waterfallStacks", "stackTotalGroup", "dummyStackItem", "stackItem", "WaterfallPoint", "getClassName", "WaterfallPoint.prototype.getClassName", "isSum", "isIntermediateSum", "WaterfallPoint.prototype.isValid", "Axis", "WaterfallSeries", "stackedYNeg", "stackedYPos", "stackKey", "WaterfallSeries.prototype.generatePoints", "processedYData", "WaterfallSeries.prototype.translate", "halfMinPointLength", "actualStack", "previousIntermediate", "previousY", "pointY", "actualStackX", "stackState", "stateIndex", "absolutePos", "absoluteNeg", "posTotal", "negTotal", "connectorThreshold", "reversed", "yPos", "hPos", "setOffset", "minPointLengthOffset", "tooltipY", "isPointInside", "WaterfallSeries.prototype.processData", "dataLength", "subSum", "sum", "dataMax", "WaterfallSeries.prototype.toYData", "pt", "updateParallelArrays", "WaterfallSeries.prototype.updateParallelArrays", "WaterfallSeries.prototype.pointAttribs", "upColor", "WaterfallSeries.prototype.getGraphPath", "getCrispPath", "WaterfallSeries.prototype.getCrispPath", "graphNormalizer", "borderNormalizer", "reversedXAxis", "reversedYAxis", "pointArgs", "prevPoint", "prevArgs", "prevStack", "isPos", "prevStackX", "nextLast", "last", "WaterfallSeries.prototype.drawGraph", "WaterfallSeries.prototype.setStackedPoints", "calculateStackState", "firstS", "nextS", "sInx", "sOff", "statesLen", "seriesThreshold", "stackThreshold", "interSum", "xLength", "actualSum", "prevSum", "usePercentage", "totalYVal", "yVal", "xPoint", "getExtremes", "WaterfallSeries.prototype.getExtremes", "stackX", "lineWidthPlus", "getZonesGraphs", "showLine", "AxisDefaults", "relativeLength", "RadialAxis", "beforeSetTickPositions", "autoConnect", "isCircular", "userMax", "categories", "createLabelCollector", "tickPositions", "map", "createLabelCollectorHidden", "getCrosshairPosition", "end", "getPosition", "getLinePath", "_lineWidth", "r", "horiz", "open", "innerR", "xBounds", "yBounds", "angleRad", "getOffset", "axisOffset", "side", "radiusToPixels", "percentRegex", "fullRadius", "thickness", "gridLineInterpolation", "getPlotLinePath", "transFrom", "transTo", "xOnPerimeter", "isCrosshair", "paneInnerR", "otherAxis", "crossPos", "innerRatio", "slice", "translatedVal", "getTitlePosition", "titleOptions", "title", "middle", "modify", "setAxisSize", "setAxisTranslation", "onAxisAfterInit", "paneOptions", "fullCircle", "normalizedStart", "normalizedEnd", "onAxisAutoLabelAlign", "preventDefault", "onAxisDestroy", "labelCollectors", "labelCollector", "onAxisInit", "isX", "isHidden", "paneIndex", "userOptions", "radialAxis", "renderHidden", "setTitle", "setCategories", "defaultPolarOptions", "defaultRadialGaugeOptions", "defaultCircularOptions", "defaultXAxisOptions", "defaultYAxisOptions", "defaultRadialOptions", "reversedStacks", "onAxisInitialAxisTranslation", "onTickAfterGetLabelPosition", "labelBBox", "labelOptions", "correctAngle", "labelYPosCorrection", "optionsY", "centerSlot", "labelDir", "reducedAngle1", "reducedAngle2", "ret", "styles", "tickInterval", "onTickAfterGetPosition", "sector", "minPixelPadding", "minPointOffset", "plotBands", "wrapTickGetMarkPath", "tickLength", "tickWidth", "endPoint", "gridLineWidth", "textOverflow", "maxPadding", "minPadding", "showLastLabel", "minorGridLineWidth", "minorTickInterval", "minorTickLength", "minorTickPosition", "minorTickWidth", "tickPosition", "TickClass", "getConnectors", "segment", "calculateNeighbours", "addedNumber", "prevPointInd", "previousPoint", "nextPoint", "nextX", "nextY", "leftContX", "smoothing", "denom", "leftContY", "rightContX", "rightContY", "dLControlPoint", "dRControlPoint", "leftContAngle", "jointAngle", "rightContAngle", "prevPointCont", "onChartAfterDrawChartBox", "onChartAfterInit", "startOnTick", "endOnTick", "onChartGetAxes", "onPointerGetSelectionBox", "linearAxis", "result", "onPointerGetSelectionMarkerAttrs", "mouseDownX", "mouseDownY", "attrs", "zoomHor", "paneRadRange", "pathStart", "toValue", "pathEnd", "trimPath", "zoomVert", "linearAxis_1", "innerPath", "outerPath", "__spreadArray", "radialAxis_1", "onSeriesAfterInit", "PolarAdditions", "isRadialSeries", "isRadialBar", "onSeriesAfterTranslate", "chart_1", "kdByAngle", "searchPointByAngle", "findNearestPointBy", "preventPostTranslate", "toXY", "hasParallelCoordinates", "MIN_VALUE", "hasClipCircleSetter", "circ", "clipCircle", "uniqueKey", "clipPath", "createElement", "defs", "wrapper", "setClip", "searchKDTree", "clientX", "lastTick", "find", "firstTick", "unshift", "wrapChartGet", "wrapColumnSeriesAlignDataLabel", "alignTo", "labelPos", "getPrototypeOf", "wrapColumnSeriesTranslate", "visibleRange", "thresholdAngleRad", "yMin", "yMax", "pointX", "stack", "stackValues", "getStackIndicator", "wrapLineSeriesGetGraphPath", "firstValid", "popLastPoint", "pop", "wrapPointerGetCoordinates", "wrapPointerPinch", "wrapSeriesAnimate", "markerGroup", "pie", "isSVG", "animObject", "scaleX", "scaleY", "wrapSplineSeriesGetPointSpline", "pack", "l", "ar", "PolarAdditions.compose", "PointerClass", "AreaSplineRangeSeriesClass", "ColumnSeriesClass", "LineSeriesClass", "SplineSeriesClass", "pointerProto", "PolarAdditions.prototype.arc", "PolarAdditions.prototype.toXY", "polarPlotX", "Legend", "Tick", "areasplinerange"]
}
